{"meta":{"title":"KAIGE","subtitle":null,"description":null,"author":"KAIGE","url":"https://www.kaige1220.top"},"pages":[{"title":"","date":"2018-07-16T04:38:10.338Z","updated":"2018-07-16T04:38:10.338Z","comments":true,"path":"baidu_verify_PSANnWPWBN.html","permalink":"https://www.kaige1220.top/baidu_verify_PSANnWPWBN.html","excerpt":"","text":"PSANnWPWBN"},{"title":"categories","date":"2018-07-19T07:54:49.000Z","updated":"2018-07-19T07:55:48.991Z","comments":true,"path":"categories/index.html","permalink":"https://www.kaige1220.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-19T07:53:59.000Z","updated":"2018-07-19T07:55:25.308Z","comments":true,"path":"tags/index.html","permalink":"https://www.kaige1220.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"我的2019持股","slug":"我的2019持股","date":"2019-01-07T03:07:30.810Z","updated":"2019-01-07T03:32:00.006Z","comments":true,"path":"2019/01/07/我的2019持股/","link":"","permalink":"https://www.kaige1220.top/2019/01/07/我的2019持股/","excerpt":"","text":"从今年开始，我会持续跟踪我的投资收益，年末会做一个说明。 我的2019持股：以正合： 行业 标的 持仓 保险 中国平安 15% 空调 格力电器 10% 指数 500etf 10% 以奇胜： 行业 标的 持仓 农业产品 新希望 20% 细胞工程 中原协和 15% 建筑行业 晋亿实业 15% 特高压 许继电器 15% 投资系统参考（包括：选股系统、风险控制、买点系统、卖点系统）：我的投资体系：不断进化中 一年算，计算我的年度收益率！ 19年末再来看！","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"我的2019持股","slug":"投资/我的2019持股","permalink":"https://www.kaige1220.top/categories/投资/我的2019持股/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"我的2019持股","slug":"我的2019持股","permalink":"https://www.kaige1220.top/tags/我的2019持股/"}]},{"title":"年初选股初探","slug":"2019选股","date":"2019-01-04T03:08:12.609Z","updated":"2019-01-04T08:36:30.201Z","comments":true,"path":"2019/01/04/2019选股/","link":"","permalink":"https://www.kaige1220.top/2019/01/04/2019选股/","excerpt":"","text":"引自：心静如水-容大 保险： 平安 券商： 东财 银行： 平银 电器： 格力 老板 特高压： 许继 平高 医药 药名康德 养殖： 温氏 新希望 正邦 牧原 基建： 中国建筑 科技： 大族 尽可能中长线持有，如果手痒，一定是短线并且是少量仓位。 引自 量化选股 守正： 买业绩好的核心资产大蓝筹！ 出奇： 买业绩反转、业绩持续增长的小盘股 （流动性不足的情况下，赌徒只会炒小）","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"年初选股初探","slug":"投资/年初选股初探","permalink":"https://www.kaige1220.top/categories/投资/年初选股初探/"}],"tags":[{"name":"年初选股初探","slug":"年初选股初探","permalink":"https://www.kaige1220.top/tags/年初选股初探/"}]},{"title":"The new hard parts（异步编程）","slug":"The new hard part","date":"2019-01-04T00:35:28.738Z","updated":"2019-01-04T10:09:23.953Z","comments":true,"path":"2019/01/04/The new hard part/","link":"","permalink":"https://www.kaige1220.top/2019/01/04/The new hard part/","excerpt":"","text":"Javascript 内部机制是同步的， 要想异步靠的是浏览器的API 比如：setTimeout() 事件循环，首先执行的是javascript同步代码，被压入浏览器任务队列中的代码，只有等到javascript的代码执行完毕，才能回到javascript里 1、 promisefetch 获取数据，保存起来，什么时候调用还不知道，所以它被存储在未来的数据中。 当我们处理Web浏览器时，我们将从互联网上获取数据。xhr是我们正在使用的网络浏览器功能。它是浏览器的一个特殊功能。 获取的数据被分配到promise对象里。它不仅在Web浏览器中执行操作，而且还在JavaScript中执行操作。 总结： 双向执行（非阻塞） 在获取网络数据的同时，我们还在执行javascript同步代码，这些数据接受后放在promise对象里，先执行完javascript里的同步代码，然后通过then方法依次执行promise的操作。解决回调地狱。让代码看起来像同步方式一样。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"大师系列","slug":"技术/大师系列","permalink":"https://www.kaige1220.top/categories/技术/大师系列/"},{"name":"The new hard parts","slug":"技术/大师系列/The-new-hard-parts","permalink":"https://www.kaige1220.top/categories/技术/大师系列/The-new-hard-parts/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"The new hard parts","slug":"The-new-hard-parts","permalink":"https://www.kaige1220.top/tags/The-new-hard-parts/"},{"name":"异步编程","slug":"异步编程","permalink":"https://www.kaige1220.top/tags/异步编程/"}]},{"title":"年终投资体系总结","slug":"年终选股系统总结","date":"2019-01-02T06:26:32.298Z","updated":"2019-01-04T05:13:19.607Z","comments":true,"path":"2019/01/02/年终选股系统总结/","link":"","permalink":"https://www.kaige1220.top/2019/01/02/年终选股系统总结/","excerpt":"今年的主要目标：1、多思考，多学习！ 2、进一步完善投资体系！ 3、能取得一定的收益（随缘，不预测，不期望！）","text":"今年的主要目标：1、多思考，多学习！ 2、进一步完善投资体系！ 3、能取得一定的收益（随缘，不预测，不期望！） 初入股市的小菜鸟，希望能不断进化吧！在总结之前先感谢一下对我影响比较大的老师们： 陶博士：主要从他那里学到了动量效应和反转效应，进而指导投资思路。 省心省力：让我看到一个人敢于直面自己，耐心坚持的可贵！ 心静如水-容大： 从他那里学到了我个人认为比较理想的价值投资方法。 好了，总结下投资体系！ 统筹大局1、 行业选择（主）行业趋势、政策（需要关注人民日报、新闻等各种政策面） 大金融（银行保险券商）、5G、物流、医疗器械、生活消费、 2、大盘走势判断任何时候股价下跌都不是买入的理由、而是出现曙光，别人却熟视无睹的时候，大多时候要学会等待 选股标准基本面选股标准1、每股收益过去三年的增加2、年度收益在25%—50%3、ROE 净收益/股本 至少17%4、近几个季度的收益不能低于年度收益5、当季季度收益同上年同季度收益对比6、当季季度收益在25%以上7、股东人数下降股价有所升高8、关注企业的曙光而不是宏观 非基本面选股标准：1、背柄区域调整幅度介于最高点的8%–12%2、背柄应该在10周线以上3、不要抄底买进，而是等突破的合适价位买进，突破后涨幅超过5%就不要进行买入了。4、vcp收缩的时间买入，量收缩买入5、背柄区域的价格不能跳跃太大6、平底形态一般持续5-6周的时间。7、股票强度（短期强度没有意义，最少一年）8、趋势判断 看个股月线和周线处于什么趋势9、量能判断10、预期差 预期一致不会导致股价升高。（大分歧就是要干，一致的时候就是卖给别人的时候） 买入法则如果在一只股票的上升阶段买入，那么股价有可能走高，也有可能掉头向下。概率为1：1； 但如果在股价回调之后的爬升阶段买入，胜算的机会就会加大！坚实的底部支撑 横盘够长！神奇支撑线 多数情况位于 10周移动均线 附近 ，估计轻触神奇支撑线后的几周内。 缓慢收紧 放量升高（突破过程中放量多少？）—–回撤—–形成杯柄—-成交量缩小—-到达神奇支撑线（神奇支撑线追上股价）——–买入经过充分调整 回调到30到60 日线可以考虑 MVP法则M 代表动量 股票在15d内有12d上涨v 交易量 在15d 内，交易量增加了25%以上p 价格 股价在15d内， 涨幅增加了20以上 等待一个自然回调或一个新的基地形成。 如果没有像预期内一样发展 1、 突破基底后，价格应始终保持在20日均线上方。 我会建仓一般，如果低于50日线，我会卖掉。 2、 股价连续三天下跌 当天没有收回振幅上半部分，卖掉。 3、 低交易量买入，高交易量卖出是个危险的信号。 成功总结：卖出比买入更重要关注周线图周线图处于横盘期时是比较好的买点买入延神奇支撑线展开的股票成交量减少，股价与神奇支撑线重合是好的买点不要急于买入你看好的标的，要等待，等待非常关键！做一名波段交易者 几周—-几月 如果是超级大牛股甚至持有一年多！在别人恐惧的时候买入，学会控制自己的情绪不要让别人影响你的投资决策！只投资你了解的股票，不要过度分化上涨过程中不要加仓，所以在合适的位置仓位一定是放大的 风险管控1、慎重初战，先让自己立于不败之地（不亏损或者将亏损控制住在一个很小的范围）小仓位尝试。2、选股不要贪多，也不要单一，一般选择三到四个3、看不懂的不要选择，尊重自己的选股系统，而不是被情绪左右4、在你进入一个标的的时候，需要考虑胜率多少； 亏损的概率多少； 持股的周期多久 ； 给予多少仓位合适 ； 所以这种情况都是提前想好的，而不是随随便便就买入的。（重点是胜率而不是赔率！） 5、 根据不同的选股方法考虑不同的持股周期，分为中（2-3个月）、长（1-2年）、短（一周内） 6、投资组合 7、风险控制的重要性 顺势 &gt; 仓位控制（承认自己的无知） &gt; 买点（宁可错过不可买错） &gt; 看错了止损 顺势：趋势运行有两个自然属性： 趋势的延续和趋势的翻转。 强制恒强、顺势而为，讲的的是趋势的延续； 盛极而衰、否极泰来讲的是趋势的反转。 这就牵扯到 动量效应和反转效应。 动量效应： 是在一个趋势已经形成的基础上，寻求趋势的延续。 这个对应到投资就是寻求第二阶段的主升浪，属于右侧买入法则。 （更时候在牛市情况下） 这个和欧奈尔的操作体系差不多，用到的就是动量效应，适合与牛市。 反转效应：个股经历充分的甚至极端的下跌，寻求安全边际的股票进行买入。这个适合熊市操作。 仓位控制关于持仓比例的问题以20万为例 12.5% 的比例一个标的的话 就是投入2.5万 你的止损点为10% 25% 的比例 就是投入5万， 你的止损点为5% 头寸永远不要超过50% 也就是10万 通常持有4到5个票最为稳妥。选择最好的。 不要太早的卖出领头羊股票 关于止损说明：市场环境不好的情况下： 1、收紧止损线 5-6%2、更早止盈 10% - 15%3、头寸大小减少 卖出法则使用卖半规则 1、当你的股票获得的不菲的收益，你不值得是不是需要卖出，如果出现回撤，你可以尝试卖掉一半。2、大幅度脱离神奇线（最常见的是10周线）3、数基地， 第一个到第三个基地都是好的买入机会， 第五个到第六个就比较危险了。4、股价出现剧烈波动时5、高点跳空6、当你感觉成了投资天才时7、恐惧不是卖出的信号！ 根据市场情况的分类法则1、在低风险偏好的情况下，市场更加注重估值和现金流，这时价值投资和套利策略是优先选择； 2、在市场处于中等风险偏好的情况下，市场注重企业的增长速度，这是成长股投资和阿尔法策略是优先选择； 3、在市场处于高风险偏好的情况下，市场更加注重企业的远景规划，这时候事件驱动和指数增强策略是优先选择。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"年终投资体系总结","slug":"投资/年终投资体系总结","permalink":"https://www.kaige1220.top/categories/投资/年终投资体系总结/"}],"tags":[{"name":"年终投资体系总结","slug":"年终投资体系总结","permalink":"https://www.kaige1220.top/tags/年终投资体系总结/"}]},{"title":"ES6知识的学习","slug":"ES6知识的学习","date":"2018-12-20T05:42:23.101Z","updated":"2018-12-25T08:00:12.733Z","comments":true,"path":"2018/12/20/ES6知识的学习/","link":"","permalink":"https://www.kaige1220.top/2018/12/20/ES6知识的学习/","excerpt":"这不是一个完整的ES6教程。 箭头函数 1234567()=&gt;3x+.3(...x)=&gt;3(x,y)=&gt;3x=&gt;&#123;try&#123;3;&#125; catch(e)&#123;&#125;&#125; //try catch 需要大括号包裹x=&gt;&#123;return 3;&#125; //虽然箭头函数可以不用大括号，但是也可以用x=&gt;(&#123;x:y&#125;) //对象圆括号包裹","text":"这不是一个完整的ES6教程。 箭头函数 1234567()=&gt;3x+.3(...x)=&gt;3(x,y)=&gt;3x=&gt;&#123;try&#123;3;&#125; catch(e)&#123;&#125;&#125; //try catch 需要大括号包裹x=&gt;&#123;return 3;&#125; //虽然箭头函数可以不用大括号，但是也可以用x=&gt;(&#123;x:y&#125;) //对象圆括号包裹 1. 箭头函数是匿名的它们在语法上是匿名的，没有办法在语法上给箭头函数命名。你不能在箭头符号之前或之后添加一些额外的名称或类似的东西。所以现在大多数人可能没有想太多关于它是否具有名称功能的不同之处？ 举几个例子： 其中命名函数表达式实际上比匿名函数好很多。任何时候你的函数需要自我引用，通常是递归。但是在其他情况下，您的函数可能想要自己引用。 在运行一次后需要解除绑定的事件处理程序需要对自身进行自引用。如果它是匿名函数，则您没有方便的语法自引用。所以你依赖于一些可能指向事物的蹩脚外部变量。匿名函数失败的另一个例子是匿名函数在堆栈跟踪中显示为匿名函数。 2. 箭头函数和this自带绑定this ，这就是我们为何要使用它的原因 比如我们如果异步调用函数，如果不绑定this可能会出错。而箭头函数自带绑定this。 3. let vs var vs const123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function foo(x,y)&#123; var z = x*2;// 作者建议在函数顶端声明用var var 说明是全局使用，而let说明是在代码块中使用。//变量的第一次使用尽可能接近声明该变量。 let z; try&#123; z = bar(x*2); &#125;catch(err)&#123; &#125; // var 使用在if语句中if()&#123; var w = var r = &#125;else if()&#123; var w = var r = &#125;else&#123; var var &#125; if(x&gt;y)&#123; let temp = x; x = y; y = temp; &#125;// 在for 中使用 let for(let i=0; i&lt;10; i++)&#123; $(\"btn\"+i).click(function()&#123; console.log(\"button\" + i +\"click\") &#125;); &#125; //const 作者认为const 应该用在实际不变的常量上，比如 const PI = 3.14 有时候使用const 未来性能的考虑，我们需要垃圾回收。如果使用const那么你会多写一些代码。 const x = [1,2,3,4]; x[0] = 10; const x = Object.freeze([1,2,3,4])&#125; 默认值 参数收集运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//默认值function foo(x = 42)&#123;&#125;foo() ? //42foo(2) ? //2foo.apply(null,[]) ? //42foo.apply(null,[,]) ? //42//懒惰性function require()&#123; throw \"parameter require!\"&#125;function foo(id = require())&#123;&#125;var x = 1;function foo(x = 2, f = funcion()&#123;return x;&#125;)&#123; console.log(f());&#125;foo() ? //2var x = 1;function foo(x = 2, f = funcion()&#123;return x;&#125;)&#123; var x =5; console.log(f());&#125;foo() ? //2//参数收集运算符function foo(...args)&#123; args.unshift(42); bar(...args);&#125;function foo(...args)&#123; bar(42,...args)&#125; 解构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154function foo()&#123; return [1,2,3]&#125;//一var temp = foo();var a = temp[0];var b = temp[1];var c = temp[3];//二// 有默认值么？var [ a, b = 42, c] = foo()// 防止抛出错误function foo()&#123; return null&#125;var [ a, b = 42, c] = foo() || [];//多参数function foo()&#123; return [1,2,3,4,5,6]&#125;var [ a, b = 42, c, ...args] = foo() || [];//优化function foo()&#123; return [1,2,3,4,5,6]&#125;var a,b,c,args;[ a, b = 42, c, ...args] = foo() || [];//存储变量var a = [1,2,3];[,, ...a] = [0,1, ...a,4];//嵌套数组解构function foo()&#123; return [1,2,3,[4,5,6]&#125;var a,b,c,d,eargs;[ a, b = 42, c, [ d, , e ]] = foo() || [];//var a,b,vals,c,d;[ ,,, [c,d]] =[a,d, ...vals] =foo()//对象解构function foo()&#123; return &#123;a:1, b:2, c:3&#125;&#125;var&#123; a, b, c&#125; = foo();//防止抛出错误var&#123; a=10, b：X =42, c&#125; = foo() || &#123;&#125;;//解构嵌套对象function foo()&#123; return &#123;a:1, b:2, c:3 d:&#123; e:4 &#125; &#125;&#125;var&#123; a, b, c, d:[ e ] = []&#125; = foo();//解构和函数参数function foo([a,b,c])&#123; console.log(a,b,c);&#125;foo([1,2,3])//高级解构 模板字符串123456789101112var name = \"kaige\";var orderNumber = \"123\";var total = 312.2;var msg = \"helo\" + name + your\\order(#\"+orderNumber+\")was $\"+ total + \".\";//模板字符串var msg = `helo ,$(name&#125; ,your order(#$&#123;orderNumber&#125;)was $$&#123; total&#125;.`;//标签 特殊符号、迭代器和生成器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118symbolvar x = symbol(\"hahhh\")//按作者： symbol 表示特殊的标识，你不可以动它， 在命名属性的时候你也可以这样__name 就是加下划线以示你不可以动它哦。var obj = &#123; id: 42 [x]: \" shhhhhh this is a secret\" //用[x]拿到刚才我们定义的symbol&#125;//symbol 有一些js内置的定义符号symbol.iteratorsymbol.toStringTagsymbol.toPrimitivesymbol.isConcatSpreadable//迭代器var arr = [1,2,3];//手动迭代var it = arr[Symbol.iterator]();it.next(); //每次获取一个值，接着调用next()it.next();//自动迭代for(var v of arr)&#123; console.log(v)&#125;var str = \"hjell\"for (var v of str)&#123; console.log(v)&#125;// 注意和 for in 的区别 for in 有自己迭代的规则，比如迭代字符串会迭代的是下标。//创建自定义迭代器var obj = &#123; [Symbol.iterator]()&#123; var idx = this.start, en = this.end; var it = &#123; next: ()=&gt;&#123; if(idx&lt;= en)&#123; var v = this.value[idx]; idx++; return &#123;value: v, done: false&#125;; &#125;else&#123; return &#123;done:true&#125; &#125; &#125; &#125; values: [2,4,6,8,10,12,14,16,18,20,22,24,26,28], start: 4, end: 13&#125;var vals = [... obj];// 发电机function *main()&#123; console.log(\"hello\"); yield 9; //yield不光有暂停功能，还具有 输出值的功能 console.log(\"world\"); return 10;&#125;var it = main();it.next(); //&#123;value: 9, done: false&#125;it.next(); //&#123;value: 10, done: true&#125;// 做一个迭代看看， 我们发现10没有输出。 因为yield 暂停循环。如果想输出10 把return改成yield。for(var v of main() )&#123; console.log (v)&#125;// 看看下一个例子function *main()&#123; for(var i = 0; i&lt;5; i++)&#123; yield i; &#125;&#125;for(var v of main() )&#123; console.log (v)&#125;// 让我们用发电机做上面的自定义迭代器的例子var obj = &#123; *[Symbol.iterator]()&#123; for(var i = this.start; i &lt;= this.end; i++)&#123; yield this.valuses[i]; &#125; &#125; values: [2,4,6,8,10,12,14,16,18,20,22,24,26,28], start: 4, end: 13&#125;var vals = [... obj]; 一个练习1234567891011121314151617181920212223242526var numbers = &#123; *[Symbol.iterator](&#123; start = 0, step = 1, end = 100 &#125; =&#123;&#125;)&#123; for(let i =start; i&lt;= end; i= i+step)&#123; yield i; &#125; &#125;&#125;;//打印 0 ---100 步长 1for (let num of numbers)&#123; console.log(num);&#125;// 打印6 -- 30 步长4for(let num of numbers[Symbol.iterator](&#123; start: 6, step: 4, end: 30&#125;))&#123; console.log(num)&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"大师系列","slug":"技术/大师系列","permalink":"https://www.kaige1220.top/categories/技术/大师系列/"},{"name":"ES6知识的学习","slug":"技术/大师系列/ES6知识的学习","permalink":"https://www.kaige1220.top/categories/技术/大师系列/ES6知识的学习/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.kaige1220.top/tags/函数式编程/"},{"name":"ES6知识的学习","slug":"ES6知识的学习","permalink":"https://www.kaige1220.top/tags/ES6知识的学习/"}]},{"title":"Functional-Light JavaScript（函数式编程）(3)","slug":"大师系列-函数式编程3","date":"2018-12-20T01:04:24.393Z","updated":"2018-12-25T07:52:40.374Z","comments":true,"path":"2018/12/20/大师系列-函数式编程3/","link":"","permalink":"https://www.kaige1220.top/2018/12/20/大师系列-函数式编程3/","excerpt":"数据结构的转换 1、map()12345678910111213function doubleIt(v)&#123; return v*2;&#125;function transform(arr,fn)&#123; var list = []; for(var i=0; i&lt;arr.length; i++)&#123; list[i] = fn (arr[i]); &#125; return list;&#125;transform([1,2,3,4,5],doubleIt); map() 函数区别于for循环， for循环每次只进行一次。 而map()编译器可以分离1000个线程并一次完成1000个线程。映射操作的优点之一是每个操作完全独立于任何其他操作。顺便说一句，这就是为什么sort不是map的一个例子，因为排序显然不能完全并行化，","text":"数据结构的转换 1、map()12345678910111213function doubleIt(v)&#123; return v*2;&#125;function transform(arr,fn)&#123; var list = []; for(var i=0; i&lt;arr.length; i++)&#123; list[i] = fn (arr[i]); &#125; return list;&#125;transform([1,2,3,4,5],doubleIt); map() 函数区别于for循环， for循环每次只进行一次。 而map()编译器可以分离1000个线程并一次完成1000个线程。映射操作的优点之一是每个操作完全独立于任何其他操作。顺便说一句，这就是为什么sort不是map的一个例子，因为排序显然不能完全并行化， 2、filter() 1234567891011121314151617181920212223242526function isOdd(v)&#123; return v%2 == 1;&#125;function exclude(arr,fn)&#123; var list = []; for (var i=0; i&lt;arr.length; i++)&#123; if (fn(arr[i]))&#123; list.push(arr[i]); &#125; &#125; return list;&#125;exclude([1,2,3,4,5,6],isOdd);//等同于function onlyOdds(val)&#123; return val % 2 == 1;&#125;[1,2,3,4,5,6].filter(onlyOdds); 3、reduce() 123456789101112function mult(x,y)&#123; return x*y;&#125;function combine(arr,fn,initial)&#123; var result = initial; for(var i = 0; i &lt; arr.length; i++)&#123; result = fn(result,arr[i]); &#125; return result;&#125;combine([1,2,3,4,5],mult,1); 记住reduce()需要接受两个参数。第二个参数是需要reduce的初始值，第一个参数是需要服从的规则。 map filter reduce 都不会改变原来的数组，他们会创建一个新数组； 排序sort() 反向reverse()会改变原来的数组，直&gt; 接一步到位。 另外我们还需要知道concat() 也不会改变原来数组。 4、上面几个函数的结合 &lt;未完待续&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"大师系列","slug":"技术/大师系列","permalink":"https://www.kaige1220.top/categories/技术/大师系列/"},{"name":"Functional-Light JavaScript","slug":"技术/大师系列/Functional-Light-JavaScript","permalink":"https://www.kaige1220.top/categories/技术/大师系列/Functional-Light-JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"Functional-Light JavaScript","slug":"Functional-Light-JavaScript","permalink":"https://www.kaige1220.top/tags/Functional-Light-JavaScript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.kaige1220.top/tags/函数式编程/"}]},{"title":"Functional-Light JavaScript（函数式编程）(2)","slug":"大师系列2","date":"2018-11-30T11:09:54.362Z","updated":"2018-12-03T08:43:49.307Z","comments":true,"path":"2018/11/30/大师系列2/","link":"","permalink":"https://www.kaige1220.top/2018/11/30/大师系列2/","excerpt":"接第三章","text":"接第三章 第四章 不变性(常量) 作者认为const的作用并不是很大，在定义数组的时候，我们看到数组的值是可以改变的。 作者提到了ES5里面的一个方法Object.freeze() 可以保持数据结构为只读状态。 作者 建议使用这个方法 当你不知道一个数据结构是否是一个不可变的数据结构，你应该假设你不能改变它。 所以你应该这样做： 惯例，看我们的练习题和答案 1234567891011121314151617181920212223242526272829function lotteryNum() &#123; return (Math.round(Math.random() * 100) % 58) + 1;&#125;function pickNumber(nums)&#123; // 复制一个数组先，无论它是不是不可变的。 这个数组用来存储我们选取的彩票数字 var newNums = nums.slice(); //定义变量数字存储单个选取的数字 var num; do &#123; num = lotteryNum(); &#125; while (newNums.indexOf(num) != -1); newNums.push(num); newNums.sort(function(a,b)&#123; return a - b; &#125;); return newNums;&#125;var luckyLotteryNumbers = [];for (var i = 0; i &lt; 6; i++) &#123; luckyLotteryNumbers = pickNumber( Object.freeze(luckyLotteryNumbers) );&#125;console.log(luckyLotteryNumbers); 第五章 闭包及其副作用作者给闭包下的定义： Closure is when a function”remembers” the variables aroundit even when that function is executed elsewhere.(闭包是一个函数记住它周围的变量，即使该函数在别处执行。) 还记得第一章函数的纯度么， 闭包可以实现呀。 第六章 递归学习在算法方面，有些事情表示递归更好 如果我们先做一个求和的函数，我们首先想到的肯定是这样的： 优化下会成这样： 如果用递归呢？ 头部和尾部 头部我们解决了， 现在，如果nums是长度为1，函数会多调用一次，如何解决呢？ 好了来做一个乘法的练习： 123456789101112function mult(product,num,...nums) &#123; // base case if (nums.length == 0) &#123; return product * num; &#125; // recursive (reductive) call return product * mult(num,...nums);&#125;mult(3,4,5); // 60mult(3,4,5,6); // 360 尾调用(PTC)尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 12345678910// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125; 上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。 果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。 PTC需要严格模式。如果您没有严格的模式，PTC将不会生效，因此，这些限制将对您有效。因此，您必须确保记住切换到严格模式。如果您还没有使用严格模式，这只是您应该使用严格模式的众多原因中的一个。 看到这里，我们应该知道我们之前写的求和函数不是属于正则的PTC或者叫递归函数把，因为我们把回调其他函数叫PTC。 那如何改进呢？ 答案是我可以将它作为参数传递给下一个函数 continuation Passing Style(CPS)当我们讨论的方式难以直接在PTC表单中排列时，有一种不同的方法来处理我们的算法。这种形式称为CPS，代表延续传递风格。所以，有时候你的算法会是这样的，例如，如果你需要做两个递归调用，比如二进制下降，那么两个需要在同一个函数中发生的递归调用，就没有办法同时拥有它们在最后。 Trampolines","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"大师系列","slug":"技术/大师系列","permalink":"https://www.kaige1220.top/categories/技术/大师系列/"},{"name":"Functional-Light JavaScript","slug":"技术/大师系列/Functional-Light-JavaScript","permalink":"https://www.kaige1220.top/categories/技术/大师系列/Functional-Light-JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"Functional-Light JavaScript","slug":"Functional-Light-JavaScript","permalink":"https://www.kaige1220.top/tags/Functional-Light-JavaScript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.kaige1220.top/tags/函数式编程/"}]},{"title":"冯柳旧文精选：我眼中的股市游戏","slug":"冯柳旧文精选：我眼中的股市游戏","date":"2018-11-29T02:14:49.681Z","updated":"2018-11-29T02:18:03.378Z","comments":true,"path":"2018/11/29/冯柳旧文精选：我眼中的股市游戏/","link":"","permalink":"https://www.kaige1220.top/2018/11/29/冯柳旧文精选：我眼中的股市游戏/","excerpt":"","text":"对大部分股票来说，股市就是一场游戏，明白玩法往往比其他什么更重要。而趋势、预期还有参与者的交易行为无疑是其中最重要的几个。趋势和预期决定中长线、交易行为决定短线，它们互相影响并相互强化和改变，大部分时候你分不清楚谁更重要或更占据主导地位，但有的时候，一方演化的足够强大就可以改变另一方并最终影响自己，对这样的循环与反馈进行理解将会对我们的游戏参与带来莫大的帮助。为方便逻辑阐述，下面会用简单化的数据来表达，但这不代表该比方具备现实的适用性，因为不同股票的评价方法会有很大出入，所以声明下以免误导。 先谈趋势和预期，一般来说，趋势是由预期决定，但预期可以由趋势强化并反过来再影响到趋势上，形成正反馈直至极限。在形成期，预期是最重要的因素，在演变强化期，趋势是最关键的方面，而转折期，则往往是双方极限值共振的结果，考虑到趋势的多样性和变化性特征，预期极限值的作用会更大也更容易判断一点。 在我看来，技术分析主要是找出趋势和预期同向运动并强化的机会，价值分析则可以在反向运动但最终会被预期改变的机会上下注。另外，不管是预期还是趋势，它都应包含自身和环境两方面的衡量，这也就是很多人说的，大盘不好不做个股的道理，因为大制小、小印大，个体一般都会受整体的压制和影响，并在大部分时候会最终服从于整体，当然有些先于整体走好的个体则说明其静态预期就已足以抵消整体的压制，若环境压制不进一步加强则比较容易先走出行情来。 举例来讲，比如业绩在1 元、增长率在不同条件设定下可以有正负20%甚至极限到50%的股票，考虑到事实的显现有一个漫长的时间过程，在这期间决定增长预期的选择除了基本面还有就是市场的阶段性情绪。我过去曾经说过，对股票买卖区域的设定一定要考虑牛熊市的前提，比如20 元是这个票在不考虑条件值变化下的合理估算的话，牛市应该在20 之上买入，熊市应该在20 之下卖出，因为牛市中大家会往好的方向想，总认为未来会更好，这样往往等不到合理估值区域就应该买入，而熊市中如果20 是合理的话，这个价格反而是卖点，因为事情总是在不断变坏，这样合理估值点就容易成顶部。然后再考虑到条件值选择导致的增长预期变化，那么买卖范围就可以扩大到75 到10 元上下，也就是说75 以上买乃至10 以下卖都有其合理性的解释。 在阶段性投机中，有两种机会，一是涨出来的、一是跌出来的，就我个人的偏好来说，我不太喜欢后者，因为空间是由跌出来的幅度决定，相对有限。而前者呢，就是我们经常说的那种越涨越低估的股票，因为在20 进入的时候，我们的预期是不到20%的增长，这样的目标价一般在30 元，也就是50 个点不到的空间，而一旦涨到30 以上的时候，由于趋势加强导致对预期的更乐观推动，市场开始憧憬50%的增长速度，估值定价往往可以到75 乃至100 以上，这样就变成了原先50 个点的利润目标在涨了以后反而扩大到2 到3 倍以上，而且由于趋势与预期的加强和明朗，后期目标的实现往往比前期更迅速快捷。当然，任何事物的发展都会有个极限值，在75 目标实现后，理智的人会发现，如果说20%到50%增长率在理论上有实现可能的话，超过50%的增长则是很难预期的，这样在没有新增预期来推动趋势继续加强的情况下，趋势就会变的相对平缓，从而在技术上呈现顶部特征，继而引发重新思考和趋势与预期的反向共振，负反馈就开始发生。 所以说，能否产生新增的更高预期来维持趋势进一步强化是我们参与游戏的关键。就像前段时间有朋友对我说，通货膨胀这么厉害，他也想入市保值，我回复说，你过去已经犯了不入市的错误，现在就别再犯入市的错误了，因为当全世界都想通过股市来对抗通货膨胀的时候，也许拿着现金让其自然贬值会是更好的选择，除非你能找到明确的新增预期，否则凭什么指望别人以更高的价钱来购买已经给他人提供过保值机会的资产呢。当然，如果你选择的企业足够好，能够用时间换来更高的预期则另当别论，但这和之前信奉的理由又是两回事了。 再谈下参与者的交易行为，这是比较容易影响人持仓或空仓心态的方面，很多朋友对我说，自己是真的看多或看空，但有的时候看见无数坚决的买单或卖盘的时候就总受影响以至无法坚持，否则为什么那么多资金在坚决地做和自己判断相反的事情呢。我觉得不断审视并随时准备修正自己是非常好的习惯，但为了让自己不过于敏感就必须把短期行为放到大情景下去理解，牛市里的卖出是为了更好的买入，熊市中的买入是为了更好的卖出，牛市的阻力位与熊市的支撑位都是最容易坑害人的陷阱，同样行为后面的动机和后续补救是完全不同的，你只看到了他买的时候坚决，也许之后卖的会更坚决呢，所谓看大势挣大钱、辨别牛熊再投资是非常正确的经验之谈，这样可以不为细节所遮蔽。 当然，有人会说牛熊的判断才是最难的方面，其实只要看这个市场大部分股票是否已透支其极限预期就好了，不过这样需要对整个市场都有良好的认识，如果不具备这样能力的话，那么我的建议就是只关注确定性高成长的票，它们在牛熊中都不会有太坏的预期，主要取决于其自身的成长率和时间，与市场估值关系不大，这样比较省心但要考虑错判后的风险承受问题。我认为，资产就是金钱在不同时间下的不同属性，本质就是现在的钱和未来的钱之间进行交换，买入是用现在换未来，卖出则是把未来换现在，关键要想明白未来和现在谁更值钱就好了，牛熊市就是这样的一个判断依据，当然，对极少数的优异公司来说，未来总是会强过现在的，这就是比牛熊大势更大的大势。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"股票","slug":"投资/股票","permalink":"https://www.kaige1220.top/categories/投资/股票/"},{"name":"冯柳旧文精选：我眼中的股市游戏","slug":"投资/股票/冯柳旧文精选：我眼中的股市游戏","permalink":"https://www.kaige1220.top/categories/投资/股票/冯柳旧文精选：我眼中的股市游戏/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"冯柳旧文精选：我眼中的股市游戏","slug":"冯柳旧文精选：我眼中的股市游戏","permalink":"https://www.kaige1220.top/tags/冯柳旧文精选：我眼中的股市游戏/"}]},{"title":"Functional-Light JavaScript（函数式编程）","slug":"大师系列","date":"2018-11-23T08:25:37.849Z","updated":"2018-11-30T11:10:27.672Z","comments":true,"path":"2018/11/23/大师系列/","link":"","permalink":"https://www.kaige1220.top/2018/11/23/大师系列/","excerpt":"函数式编程开启函数式编程的课程 函数式编程（FP）通过纯函数，避免共享状态，可变数据和副作用来构建程序的过程。函数式编程是声明性的而不是命令式的。","text":"函数式编程开启函数式编程的课程 函数式编程（FP）通过纯函数，避免共享状态，可变数据和副作用来构建程序的过程。函数式编程是声明性的而不是命令式的。 第一章：函数纯度可证明性与可读性：作者介绍了函数式编程的可证明性与可读性带来的优势。 最后作者提了下抽象的定义： 用单个绳子做了个比喻， 一般我们很容易用单个绳子编制成一个网，而从一个网中拿出一个绳子却比较困难。我们需要的是化繁为简。 纯粹的函数和它的副作用在最基础的意义上，我可以说一个函数是真正的函数而不仅仅是一个过程，它必须有一个return关键字。没有return语句的函数不是函数，它是一个过程。它确实需要理想地返回肯定和有用的东西。 这就是我们说的时候的意思，避免副作用。如果可能的话，我们真正的意思是避免它们。你做的任何事情，打印到控制台。向DOM添加内容。发出网络请求。写入文件。任何这些都将被输出，你需要至少做一些这样的程序才能有用，但我认为事情的本质是我们只是在整个代码中散布我们的副作用基础。 它的内部是纯粹的。它没有副作用，我们把副作用放在外壳上，所以它们很容易找到，而且它们非常明显。我喜欢这种可视化，这不仅仅是理论。事实上，我打赌你们中有很多人已经在使用已经实现了这个想法的系统。 改变其范围之外的变量的函数不是纯函数 一个比较好的判断纯函数的方法： 每次输入相同的变量得到的结果是一致的。不纯的变量由于有多余的变量，所以可能导致结果不同。 怎么去除函数中的副作用 封装 ， 我们用F()函数封装了f() 让其处于F()的词法作用域内 完全封装所有可能的副作用，以便程序的外部部分无法观察到它们。在可能的情况下，你应该这样做。 1234567891011121314151617181920212223242526272829303132333435363738394041//foo这里是一个不纯的函数，因为它确实需要一个输入x，但它也使用y作为输入。你能看出为什么用y作为输入吗？因为第2行的y ++考虑了y的当前状态。所以这是一个副作用，它也会改变y，所以这是副作用。function foo(x) &#123; y++; z = x * y;&#125;var y = 5, z;foo(20);z; // 120foo(25);z; // 175///封装： 上面那个函数是不纯的函数，因为有多余的变量（y和z） 好了，我们封装在bar里面，返回一个数组function bar(x,y)&#123; var z; foo(x); return [y,z]; function foo(x)&#123; y++; z = x*y; &#125;//创建一个接口函数，而不是把它包起来function bar(curX,curY)&#123; var [origY,orgZ] = [y,z]; y = curY; foo(curX); var [newY,newZ] = [y,z]; [y,z] = [origY,orgZ]; return [newY,newZ];&#125;&#125; 进一步理解 这个函数是纯函数么？ 大家可以思考下。 这个函数呢？ 定义一和定义二的矛盾。定义一：引用了一个变量本身之外的变量就不是纯函数。定义二：指的就是每次给一个相同的输入得到相同的输出。 &lt;未完待续&gt; 第二章：函数输入如果我有一个只接受一个参数的函数，只需要一个参数，那么这个函数有一个特殊的术语，它叫做一元函数。当然两个参数的就是二元了。 我们先理解下什么是编程的本质： 上图是一个编程任务，左侧是数据输入（input），中间是一系列的运算步骤，对数据进行加工，右侧是最后的数据输出（output）。一个或多个这样的任务，就组成了程序。 输入和输出（统称为 I/O）与键盘、屏幕、文件、数据库等相关，这些跟本文无关。这里的关键是，中间的运算部分不能有 I/O 操作，应该是纯运算，即通过纯粹的数学运算来求值。否则，就应该拆分出另一个任务。 I/O 操作往往有现成命令，大多数时候，编程主要就是写中间的那部分运算逻辑。现在，主流写法是过程式编程和面向对象编程，但是我觉得，最合适纯运算的是函数式编程。 函数的拆分与合成 1fn :: a -&gt; b 上面的式子表示，函数fn的输入是数据a，输出是数据b。 如果运算比较复杂，通常需要将fn拆分成多个函数。 f1、f2、f3的类型如下。 123f1 :: a -&gt; mf2 :: m -&gt; nf3 :: n -&gt; b 上面的式子中，输入的数据还是a，输出的数据还是b，但是多了两个中间值m和n。 我们可以把整个运算过程，想象成一根水管（pipe），数据从这头进去，那头出来。 函数的拆分，无非就是将一根水管拆成了三根。 进去的数据还是a，出来的数据还是b。fn与f1、f2、f3的关系如下。 1fn = R.pipe(f1, f2, f3); 上面代码中，我用到了 Ramda 函数库的pipe方法，将三个函数合成为一个。 好了，下面是本章的最重要的概念Pointfree1fn = R.pipe(f1, f2, f3); 这个公式说明，如果先定义f1、f2、f3，就可以算出fn。整个过程，根本不需要知道a或b。 也就是说，我们完全可以把数据处理的过程，定义成一种与参数无关的合成运算。不需要用到代表数据的那个参数，只要把一些简单的运算步骤合成在一起即可。 这就叫做 Pointfree：不使用所要处理的值，只合成运算过程。中文可以译作”无值”风格 请看下面的例子。 12var addOne = x =&gt; x + 1;var square = x =&gt; x * x; 上面是两个简单函数addOne和square。 把它们合成一个运算。 123var addOneThenSquare = R.pipe(addOne, square);addOneThenSquare(2) // 9 上面代码中，addOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。 下面是本章的练习题的答案： 12345678910111213141516171819202122232425262728293031323334353637383940//兼容浏览器var output = console.log.bind(console);//柯里化 point-free function not(predicate)&#123; return function negated(...args)&#123; return !predicate(...args); &#125;&#125;function isShortEnough(str) &#123; return str.length &lt;= 5;&#125;var isLongEnough = not(isShortEnough)//柯里化function when(fn) &#123; return function(predicate)&#123; return function(...args)&#123; if (predicate(...args)) &#123; return fn(...args); &#125; &#125;; &#125;;&#125;var printIf = when(output)var msg1 = \"Hello\";var msg2 = msg1 + \" World\";printIf(isShortEnough)(msg1); // HelloprintIf(isShortEnough)(msg2);printIf(isLongEnough)(msg1);printIf(isLongEnough)(msg2); // Hello World 第三章 构造函数我们的目的是进行函数式编程，而不仅仅是我们想要提高代码的可读性。真正的目的是在我们的代码中声明性地说明数据转换的路径是什么。任何数据，当它经历不同的步骤时，我们想要使该路径以及将沿着该路径尽可能明显地执行的步骤。 还是上述的思想，不同的小函数如何链接起来，作者给出了两个不同的方式： 一个是从左到右，一个是从右到左。 直接来看一个练习题的答案就明白了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function increment(x) &#123; return x + 1; &#125;function decrement(x) &#123; return x - 1; &#125;function double(x) &#123; return x * 2; &#125;function half(x) &#123; return x / 2; &#125;//从右到左， 因为是多个函数，所以这里用到了ES5 的知识以及用了一个循环来做， 如果就两个函数也可以直接做：// 比如： function composeRight(fn1,fn2)&#123;// return function composed(...args)&#123;// return fn1(fn2(...args));// &#125;// &#125;function compose(...fns) &#123; return function composed(result)&#123; for(var i=fns.length-1; i&gt;=0; i--)&#123; result = fns[i](result); &#125; return result; &#125;&#125;// 从左到右function pipe(...fns) &#123; return function (result)&#123; for(var i=0; i&lt;fns.length-1; i++)&#123; result = fns[1](result); &#125; return result; &#125;&#125;var f = compose(decrement,double,increment,half);var p = pipe(half,increment,double,decrement);f(3) === 4;// trueconsole.log(f(3));// 4f(3) === p(3);// true","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"大师系列","slug":"技术/大师系列","permalink":"https://www.kaige1220.top/categories/技术/大师系列/"},{"name":"Functional-Light JavaScript","slug":"技术/大师系列/Functional-Light-JavaScript","permalink":"https://www.kaige1220.top/categories/技术/大师系列/Functional-Light-JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"Functional-Light JavaScript","slug":"Functional-Light-JavaScript","permalink":"https://www.kaige1220.top/tags/Functional-Light-JavaScript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.kaige1220.top/tags/函数式编程/"}]},{"title":"V8排序源码分析1","slug":"V8 排序源码","date":"2018-11-22T08:08:45.592Z","updated":"2018-11-22T09:18:40.776Z","comments":true,"path":"2018/11/22/V8 排序源码/","link":"","permalink":"https://www.kaige1220.top/2018/11/22/V8 排序源码/","excerpt":"排序采用的算法跟数组的长度有关，当数组长度小于等于 10 时，采用插入排序，大于 10 的时候，采用快速排序。(这种说法并不严谨)。","text":"排序采用的算法跟数组的长度有关，当数组长度小于等于 10 时，采用插入排序，大于 10 的时候，采用快速排序。(这种说法并不严谨)。 插入排序 原理将第一个元素视为有序序列，遍历数组，将之后的元素依次插入这个构建的有序序列中。 12345678910111213141516171819function insertionSort(arr) &#123; for (var i = 1; i &lt; arr.length; i++) &#123; var element = arr[i]; for (var j = i - 1; j &gt;= 0; j--) &#123; var tmp = arr[j]; var order = tmp - element; if (order &gt; 0) &#123; arr[j + 1] = tmp; &#125; else &#123; break; &#125; &#125; arr[j + 1] = element; &#125; return arr;&#125;var arr = [6, 5, 4, 3, 2, 1];console.log(insertionSort(arr)); 时间复杂度 时间复杂度是指执行算法所需要的计算工作量，它考察当输入值大小趋近无穷时的情况，一般情况下，算法中基本操作重复执行的次数是问题规模 n 的某个函数。 最好情况：数组升序排列，时间复杂度为：O(n) 最坏情况：数组降序排列，时间复杂度为：O(n²) 稳定性 稳定性，是指相同的元素在排序后是否还保持相对的位置。 要注意的是对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。 比如 [3, 3, 1]，排序后，还是 [3, 3, 1]，但是其实是第二个 3 在 第一个 3 前，那这就是不稳定的排序算法。 插入排序是稳定的算法。 优势 当数组是快要排序好的状态或者问题规模比较小的时候，插入排序效率更高。这也是为什么 v8 会在数组长度小于等于 10 的时候采用插入排序。 快速排序 原理 选择一个元素作为”基准” 小于”基准”的元素，都移到”基准”的左边；大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 示例先看一个空间复杂度和时间复杂度比较高的写法（好理解）：123456789101112131415161718var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; // 取数组的中间元素作为基准 var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 还有一种原地(in-place)排序的实现方式。 在这张示意图里，基准的取值规则是取最左边的元素，黄色代表当前的基准，绿色代表小于基准的元素，紫色代表大于基准的元素。 我们会发现，绿色的元素会紧挨在基准的右边，紫色的元素会被移到后面，然后交换基准和绿色的最后一个元素，此时，基准处于正确的位置，即前面的元素都小于基准值，后面的元素都大于基准值。然后再对前面的和后面的多个元素取基准，做排序。 in-place 实现12345678910111213141516171819202122232425262728293031323334353637function quickSort(arr) &#123; // 交换元素 function swap(arr, a, b) &#123; var temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; function partition(arr, left, right) &#123; var pivot = arr[left]; var storeIndex = left; for (var i = left + 1; i &lt;= right; i++) &#123; if (arr[i] &lt; pivot) &#123; swap(arr, ++storeIndex, i); &#125; &#125; swap(arr, left, storeIndex); return storeIndex; &#125; function sort(arr, left, right) &#123; if (left &lt; right) &#123; var storeIndex = partition(arr, left, right); sort(arr, left, storeIndex - 1); sort(arr, storeIndex + 1, right); &#125; &#125; sort(arr, 0, arr.length - 1); return arr;&#125;console.log(quickSort(6, 7, 3, 4, 1, 5, 9, 2, 8)) 稳定性快速排序是不稳定的排序。 时间复杂度阮一峰老师的实现中(第一版)，基准取的是中间元素，而原地排序中基准取最左边的元素。快速排序的关键点就在于基准的选择，选取不同的基准时，会有不同性能表现。","categories":[{"name":"算法","slug":"算法","permalink":"https://www.kaige1220.top/categories/算法/"},{"name":"V8排序源码分析1","slug":"算法/V8排序源码分析1","permalink":"https://www.kaige1220.top/categories/算法/V8排序源码分析1/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"算法","slug":"算法","permalink":"https://www.kaige1220.top/tags/算法/"},{"name":"V8排序源码分析1","slug":"V8排序源码分析1","permalink":"https://www.kaige1220.top/tags/V8排序源码分析1/"}]},{"title":"前端安全系列","slug":"前端安全系列","date":"2018-11-22T07:46:10.508Z","updated":"2018-11-22T11:16:31.624Z","comments":true,"path":"2018/11/22/前端安全系列/","link":"","permalink":"https://www.kaige1220.top/2018/11/22/前端安全系列/","excerpt":"8大前端安全问题 老生常谈的XSS 警惕iframe带来的风险 别被点击劫持了 错误的内容推断 防火防盗防猪队友：不安全的第三方依赖包 用了HTTPS也可能掉坑里 本地存储数据泄露 缺失静态资源完整性校验","text":"8大前端安全问题 老生常谈的XSS 警惕iframe带来的风险 别被点击劫持了 错误的内容推断 防火防盗防猪队友：不安全的第三方依赖包 用了HTTPS也可能掉坑里 本地存储数据泄露 缺失静态资源完整性校验 拣重点来说 XXS 首先说下最常见的 XSS 漏洞，XSS (Cross Site Script)，跨站脚本攻击，因为缩写和 CSS (Cascading Style Sheets) 重叠，所以只能叫 XSS。 XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。 非持久型 XSS非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。 攻击者可以直接通过 URL (类似：https://xx.com/xx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;) 注入可执行的脚本代码。 非持久型 XSS 漏洞攻击有以下几点特征： 即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。 攻击者需要诱骗点击 反馈率低，所以较难发现和响应修复 盗取用户敏感保密信息 为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情： Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。 尽量不要从 URL，document.referrer，document.`forms` 等这种 DOM API 中获取数据直接渲染。 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法。 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。 前端渲染的时候对任何的字段都需要做 escape 转义编码。 escape 转义的目的是将一些构成 HTML 标签的元素转义，比如&lt;，&gt;，空格等，转义成 &amp;lt;，&amp;gt;，&amp;nbsp; 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。 持久型 XSS 持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，refferer，forms 等，而是来源于后端从数据库中读出来的数据。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。攻击成功需要同时满足以下几个条件： POST 请求提交表单后端没做转义直接入库。 后端从数据库中取出数据没做转义直接输出给前端。 前端拿到后端数据没做转义直接渲染成 DOM。 为了防止持久型 XSS 漏洞，需要前后端共同努力： 后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。 后端在输出给前端数据统一进行转义处理。 前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。 基于字符集的 XSS 其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。 以基于 utf-7 的 XSS 为例utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。 可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。 所以我们有什么办法避免这种 XSS 呢？ 记住指定 &lt;meta charset=&quot;utf-8&quot;&gt; XML 中不仅要指定字符集为 utf-8，而且标签要闭合 基于 Flash 的跨站 XSS 基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。 避免方法： 严格管理 cookie 的读写权限 对 Flash 能接受用户输入的参数进行过滤 escape 转义处理 未经验证的跳转 XSS 有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。 这时候需要通过以下方式来防止这类漏洞： 对待跳转的 URL 参数做白名单或者某种规则过滤 后端注意对敏感信息的保护, 比如 cookie 使用来源验证。 OK, 看看具体的案例把：实现一个搜索功能： 12345&lt;input type=\"text\" value=\"&lt;%= getParameter(\"keyword\") %&gt;\"&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt; 您搜索的关键词是：&lt;%= getParameter(\"keyword\") %&gt;&lt;/div&gt; 来用转义来修复它： 12345&lt;input type=\"text\" value=\"&lt;%= escapeHTML(getParameter(\"keyword\")) %&gt;\"&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt; 您搜索的关键词是：&lt;%= escapeHTML(getParameter(\"keyword\")) %&gt;&lt;/div&gt; escapeHTML()进行转义 大部分模板都带有的转义配置，让所有插入到页面中的数据都默认进行转义 案例继续不仅仅是特殊字符，连 javascript: 这样的字符串如果出现在特定的位置也会引发 XSS 攻击。 怎样解决呢？ 1234567891011121314// 根据项目情况进行过滤，禁止掉 \"javascript:\" 链接、非法 scheme 等allowSchemes = [\"http\", \"https\"];valid = isValid(getParameter(\"redirect_to\"), allowSchemes);if (valid) &#123; &lt;a href=\"&lt;%= escapeHTML(getParameter(\"redirect_to\"))%&gt;\"&gt; 跳转... &lt;/a&gt;&#125; else &#123; &lt;a href=\"/404\"&gt; 跳转... &lt;/a&gt;&#125; 所以，我们需要注意的是： 做了 HTML 转义，并不等于高枕无忧。 对于链接跳转，如 &lt;a href=&quot;xxx&quot; 或 location.href=&quot;xxx&quot;，要检验其内容，禁止以 javascript: 开头的链接，和其他非法的 scheme。 案例三、 把一个数据通过 JSON 的方式内联到 HTML 中:插入 JSON 的地方不能使用 escapeHTML()，因为转义 “ 后，JSON 格式会被破坏。内联 JSON 也是不安全的： 当 JSON 中包含 U+2028 或 U+2029 这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。 当 JSON 中包含字符串 &lt;/script&gt;时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 &lt;script&gt; 标签等方法就可以完成注入。 于是我们又要实现一个 escapeEmbedJSON() 函数，对内联 JSON 进行转义。 CSRF CSRF（Cross-Site Request Forgery），中文名称：跨站请求伪造攻击 那么 CSRF 到底能够干嘛呢？你可以这样简单的理解：攻击者可以盗用你的登陆信息，以你的身份模拟发送各种请求。攻击者只要借助少许的社会工程学的诡计，例如通过 QQ 等聊天软件发送的链接(有些还伪装成短域名，用户无法分辨)，攻击者就能迫使 Web 应用的用户去执行攻击者预设的操作。例如，当用户登录网络银行去查看其存款余额，在他没有退出时，就点击了一个 QQ 好友发来的链接，那么该用户银行帐户中的资金就有可能被转移到攻击者指定的帐户中。 所以遇到 CSRF 攻击时，将对终端用户的数据和操作指令构成严重的威胁。当受攻击的终端用户具有管理员帐户的时候，CSRF 攻击将危及整个 Web 应用程序。 完成 CSRF 攻击必须要有三个条件： 用户已经登录了站点 A，并在本地记录了 cookie 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。 站点 A 没有做任何 CSRF 防御 几种常见的攻击类型 GET类型的CSRFGET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用： 1&lt;img src=\"http://bank.example/withdraw?amount=10000&amp;for=hacker\" &gt; 在受害者访问含有这个img的页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。 POST类型的CSRF这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如： 123456 &lt;form action=\"http://bank.example/withdraw\" method=POST&gt; &lt;input type=\"hidden\" name=\"account\" value=\"xiaoming\" /&gt; &lt;input type=\"hidden\" name=\"amount\" value=\"10000\" /&gt; &lt;input type=\"hidden\" name=\"for\" value=\"hacker\" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。 POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。 预防 CSRFCSRF 的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的 CSRF 防御也都在服务端进行。服务端的预防 CSRF 攻击的方式方法有多种，但思路上都是差不多的，主要从以下两个方面入手： 正确使用 GET，POST 请求和 cookie 在非 GET 请求中增加 token 当正确的使用了 GET 和 POST 请求之后，剩下的就是在非 GET 方式的请求中增加随机数，这个大概有三种方式来进行： 为每个用户生成一个唯一的 cookie token，所有表单都包含同一个伪随机值，这种方案最简单，因为攻击者不能获得第三方的 cookie(理论上)，所以表单中的数据也就构造失败，但是由于用户的 cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须要在没有 XSS 的情况下才安全。 每个 POST 请求使用验证码，这个方案算是比较完美的，但是需要用户多次输入验证码，用户体验比较差，所以不适合在业务中大量运用。 渲染表单的时候，为每一个表单包含一个 csrfToken，提交表单的时候，带上 csrfToken，然后在后端做 csrfToken验证。","categories":[{"name":"优化","slug":"优化","permalink":"https://www.kaige1220.top/categories/优化/"},{"name":"前端安全系列","slug":"优化/前端安全系列","permalink":"https://www.kaige1220.top/categories/优化/前端安全系列/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"优化","slug":"优化","permalink":"https://www.kaige1220.top/tags/优化/"},{"name":"前端安全系列","slug":"前端安全系列","permalink":"https://www.kaige1220.top/tags/前端安全系列/"}]},{"title":"克隆","slug":"克隆","date":"2018-11-22T06:58:04.319Z","updated":"2018-11-22T08:00:38.272Z","comments":true,"path":"2018/11/22/克隆/","link":"","permalink":"https://www.kaige1220.top/2018/11/22/克隆/","excerpt":"浅克隆 我们使用concat.() 和slice()对数组进行拷贝的时候： 如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。 我们把这种复制引用的拷贝方法称之为浅拷贝，与之对应的就是深拷贝，深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。 所以我们可以看出使用 concat 和 slice 是一种浅拷贝。","text":"浅克隆 我们使用concat.() 和slice()对数组进行拷贝的时候： 如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。 我们把这种复制引用的拷贝方法称之为浅拷贝，与之对应的就是深拷贝，深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。 所以我们可以看出使用 concat 和 slice 是一种浅拷贝。 123456789101112131415161718// 浅克隆函数function shallowClone(o) &#123; const obj = &#123;&#125;; for ( let i in o) &#123; obj[i] = o[i]; &#125; return obj;&#125;// 被克隆对象const oldObj = &#123; a: 1, b: [ 'e', 'f', 'g' ], c: &#123; h: &#123; i: 2 &#125; &#125;&#125;;const newObj = shallowClone(oldObj);console.log(newObj.c.h, oldObj.c.h); // &#123; i: 2 &#125; &#123; i: 2 &#125;console.log(oldObj.c.h === newObj.c.h); // true 进一步12345678910111213var shallowCopy = function(obj) &#123; // 只拷贝对象 if (typeof obj !== 'object') return; // 根据obj的类型判断是新建一个数组还是对象 var newObj = obj instanceof Array ? [] : &#123;&#125;; // 遍历obj，并且判断是obj的属性才拷贝 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key]; &#125; &#125; return newObj;&#125; 深拷贝一般方法： 12345var arr = ['old', 1, true, ['old1', 'old2'], &#123;old: 1&#125;]var new_arr = JSON.parse( JSON.stringify(arr) );console.log(new_arr); 这个方法的坑点： 他无法实现对函数 、RegExp等特殊对象的克隆 会抛弃对象的constructor,所有的构造函数会指向Object 对象有循环引用,会报错 进一步12345678910var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125; 性能问题 尽管使用深拷贝会完全的克隆一个新对象，不会产生副作用，但是深拷贝因为使用递归，性能会不如浅拷贝，在开发中，还是要根据实际情况进行选择。","categories":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/categories/js/"},{"name":"克隆","slug":"js/克隆","permalink":"https://www.kaige1220.top/categories/js/克隆/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"克隆","slug":"克隆","permalink":"https://www.kaige1220.top/tags/克隆/"}]},{"title":"数组去重","slug":"数组去重","date":"2018-11-22T01:33:27.196Z","updated":"2018-11-22T06:35:49.277Z","comments":true,"path":"2018/11/22/数组去重/","link":"","permalink":"https://www.kaige1220.top/2018/11/22/数组去重/","excerpt":"先看一个兼容性好的，采用双循环来做：12345678910111213141516var arr = [1, 1, '1', '1'];function unique(arr)&#123; var res = []; for (var i=1,i&lt;arr.length,i++)&#123; for(var j=1,j&lt;res.length,i++)&#123; if(arr[i]===res[j])&#123; break; &#125; &#125; if(j===res.length)&#123; res.push(arr[i]); &#125; &#125; return res;&#125;","text":"先看一个兼容性好的，采用双循环来做：12345678910111213141516var arr = [1, 1, '1', '1'];function unique(arr)&#123; var res = []; for (var i=1,i&lt;arr.length,i++)&#123; for(var j=1,j&lt;res.length,i++)&#123; if(arr[i]===res[j])&#123; break; &#125; &#125; if(j===res.length)&#123; res.push(arr[i]); &#125; &#125; return res;&#125; 下面用indexOf简化12345678910111213var arr = [1, 1, '1', '1'];function unique(arr)&#123; var res = []; for(var 1 = 1, i&lt; arr.length, i++)&#123; var current = arr[i]; if(res.indexOf(current)===-1)&#123; res.push(current) &#125; &#125; return res;&#125; 排序后去重1234567891011121314151617var array = [1, 1, '1'];function unique(array) &#123; var res = []; var sortedArray = array.concat().sort(); var seen; for (var i = 0, len = sortedArray.length; i &lt; len; i++) &#123; // 如果是第一个元素或者相邻的元素不相同 if (!i || seen !== sortedArray[i]) &#123; res.push(sortedArray[i]) &#125; seen = sortedArray[i]; &#125; return res;&#125;console.log(unique(array)); 好了，看到这里，我们就可以组合起来了。 12345678910111213141516171819202122232425function unique(array, isSorted, iteratee) &#123; var res = []; var seen = []; for (var i = 0, len = array.length; i &lt; len; i++) &#123; var value = array[i]; var computed = iteratee ? iteratee(value, i, array) : value; if (isSorted) &#123; if (!i || seen !== computed) &#123; res.push(value) &#125; seen = computed; &#125; else if (iteratee) &#123; if (seen.indexOf(computed) === -1) &#123; seen.push(computed); res.push(value); &#125; &#125; else if (res.indexOf(value) === -1) &#123; res.push(value); &#125; &#125; return res;&#125; array：表示要去重的数组，必填 isSorted：表示函数传入的数组是否已排过序，如果为 true，将会采用更快的方法进行去重 iteratee：传入一个函数，可以对每个元素进行重新的计算，然后根据处理的结果进行去重 下面看看ES5的方法比如使用 indexOf 的方法： 12345678910var array = [1, 2, 1, 1, '1'];function unique(array) &#123; var res = array.filter(function(item, index, array)&#123; return array.indexOf(item) === index; &#125;) return res;&#125;console.log(unique(array)); 排序去重的方法： 123456789var array = [1, 2, 1, 1, '1'];function unique(array) &#123; return array.concat().sort().filter(function(item, index, array)&#123; return !index || item !== array[index - 1] &#125;)&#125;console.log(unique(array)); 好了，再看看ES6 的方法： 1var unique = (a) =&gt; [...new Set(a)]","categories":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/categories/js/"},{"name":"数组去重","slug":"js/数组去重","permalink":"https://www.kaige1220.top/categories/js/数组去重/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"数组去重","slug":"数组去重","permalink":"https://www.kaige1220.top/tags/数组去重/"}]},{"title":"类型判断","slug":"类型判断","date":"2018-11-22T01:15:12.248Z","updated":"2018-11-22T01:29:15.040Z","comments":true,"path":"2018/11/22/类型判断/","link":"","permalink":"https://www.kaige1220.top/2018/11/22/类型判断/","excerpt":"来看看jQuery type 给出的方法：灰常好，直接用：1234567891011121314151617var class2type = &#123;&#125;;// 生成class2type映射\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \").map(function(item, index) &#123; class2type[\"[object \" + item + \"]\"] = item.toLowerCase();&#125;)function type(obj) &#123; //在 IE6 中，null 和 undefined 会被 Object.prototype.toString 识别成 [object Object]！ 所以做个兼容性 // 一箭双雕 if (obj == null) &#123; return obj + \"\"; &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[Object.prototype.toString.call(obj)] || \"object\" : typeof obj;&#125;","text":"来看看jQuery type 给出的方法：灰常好，直接用：1234567891011121314151617var class2type = &#123;&#125;;// 生成class2type映射\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \").map(function(item, index) &#123; class2type[\"[object \" + item + \"]\"] = item.toLowerCase();&#125;)function type(obj) &#123; //在 IE6 中，null 和 undefined 会被 Object.prototype.toString 识别成 [object Object]！ 所以做个兼容性 // 一箭双雕 if (obj == null) &#123; return obj + \"\"; &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[Object.prototype.toString.call(obj)] || \"object\" : typeof obj;&#125; 知识点： typeof 可以判断基础的数据类型，碰到引用类型，比如 data reg math 什么的就不行了，那么用Object.prototype.toString就可以了。 上面第一点其实是把数据类型转成小写的。 用到了map函数，不会的自己查查看。 更复杂的判断：EmptyObject12345678910function isEmptyObject( obj ) &#123; var name; for ( name in obj ) &#123; return false; &#125; return true;&#125; Window对象Window 对象作为客户端 JavaScript 的全局对象，它有一个 window 属性指向自身,我们可以利用这个特性判断是否是 Window 对象。 123function isWindow( obj ) &#123; return obj != null &amp;&amp; obj === obj.window;&#125; isArrayLikeisArrayLike，看名字可能会让我们觉得这是判断类数组对象的，其实不仅仅是这样，jQuery 实现的 isArrayLike，数组和类数组都会返回 true。 因为源码比较简单，我们直接看源码： 1234567891011121314function isArrayLike(obj) &#123; // obj 必须有 length属性 var length = !!obj &amp;&amp; \"length\" in obj &amp;&amp; obj.length; var typeRes = type(obj); // 排除掉函数和 Window 对象 if (typeRes === \"function\" || isWindow(obj)) &#123; return false; &#125; return typeRes === \"array\" || length === 0 || typeof length === \"number\" &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;&#125; isElementisElement 判断是不是 DOM 元素。 123isElement = function(obj) &#123; return !!(obj &amp;&amp; obj.nodeType === 1);&#125;;","categories":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/categories/js/"},{"name":"类型判断","slug":"js/类型判断","permalink":"https://www.kaige1220.top/categories/js/类型判断/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"类型判断","slug":"类型判断","permalink":"https://www.kaige1220.top/tags/类型判断/"}]},{"title":"new 模拟方法的实现","slug":"new模拟方法的实现","date":"2018-11-21T13:20:25.784Z","updated":"2018-11-22T01:29:29.469Z","comments":true,"path":"2018/11/21/new模拟方法的实现/","link":"","permalink":"https://www.kaige1220.top/2018/11/21/new模拟方法的实现/","excerpt":"new 的功能是啥？ new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 1234567891011121314151617181920function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;Otaku.prototype.strength = 80;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin","text":"new 的功能是啥？ new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 1234567891011121314151617181920function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;Otaku.prototype.strength = 80;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin 从这个例子中，我们可以看到，实例 person 可以： 访问到 Otaku 构造函数里的属性 访问到 Otaku.prototype 中的属性 好了，理解了特性和功能，我们就来实现它。 因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的： 12345678function Otaku () &#123; ……&#125;// 使用 newvar person = new Otaku(……);// 使用 objectFactoryvar person = objectFactory(Otaku, ……) 好了，来实现吧： 12345678910111213141516171819202122function objectFactory() &#123; // 新建一个对象 var obj = new Object(), //取出第一个参数，这个参数就是我们要传的构造函数 Constructor = [].shift.call(arguments); //让obj的原型指向构造函数 obj.__proto__ = Constructor.prototype; //使用apply方法，让构造函数的this指向新建的obj对象 var ret = Constructor.apply(obj, arguments); //根据构造函数是否有返回值， new 实例化后有所不同，如果返回值是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。 return typeof ret === 'object' ? ret : obj;&#125;;","categories":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/categories/js/"},{"name":"new 模拟方法的实现","slug":"js/new-模拟方法的实现","permalink":"https://www.kaige1220.top/categories/js/new-模拟方法的实现/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"new 模拟方法的实现","slug":"new-模拟方法的实现","permalink":"https://www.kaige1220.top/tags/new-模拟方法的实现/"}]},{"title":"作用域、执行上下文栈以及闭包的理解","slug":"Js作用域和闭包的理解","date":"2018-11-21T10:09:49.969Z","updated":"2018-11-21T10:24:53.781Z","comments":true,"path":"2018/11/21/Js作用域和闭包的理解/","link":"","permalink":"https://www.kaige1220.top/2018/11/21/Js作用域和闭包的理解/","excerpt":"作用域： 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。","text":"作用域： 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 如果是静态作用域： 如何执行呢？执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设JavaScript采用动态作用域，让我们分析下执行过程：执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 执行上下文栈的理解： 先看看下面两段代码的区别：123456789101112131415var foo = function () &#123; console.log('foo1');&#125;foo(); // foo1var foo = function () &#123; console.log('foo2');&#125;foo(); // foo2 123456789101112131415function foo() &#123; console.log('foo1');&#125;foo(); // foo2function foo() &#123; console.log('foo2');&#125;foo(); // foo2 这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？ 到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？ 可执行代码 这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？ 其实很简单，就三种，全局代码、函数代码、eval代码。 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。 执行上下文栈 接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：1ECStack = []; 试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext： 123ECStack = [ globalContext]; 现在 JavaScript 遇到下面的这段代码了： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3();&#125;function fun1() &#123; fun2();&#125;fun1(); 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码： 12345678910111213141516171819// fun1()ECStack.push(&lt;fun1&gt; functionContext);// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext);// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext);// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 闭包的理解 广义： 函数 + 函数能自由访问的自由变量 实践角度的： 即使创建它的上下文已经销毁，它仍然存在， 就是引用的自由变量还在。","categories":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/categories/js/"},{"name":"作用域、执行上下文栈以及闭包的理解","slug":"js/作用域、执行上下文栈以及闭包的理解","permalink":"https://www.kaige1220.top/categories/js/作用域、执行上下文栈以及闭包的理解/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"作用域、执行上下文栈以及闭包的理解","slug":"作用域、执行上下文栈以及闭包的理解","permalink":"https://www.kaige1220.top/tags/作用域、执行上下文栈以及闭包的理解/"}]},{"title":"call apply bind 模拟方法的实现","slug":"call、applay、bind模拟方法","date":"2018-11-21T06:38:37.668Z","updated":"2018-11-21T10:01:05.737Z","comments":true,"path":"2018/11/21/call、applay、bind模拟方法/","link":"","permalink":"https://www.kaige1220.top/2018/11/21/call、applay、bind模拟方法/","excerpt":"由于这篇的笔记已经手写在笔记本上了，所以这里全部给出的是最终方案，如果想查看具体的思路，可以看冴羽大佬 的博客。 call 什么是call() call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。","text":"由于这篇的笔记已经手写在笔记本上了，所以这里全部给出的是最终方案，如果想查看具体的思路，可以看冴羽大佬 的博客。 call 什么是call() call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 好了，废话不多讲，开始直接实现（有点基础，看注释便明白了）：12345678910111213141516Function.propotype.call2 = function(context)&#123; //改变this指向 this 参数可以传 null，当为 null 的时候，视为指向 window var context = contex || window; context.fn = this //解决第二个问题传入第二个参数问题 var args = []; for(var i=1, len = argument.length; i&lt;len, i++)&#123; args.push('arguments['+i+']'); &#125; // eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。 var result = eval('context.fn('+args+')') //销毁 delete context.fn return result;&#125; applay 的实现方法 1234567891011121314151617181920Function.prototype.apply = function (context, arr) &#123; //改变this指向 this 参数可以传 null，当为 null 的时候，视为指向 window var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; bind 的实现方法 bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。 首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 bind 的另外一个特性： 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子： 12345678910111213141516171819202122232425var value = 2;var foo = &#123; value: 1&#125;;function bar(name, age) &#123; this.habit = 'shopping'; console.log(this.value); console.log(name); console.log(age);&#125;bar.prototype.friend = 'kevin';var bindFoo = bar.bind(foo, 'daisy');var obj = new bindFoo('18');// undefined// daisy// 18console.log(obj.habit);console.log(obj.friend);// shopping// kevin 尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 了解了特性后，我们开始动手了123456789101112131415161718192021Function.propotype.bind2 = function(context)&#123; var self = this; // 实现传参效果，首先我们要获取bind2函数从第二个参数到最后一个参数var args = Array.propotype.slice.call(argument,1);//建一个空函数为下面服务的var fNOP = function () &#123;&#125;;var fBound = function () &#123; // 这个时候的arguments是指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments); //解决bind的第三个特性，instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; //用空函数的实例作为桥梁链接this原型 和传入的参数 context的原型， 这样做的好处是当修改context的属性时，不会引起this 属性的改变。 fBound.prototype = new fNOP(); return fBound;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/categories/js/"},{"name":"call apply bind 模拟方法的实现","slug":"js/call-apply-bind-模拟方法的实现","permalink":"https://www.kaige1220.top/categories/js/call-apply-bind-模拟方法的实现/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"call apply bind 模拟方法的实现","slug":"call-apply-bind-模拟方法的实现","permalink":"https://www.kaige1220.top/tags/call-apply-bind-模拟方法的实现/"}]},{"title":"Flex 图解归纳","slug":"flex图解归纳","date":"2018-11-21T06:10:21.604Z","updated":"2018-11-21T06:35:40.015Z","comments":true,"path":"2018/11/21/flex图解归纳/","link":"","permalink":"https://www.kaige1220.top/2018/11/21/flex图解归纳/","excerpt":"flex 基本概念 flex 的核心的概念就是 容器 和 轴。容器包括外层的 父容器 和内层的 子容器，轴包括 主轴 和 交叉轴，可以说 flex 布局的全部特性都构建在这两个概念上。flex 布局涉及到 12 个 CSS 属性（不含 display: flex），其中父容器、子容器各 6 个。","text":"flex 基本概念 flex 的核心的概念就是 容器 和 轴。容器包括外层的 父容器 和内层的 子容器，轴包括 主轴 和 交叉轴，可以说 flex 布局的全部特性都构建在这两个概念上。flex 布局涉及到 12 个 CSS 属性（不含 display: flex），其中父容器、子容器各 6 个。 先说父容器： 容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。 justify-content 前三个属性比较好理解，不用说了，看下面两个： space-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。space-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。 align-items 还是说最后两个： baseline：基线对齐，这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。 stretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致。 ![](https://ws1.sinaimg.cn/large/006c6oKBgy1fxfnu0mip5j30e607xj 子容器 在主轴上如何伸缩：flex 子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由 flex 属性确定。 flex 的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字。子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为 none 则不伸缩。 虽然 flex 是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。 单独设置子容器如何沿交叉轴排列：align-self 再来说说轴如图所示，轴 包括 主轴 和 交叉轴，我们知道 justify-content 属性决定子容器沿主轴的排列方式，align-items 属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，flex-direction 属性决定主轴的方向，交叉轴的方向由主轴确定。 主轴 主轴的起始端由 flex-start 表示，末尾段由 flex-end 表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。 向右：flex-direction: row 向下：flex-direction: column 向左：flex-direction: row-reverse 向上：flex-direction: column-reverse 交叉轴 主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由 flex-start 和 flex-end 表示。 好了最常用的属性介绍完了，下面看看几个不常用到的： 父容器 设置换行方式：flex-wrap 轴向与换行组合设置：flex-flowflow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行，比如 flex-flow: row wrap，flex-flow 是一个复合属性，相当于 flex-direction 与 flex-wrap 的组合，可选的取值如下： row、column 等，可单独设置主轴方向 wrap、nowrap 等，可单独设置换行方式 row nowrap、column wrap 等，也可两者同时设置 多行沿交叉轴对齐：align-content当子容器多行排列时，设置行与行之间的对齐方式。 flex-start：起始端对齐 flex-end：末尾段对齐 center：居中对齐 space-around：等边距均匀分布 space-between：等间距均匀分布 stretch：拉伸对齐 子容器 设置基准大小：flex-basisflex-basis 表示在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度。 设置扩展比例：flex-grow设置收缩比例：flex-shrink设置排列顺序：order","categories":[{"name":"css","slug":"css","permalink":"https://www.kaige1220.top/categories/css/"},{"name":"Flex 图解归纳","slug":"css/Flex-图解归纳","permalink":"https://www.kaige1220.top/categories/css/Flex-图解归纳/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.kaige1220.top/tags/css/"},{"name":"Flex 图解归纳","slug":"Flex-图解归纳","permalink":"https://www.kaige1220.top/tags/Flex-图解归纳/"}]},{"title":"Kyle Simpson系列课程学习","slug":"Deep Foundations of Advanced JavaScript","date":"2018-11-21T03:08:54.395Z","updated":"2018-11-21T05:52:04.835Z","comments":true,"path":"2018/11/21/Deep Foundations of Advanced JavaScript/","link":"","permalink":"https://www.kaige1220.top/2018/11/21/Deep Foundations of Advanced JavaScript/","excerpt":"","text":"先奉上地址： youtube预览教程需翻墙 Deep Foundations of Advanced JavaScript Frontend Masters 打算黑五购买该系列教程(1) Deep JavaScript Foundations(2) Rethinking Asynchronous JavaScript(3) Functional-Light JavaScript, v2(4) ES6: The Right Parts(5) Organizing JavaScript Functionality(6) Coercion in JavaScript","categories":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/categories/js/"},{"name":"Kyle Simpson系列课程学习","slug":"js/Kyle-Simpson系列课程学习","permalink":"https://www.kaige1220.top/categories/js/Kyle-Simpson系列课程学习/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"Kyle Simpson系列课程学习","slug":"Kyle-Simpson系列课程学习","permalink":"https://www.kaige1220.top/tags/Kyle-Simpson系列课程学习/"}]},{"title":"Javascript The Good Parts","slug":"Javascript The Good Parts","date":"2018-11-21T02:34:26.260Z","updated":"2018-11-21T03:07:33.761Z","comments":true,"path":"2018/11/21/Javascript The Good Parts/","link":"","permalink":"https://www.kaige1220.top/2018/11/21/Javascript The Good Parts/","excerpt":"数据类型和运算符 被当作逻辑假的值：false null undefined ‘’ 0 NaN 未指定return值时将会返回 undefined / 运算符有可能会产生一个非整数结果，即使两个运算数都是整数 减少全局变量污染方法 在应用中只创建一个全局变量：var MYAPP = {};该全局变量此时成了应用的容器，可以如下方式使用： 12MYAPP.value1 = &#123;...&#125;;MYAPP.value2 = &#123;...&#125;; 使用闭包（Closure）","text":"数据类型和运算符 被当作逻辑假的值：false null undefined ‘’ 0 NaN 未指定return值时将会返回 undefined / 运算符有可能会产生一个非整数结果，即使两个运算数都是整数 减少全局变量污染方法 在应用中只创建一个全局变量：var MYAPP = {};该全局变量此时成了应用的容器，可以如下方式使用： 12MYAPP.value1 = &#123;...&#125;;MYAPP.value2 = &#123;...&#125;; 使用闭包（Closure） 函数 当函数被调用时，会得到一个“免费”的参数，即 arguments “数组”，通过该”数组”可访问所有函数被调用时传入的参数，无论该参数是否在该函数定义时被指定为形参 12345function() &#123; for(var i = 0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125;&#125; prototype 原型链 每个对象都连接到一个原型对象，并且它可以从中继承属性 所有通过对象字面量创建的对象都连接到 Object.prototype 这个标准对象 原型链在更新时无效，仅在检索属性值的时候起效 当尝试获取某个对象的属性值，且对象本身无此属性，那么将会去该对象的原型中寻找，如果找不到则继续从原型的原型中寻找，直到到达终点Object.prototype 对象为止，如果最终仍未找到属性，则返回 undefined。该过程被称为委托 hasOwnProperty 只会检查对象自己属性，不会检查原型链 删除 delete obj.val 将删除对象obj本身的val属性，且不会影响原型链 变量作用域 JavaScript 不支持块级作用域，这意味着所有定义在函数任何地方的参数和变量在函数内部任何地方都可见因此，尽管很多支持块级作用域的语言推荐尽可能迟地声明变量，而在 JavaScript 中却应该在函数体的顶部声明函数中用到的所有变量 闭包（Closure）12345678910var myVar = function() &#123; var innerVal = 0; return &#123; getInnerVal() &#123; return innerVar; &#125; &#125;&#125;//myVar.getInnerVal()才能取得innerVal的值 （伪）数组（array-like） JavaScript 中没有真正的数组，它把数组的下标转换为字符串，用其作为属性 数组是一段线性分配的内存，它通过计算指针偏移量去访问元素，数组是很快的数据结构 “数组”中可同时包含不同类型的元素 “数组”拥有一个诡异的 length 属性 需要避开的一些坑 parseInt 方法遇到非数字时停止解析，所以 parseInt(“123”) 和 parseInt(“123abc”) 的结果是一样的若字符串首位为 0，如 “013”，则会按照八进制进行转换。好在可以提供基数，如 parseInt(“013”, 10)，最好始终使用这种写法 运算符 两个运算数都是数字则返回两数之和 一个运算数是空字符串，则会将另一个运算数转换为字符串并返回 其余情况均为拼接字符串 浮点数运算不精确0.1 + 0.2 不等于 0.3。可以通过整数化来解决，如 0.1 + 0.2 等于 (0.1 10 + 0.2 10) / 10 Js代码的优良习惯 后面 会填上","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"Js","slug":"技术/Js","permalink":"https://www.kaige1220.top/categories/技术/Js/"},{"name":"Javascript The Good Parts","slug":"技术/Js/Javascript-The-Good-Parts","permalink":"https://www.kaige1220.top/categories/技术/Js/Javascript-The-Good-Parts/"}],"tags":[{"name":"Javascript The Good Parts","slug":"Javascript-The-Good-Parts","permalink":"https://www.kaige1220.top/tags/Javascript-The-Good-Parts/"}]},{"title":"函数节流和去抖","slug":"函数节流和去抖","date":"2018-11-19T03:03:24.375Z","updated":"2018-11-19T03:02:57.676Z","comments":true,"path":"2018/11/19/函数节流和去抖/","link":"","permalink":"https://www.kaige1220.top/2018/11/19/函数节流和去抖/","excerpt":"函数节流和去抖的出现场景，一般都伴随着客户端 DOM 的事件监听。举个例子，实现一个原生的拖拽功能（不能用 H5 Drag&amp;Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。我们需要做的是降低触发回调的频率，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。 说完函数节流，再看它的好基友函数去抖（debounce）。思考这样一个场景，对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。","text":"函数节流和去抖的出现场景，一般都伴随着客户端 DOM 的事件监听。举个例子，实现一个原生的拖拽功能（不能用 H5 Drag&amp;Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。我们需要做的是降低触发回调的频率，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。 说完函数节流，再看它的好基友函数去抖（debounce）。思考这样一个场景，对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。 throttle 应用场景 DOM 元素的拖拽功能实现（mousemove） 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹） 计算鼠标移动的距离（mousemove） Canvas 模拟画板功能（mousemove） 搜索联想（keyup） 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次 debounce 应用场景 每次 resize/scroll 触发统计事件 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好） 按一个按钮发送 AJAX：给 click 加了 debounce 后就算用户不停地点这个按钮，也只会最终发送一次；如果是 throttle 就会间隔发 送几次 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次 函数节流和函数去抖的核心其实就是限制某一个方法被频繁触发，而一个方法之所以会被频繁触发，大多数情况下是因为 DOM 事件的监听回调，而这也是函数节流以及去抖多数情况下的应用场景。 高程三给出的去抖的方法：1234567891011121314function debounce(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(context); &#125;, 1000);&#125;function print() &#123; console.log('hello world');&#125;window.onscroll = function() &#123; debounce(print);&#125;; 上述代码可以更改更优化：123456789101112131415function debounce(method, context) &#123; var timer = null; return function() &#123; clearTimeout(timer); timer = setTimeout(function() &#123; method.call(context); &#125;, 1000); &#125;&#125;function print() &#123; console.log('hello world');&#125;window.onscroll = debounce(print); 去抖的实现方式非立即执行：非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 12345678910const debounce = (func, wait, ...args) =&gt; &#123; let timeout; return function()&#123; const context = this; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(context, args) &#125;,wait); &#125;&#125; 另外一种写法：1234567891011121314function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; 立即执行版：1234567891011121314151617function debounce(func,wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125;&#125; 联合版本：12345678910111213141516171819202122232425262728/** * @desc 函数防抖 * @param func 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表非立即执行 */function debounce(func,wait,immediate) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 节流（throttle）所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。**节流会稀释函数的执行频率。 对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。 时间戳版：12345678910111213function throttle(func, wait) &#123; var previous = 0; return function() &#123; var now = Date.now(); var context = this; var args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125; 定时器版:123456789101112131415function throttle(func, wait) &#123; var timeout; return function() &#123; var context = this; var args = arguments; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 我们应该可以很容易的发现，其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"函数节流和去抖","slug":"技术/函数节流和去抖","permalink":"https://www.kaige1220.top/categories/技术/函数节流和去抖/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"函数节流和去抖","slug":"函数节流和去抖","permalink":"https://www.kaige1220.top/tags/函数节流和去抖/"}]},{"title":"缓存系列","slug":"缓存技巧","date":"2018-11-19T00:53:16.902Z","updated":"2018-11-19T02:53:20.730Z","comments":true,"path":"2018/11/19/缓存技巧/","link":"","permalink":"https://www.kaige1220.top/2018/11/19/缓存技巧/","excerpt":"缓存的作用 重用已获取的资源，减少延迟与网络阻塞，进而减少显示某个资源所用的时间，借助 HTTP 缓存，Web 站点变得更具有响应性。 其实我们对于页面静态资源的要求就两点1、静态资源加载速度2、页面渲染速度 页面渲染速度建立在资源加载速度之上，但不同资源类型的加载顺序和时机也会对其产生影响，所以缓存的可操作空间非常大","text":"缓存的作用 重用已获取的资源，减少延迟与网络阻塞，进而减少显示某个资源所用的时间，借助 HTTP 缓存，Web 站点变得更具有响应性。 其实我们对于页面静态资源的要求就两点1、静态资源加载速度2、页面渲染速度 页面渲染速度建立在资源加载速度之上，但不同资源类型的加载顺序和时机也会对其产生影响，所以缓存的可操作空间非常大 缓存的分类 缓存应该放在哪里？ 分析自己的项目的性能问题，性能瓶颈在哪？是文件太大，还是请求数量太多？重复的无效请求是否太多？数据或者结果可以缓存吗？这些数据、结果、文件的刷新率如何，容易失效吗？ 这些问题，一千个项目有一千个答案，只有弄明白了缓存的核心原理，才能以不变应万变，信手沾来。 缓存的一些应用场景 1、每次都加载某个同样的静态文件 =&gt; 浪费带宽，重复请求 =&gt; 让浏览器使用本地缓存（协商缓存，返回304）2、协商缓存还是要和服务器通信啊 =&gt; 有网络请求，不太舒服，感觉很low =&gt; 强制浏览器使用本地强缓存（返回200）3、缓存要更新啊，兄弟，网络请求都没了，我咋知道啥时候要更新？=&gt; 让请求（header加上ETag）或者url的修改与文件内容关联（文件名加哈希值） 各类缓存技术优缺点 1、cookie优点：对于传输部分少量不敏感数据，非常简明有效缺点：容量小（4K），不安全（cookie被拦截，很可能暴露session）；原生接口不够友好，需要自己封装；需要指定作用域，不可以跨域调用 2、Web Storage容量稍大一点（5M），localStorage可做持久化数据存储支持事件通知机制，可以将数据更新的通知发送给监听者缺点：本地储存数据都容易被篡改，容易受到XSS攻击 缓存读取需要依靠js的执行，所以前提条件就是能够读取到html及js代码段，其次文件的版本更新控制会带来更多的代码层面的维护成本，所以LocalStorage更适合关键的业务数据而非静态资源 Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 3、indexDBIndexedDb提供了一个结构化的、事务型的、高性能的NoSQL类型的数据库，包含了一组同步/异步API，这部分不好判断优缺点，主要看使用者。 浏览器缓存机制：强缓存、协商缓存 概述良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度通常浏览器缓存策略分为两种：强缓存和协商缓存 1、基本原理1）浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源3）如果前面两者都没有命中，直接从服务器加载资源 2、相同点如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据； 3、不同点强缓存不发请求到服务器，协商缓存会发请求到服务器。 强缓存强缓存通过Expires和Cache-Control两种响应头实现 1、Expires Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效 2、Cache-Control Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间 Cache-Control: no-cache不会缓存数据到本地的说法是错误的，详情《HTTP权威指南》P182Cache-Control: no-store才是真正的不缓存数据到本地Cache-Control: public可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器Cache-Control: private只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存 协商缓存当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的 1、Last-Modified，If-Modified-SinceLast-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 2、ETag、If-None-MatchEtag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的 If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来 ETag的优先级比Last-Modified更高 具体为什么要用ETag，主要出于下面几种情况考虑： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改 了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级 的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间。 几种状态码的区别 200：强缓Expires/Cache-Control存失效时，返回新的资源文件 200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功 304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304 但是！但是！现在的200(from cache)已经变成了from disk cache(磁盘缓存)和from memory cache(内存缓存)两种打开chrome控制台看一下网络请求就知道了 如何选择合适的缓存大致的顺序 Cache-Control —— 请求服务器之前 Expires —— 请求服务器之前 If-None-Match (Etag) —— 请求服务器 If-Modified-Since (Last-Modified) —— 请求服务器 协商缓存需要配合强缓存使用，如果不启用强缓存的话，协商缓存根本没有意义 大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】 但是下面的场景需要注意： 分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败； 分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）； 数据存储：cookie、Storage、indexedDB 简单对比储存的数据可能是从服务器端获取到的数据，也可能是在多个页面中需要频繁使用到的数据 1、cookie：4K，可以手动设置失效期2、localStorage：5M，除非手动清除，否则一直存在3、sessionStorage：5M，不可以跨标签访问，页面关闭就清理4、indexedDB：浏览器端数据库，无限容量，除非手动清除，否则一直存在5、Web SQL：关系数据库，通过SQL语句访问（已经被抛弃） 一、cookie Cookie通过在客户端记录信息确定用户身份Session通过在服务器端记录信息确定用户身份 Cookie机制 一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围 session机制 Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 当程序需要为某个客户端的请求创建一个session时， 服务器首先检查这个客户端的请求里是否已包含了一个session标识————称为session id， 如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个）， 如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 可以用document.cookie获取cookie，得到一个字符串，形式如 key1=value1; key2=value2，需要用正则匹配需要的值，其他库已经封装的比较好，具体可以自己去搜索 cookie可以设置路径path，所有他要比另外两个多了一层访问限制cookie可以通过设置domain属性值，可以不同二级域名下共享cookie，而Storage不可以，比如http://image.baidu.com的cookie http://map.baidu.com是可以访问的，前提是Cookie的domain设置为.http://baidu.com，而Storage是不可以的 缺点：在请求头上带着数据，大小是4k之内，主Domain污染。 常用的配置属性有以下几个Expires ：cookie最长有效期Max-Age：在 cookie 失效之前需要经过的秒数。（当Expires和Max-Age同时存在时，文档中给出的是已Max-Age为准，可是我自己用Chrome实验的结果是取二者中最长有效期的值）Domain：指定 cookie 可以送达的主机名。Path：指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部Secure：一个带有安全属性的 cookie 只有在请求使用SSL和HTTPS协议的时候才会被发送到服务器。HttpOnly:设置了 HttpOnly 属性的 cookie 不能使用 JavaScript 经由 Document.cookie 属性、XMLHttpRequest 和 Request APIs 进行访问，以防范跨站脚本攻击（XSS）。 Storage：localStorage、sessionStorage大小：官方建议是5M存储空间类型：只能操作字符串，在存储之前应该使用JSON.stringfy()方法先进行一步安全转换字符串，取值时再用JSON.parse()方法再转换一次存储的内容： 数组，图片，json，样式，脚本。。。（只要是能序列化成字符串的内容都可以存储）注意：数据是明文存储，毫无隐私性可言，绝对不能用于存储重要信息区别：sessionStorage将数据临时存储在session中，浏览器关闭，数据随之消失，localStorage将数据存储在本地，理论上来说数据永远不会消失，除非人为删除 1、基础操作API保存数据localStorage.setItem( key, value );sessionStorage.setItem( key, value );读取数据localStorage.getItem( key );sessionStorage.getItem( key );删除单个数据localStorage.removeItem( key );sessionStorage.removeItem( key );删除全部数据localStorage.clear( );sessionStorage.clear( );获取索引的keylocalStorage.key( index );sessionStorage.key( index ); 2、监听storage事件可以通过监听 window 对象的 storage 事件并指定其事件处理函数，当页面中对 localStorage 或 sessionStorage 进行修改时，则会触发对应的处理函数 123window.addEventListener('storage',function(e)&#123; console.log('key='+e.key+',oldValue='+e.oldValue+',newValue='+e.newValue);&#125;) 触发事件的时间对象（e 参数值）有几个属性：key : 键值。oldValue : 被修改前的值。newValue : 被修改后的值。url : 页面url。storageArea : 被修改的 storage 对象。 indexedDB参考官方文档张大神教程 务必先了解数据库的一些概念关系型数据库和非关系型数据库 关系型最主要的当然是SQL了， 下面主要说下非关系型的。使用键值对存储数据，且结构不固定，非常类似JavaScript中的纯对象。 了解数据库中的事务-transaction数据库的事务（英文为’transaction’），我们可以理解为对数据库的操作，而且专指一个序列上的操作。举个例子，银行转账，一个账号钱少了然后另一个账号钱多了，这两个操作要么都执行，要么都不执行。像这种操作就可以看成一个事务。 事务的提出主要是为了保证并发情况下保持数据一致性。关系型数据库中的事务具有下面4个基本特征： 原子性(Atomicity)：事务中的所有操作作为一个整体提交或回滚。 一致性(Consistemcy)：事物完成时，数据必须是一致的，以保证数据的无损。 隔离性(Isolation)：对数据进行修改的多个事务是彼此隔离的。 持久性(Durability)：事务完成之后，它对于系统的影响是永久的，该修改即使出现系统故障也将一直保留。 事务执行过程可以粗浅地理解为：开始事务，巴拉巴拉操作，如果错误，回滚（rollback），如果没问题，提交（commit），结束事务。 了解数据库中的游标-cursor现实世界中的“游标”相关联的常见事物就是“游标卡尺”，有刻度有区域：数据库中的游标其实与之有共同之处。内存条本质上就像一把尺子，我们可以想象上面有很多刻度，然后内存大小就是由这些刻度一个一个堆砌起来的。数据库的事务为了保证数据可以回滚，显然需要有一片内存区域放置那些即将受影响是数据，这个内存区域中的虚表就是数据库的“游标”。 和现实世界的“游标卡尺”相映射就是：一个刻度表示一行数据，游标就是尺子上的一片区域，想要获得数据库一行一行的数据，我们可以遍历这个游标就好了。 数据库中的“锁”-lock数据库中的“锁”是保证数据库数据高并发时候数据一致性的一种机制。举个例子：现有两处火车票售票点，同时读取某发现上海到北京车票余额为5。此时两处售票点同时卖出一张车票，同时修改余额为5-1也就是4写回数据库，这样就造成了实际卖出两张火车票而数据库中的记录却只少了1张。为了避免发生这种状况，就有了锁机制，也就是执行多线程时用于强行限制资源访问。 一个简单的demo:HTML代码：123456789101112131415161718192021222324252627282930313233343536&lt;form id=\"form\"&gt; &lt;p&gt;项目名称：&lt;input required name=\"name\" autocomplete=\"off\" required&gt;&lt;/p&gt; &lt;p&gt;开始时间：&lt;input type=\"date\" value=\"2017-07-16\" name=\"begin\" required&gt;&lt;/p&gt; &lt;p&gt;预计结束：&lt;input type=\"date\" value=\"2057-07-16\" name=\"end\" required&gt;&lt;/p&gt; &lt;p&gt;参与人员：&lt;input name=\"person\" placeholder=\"多人空格分隔\" required autocomplete=\"off\"&gt;&lt;/p&gt; &lt;p&gt;补充说明：&lt;textarea rows=\"5\" placeholder=\"非必填\" name=\"remark\"&gt;&lt;/textarea&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"确定创建\"&gt;&lt;/p&gt;&lt;/form&gt;&lt;div id=\"result\" class=\"result\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;项目名称&lt;/th&gt; &lt;th&gt;开始时间&lt;/th&gt; &lt;th&gt;结束时间&lt;/th&gt; &lt;th&gt;参与人员&lt;/th&gt; &lt;th&gt;补充说明&lt;/th&gt; &lt;th width=\"30\"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;div id=\"status\" class=\"status\"&gt;加载中...&lt;/div&gt;&lt;/div&gt;&lt;!-- 列表数据模板 --&gt;&lt;script id=\"tplList\" type=\"text/template\"&gt;&lt;tr&gt; &lt;td data-key=\"name\" data-id=\"$id$\" contenteditable=\"plaintext-only\"&gt;$name$&lt;/td&gt; &lt;td data-key=\"begin\" data-id=\"$id$\" contenteditable=\"plaintext-only\"&gt;$begin$&lt;/td&gt; &lt;td data-key=\"end\" data-id=\"$id$\" contenteditable=\"plaintext-only\"&gt;$end$&lt;/td&gt; &lt;td data-key=\"person\" data-id=\"$id$\" contenteditable=\"plaintext-only\"&gt;$person$&lt;/td&gt; &lt;td data-key=\"remark\" data-id=\"$id$\" contenteditable=\"plaintext-only\"&gt;$remark$&lt;/td&gt; &lt;td&gt;&lt;a href=\"javascript:\" role=\"button\" class=\"jsListDel\" data-id=\"$id$\"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/script&gt; JS代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187(function () &#123; // 元素们 var eleForm = document.querySelector('#form'); var eleTbody = document.querySelector('#result tbody'); var eleStatus = document.getElementById('status'); // 模板字符内容 var strTplList = document.getElementById('tplList').innerHTML; var logError = function (error) &#123; eleStatus.style.display = 'block'; eleStatus.innerHTML = '&lt;span class=\"error\"&gt;'+ error +'&lt;/span&gt;'; &#125;, logInfo = function (info) &#123; eleStatus.style.display = 'block'; eleStatus.innerHTML = '&lt;span class=\"info\"&gt;'+ info + '&lt;/span&gt;'; &#125;; // 简易模板方法 String.prototype.temp = function(obj) &#123; return this.replace(/\\$\\w+\\$/gi, function(matchs) &#123; return obj[matchs.replace(/\\$/g, \"\")] || ''; &#125;); &#125;; // 本演示使用的数据库名称 var dbName = 'project'; // 版本 var version = 1; // 数据库数据结果 var db; // 打开数据库 var DBOpenRequest = window.indexedDB.open(dbName, version); // 如果数据库打开失败 DBOpenRequest.onerror = function(event) &#123; logError('数据库打开失败'); &#125;; DBOpenRequest.onsuccess = function(event) &#123; // 存储数据结果 db = DBOpenRequest.result; // 显示数据 method.show(); &#125;; // 下面事情执行于：数据库首次创建版本，或者window.indexedDB.open传递的新版本（版本数值要比现在的高） DBOpenRequest.onupgradeneeded = function(event) &#123; var db = event.target.result; db.onerror = function(event) &#123; logError('数据库打开失败'); &#125;; // 创建一个数据库存储对象 var objectStore = db.createObjectStore(dbName, &#123; keyPath: 'id', autoIncrement: true &#125;); // 定义存储对象的数据项 objectStore.createIndex('id', 'id', &#123; unique: true &#125;); objectStore.createIndex('name', 'name'); objectStore.createIndex('begin', 'begin'); objectStore.createIndex('end', 'end'); objectStore.createIndex('person', 'person'); objectStore.createIndex('remark', 'remark'); &#125;; var method = &#123; add: function (newItem) &#123; var transaction = db.transaction([dbName], \"readwrite\"); // 打开已经存储的数据对象 var objectStore = transaction.objectStore(dbName); // 添加到数据对象中 var objectStoreRequest = objectStore.add(newItem); objectStoreRequest.onsuccess = function(event) &#123; method.show(); &#125;; &#125;, edit: function (id, data) &#123; // 编辑数据 var transaction = db.transaction([dbName], \"readwrite\"); // 打开已经存储的数据对象 var objectStore = transaction.objectStore(dbName); // 获取存储的对应键的存储对象 var objectStoreRequest = objectStore.get(id); // 获取成功后替换当前数据 objectStoreRequest.onsuccess = function(event) &#123; // 当前数据 var myRecord = objectStoreRequest.result; // 遍历替换 for (var key in data) &#123; if (typeof myRecord[key] != 'undefined') &#123; myRecord[key] = data[key]; &#125; &#125; // 更新数据库存储数据 objectStore.put(myRecord); &#125;; &#125;, del: function (id) &#123; // 打开已经存储的数据对象 var objectStore = db.transaction([dbName], \"readwrite\").objectStore(dbName); // 直接删除 var objectStoreRequest = objectStore.delete(id); // 删除成功后 objectStoreRequest.onsuccess = function() &#123; method.show(); &#125;; &#125;, show: function () &#123; // 最终要展示的HTML数据 var htmlProjectList = ''; // 打开对象存储，获得游标列表 var objectStore = db.transaction(dbName).objectStore(dbName); objectStore.openCursor().onsuccess = function(event) &#123; var cursor = event.target.result; // 如果游标没有遍历完，继续下面的逻辑 if (cursor) &#123; htmlProjectList = htmlProjectList + strTplList.temp(cursor.value); // 继续下一个游标项 cursor.continue(); // 如果全部遍历完毕 &#125; else &#123; logInfo(''); eleTbody.innerHTML = htmlProjectList; if (htmlProjectList == '') &#123; logInfo('暂无数据'); &#125; &#125; &#125; &#125; &#125;; // 表单提交新增数据 eleForm.addEventListener('submit', function (event) &#123; event.preventDefault(); var formData = &#123;&#125;; [].slice.call(this.querySelectorAll('input,textarea')).forEach(function (ele) &#123; if (ele.name) &#123; formData[ele.name] = ele.value; &#125; &#125;); // 添加新的数据 method.add(formData); this.reset(); &#125;); // 编辑事件 eleTbody.addEventListener('focusout', function (event) &#123; var eleTd = event.target; // 获取id，也就是获得主键 var id = eleTd &amp;&amp; eleTd.getAttribute('data-id'); if (!id || !/td/.test(eleTd.tagName)) &#123; return; &#125; // 这是要替换的数据 var data = &#123; id: id * 1 &#125;; // 获得现在的数据 [].slice.call(eleTd.parentElement.querySelectorAll('td[data-key]')).forEach(function (td) &#123; var key = td.getAttribute('data-key'); var value = td.innerText || td.textContent || ''; data[key] = value; &#125;); // 更新本地数据库 method.edit(id, data); &#125;); // 删除事件 eleTbody.addEventListener('click', function (event) &#123; var eleBtn = event.target, id = ''; if (eleBtn &amp;&amp; eleBtn.classList.contains('jsListDel') &amp;&amp; (id = eleBtn.getAttribute('data-id'))) &#123; method.del(id * 1); event.preventDefault(); &#125; &#125;);&#125;)(); 对比如果是浏览器主窗体线程开发，同时存储数据结构简单，localStorage比较好；如果数据结构比较复杂，同时对浏览器兼容性没什么要求，可以考虑使用indexedDB；如果是在Service Workers中开发应用，只能使用indexedDB数据存储。indexedDB数据库的使用目前可以直接在http协议下使用，这个和cacheStorage缓存存储必须使用https协议不一样 cacheStorage缓存页面，indexedDB数据库缓存数据，两者一结合而就可以实现百分百的离线开发 离线应用缓存：App Cache =&gt; ManifestManifest 是 H5提供的一种应用缓存机制, 基于它web应用可以实现离线访问(offline cache)浏览器还提供了应用缓存的API：applicationCach 基础与流程manifest是一个后缀名为minifest的文件，在文件中定义那些需要缓存的文件，支持manifest的浏览器将会按照manifest文件的规则，像文件保存在本地，从而在没有网络链接的情况下，也能访问页面。 当第一次正确配置app cache后，再次访问该应用时，浏览器会首先检查manifest文件是否有变动，如果有变动就会把相应的变得更新下来，同时改变浏览器里面的app cache，如果没有变动，就会直接把app cache的资源返回，基本流程如下： 使用1、html文件指定manifest配置在html标签中指定manifest文件, 便表示该网页使用manifest进行离线缓存.该网页内需要缓存的文件列表需要在 demo.appcache 文本文件中指定. 1234&lt;!DOCTYPE HTML&gt;&lt;html manifest=\"demo.appcache\"&gt;...&lt;/html&gt; 2、manifest缓存清单首行必须以CACHE MANIFEST开头，标准的三段式 12345678910111213// 需要缓存的文件，无论是否有网络连接，都从缓存读取CACHE MANIFEST/theme.css/logo.gif/main.js// 文件 &quot;login.asp&quot; 永远不会被缓存，且离线时是不可用的NETWORK:login.asp// 如果无法建立因特网连接，则用 &quot;offline.html&quot; 替代 /html5/ 目录中的所有文件FALLBACK:/html5/ /404.html 更新缓存1、更新manifest文件2、通过javascript操作 1window.applicationCache.update(); 3、清除浏览器缓存 关于它被废除的一些评论 即使在线，文件总是从 AppCache 中来 只有 Manifest 变化时文件才会更新，一旦变化总会更新所有文件 不支持 conditional download，破坏响应式设计 失败的 fallback 页面，无法区分网络错误和状态码 重定向被处理为访问失败","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"缓存","slug":"技术/缓存","permalink":"https://www.kaige1220.top/categories/技术/缓存/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://www.kaige1220.top/tags/缓存/"}]},{"title":"图片懒加载指南","slug":"图片懒加载指南","date":"2018-11-16T01:07:51.740Z","updated":"2018-11-16T07:20:02.245Z","comments":true,"path":"2018/11/16/图片懒加载指南/","link":"","permalink":"https://www.kaige1220.top/2018/11/16/图片懒加载指南/","excerpt":"概述 图片一般在整个网站上占用的资源比较大，但我们如何更快的加载这些图片呢？ 延迟加载是Web和应用程序开发中的一组技术，它们将页面上的资源加载延迟到以后的时间点 - 实际需要这些资源而不是预先加载它们。这些技术有助于提高性能，更好地利用设备资源并降低相关成本。","text":"概述 图片一般在整个网站上占用的资源比较大，但我们如何更快的加载这些图片呢？ 延迟加载是Web和应用程序开发中的一组技术，它们将页面上的资源加载延迟到以后的时间点 - 实际需要这些资源而不是预先加载它们。这些技术有助于提高性能，更好地利用设备资源并降低相关成本。 延迟加载技术 图像加载到页面有两种方式：&lt;img&gt; 标记 和css里面的background-image。首先看第一种： 1&lt;img src=\"/path/to/some/image.jpg\" /&gt; 延迟加载如何做呢？ 第一步是防止图像正面加载。浏览器使用src标记的属性来触发图像加载。如果它是HTML中的第一个或第1,000个图像并不重要。如果浏览器获取该src属性，它将触发要下载的图像，无论它是在当前视图中还是在当前视图之外。 要延迟加载，我们需要把src的属性替换掉： 1&lt;img data-src=\"https://ik.imagekit.io/demo/default-image.jpg\" /&gt; 既然我们正在阻止图像加载，我们需要告诉浏览器何时加载它。否则，它永远不会发生。为此，我们检查一旦图像（即其占位符）进入视口，我们就会触发加载。 有两种方式可以实现： 1、使用Javascript事件触发图像加载这种技术使用的事件侦听器scroll (滚动事件)，resize （窗口改变事件）以及orientationChange （窗口翻转事件）； 滚动时，滚动事件会快速触发多次。因此，为了提高性能，我们在脚本中添加了一个小超时，限制了延迟加载函数的执行，因此它不会阻止在浏览器中的同一个线程中运行的其他任务。 方法示例： 在这之前先了解下： clientHeight = (padding + content) clientHeight：包括padding但不包括border、水平滚动条、margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素。 clientWidth 不包含滚动条 offsetHeight：包括padding、border、水平滚动条，但不包括margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素。 当本元素的子元素比本元素高且overflow=scroll时，本元素会scroll，这时：scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。 scrollTop: 代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时scrollTop==0恒成立。单位px，可读可设置。 offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;style&gt;img &#123; background: #F1F1FA; width: 400px; height: 300px; display: block; margin: 10px auto; border: 0;&#125;&lt;/style&gt;&lt;img src=\"https://ik.imagekit.io/demo/img/image1.jpeg?tr=w-400,h-300\" /&gt;&lt;img src=\"https://ik.imagekit.io/demo/img/image2.jpeg?tr=w-400,h-300\" /&gt;&lt;img src=\"https://ik.imagekit.io/demo/img/image3.jpg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image4.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image5.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image6.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image7.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image8.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image9.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image10.jpeg?tr=w-400,h-300\" /&gt;&lt;script&gt; document.addEventListener(\"DOMContentLoaded\", function() &#123; var lazyloadImages = document.querySelectorAll(\"img.lazy\"); var lazyloadThrottleTimeout; function lazyload () &#123; if(lazyloadThrottleTimeout) &#123; clearTimeout(lazyloadThrottleTimeout); &#125; lazyloadThrottleTimeout = setTimeout(function() &#123; var scrollTop = window.pageYOffset; lazyloadImages.forEach(function(img) &#123; if(img.offsetTop &lt; (window.innerHeight + scrollTop)) &#123; img.src = img.dataset.src; img.classList.remove('lazy'); &#125; &#125;); if(lazyloadImages.length == 0) &#123; document.removeEventListener(\"scroll\", lazyload); window.removeEventListener(\"resize\", lazyload); window.removeEventListener(\"orientationChange\", lazyload); &#125; &#125;, 20); &#125; document.addEventListener(\"scroll\", lazyload); window.addEventListener(\"resize\", lazyload); window.addEventListener(\"orientationChange\", lazyload);&#125;);&lt;/script&gt; 方法2、使用Intersection Observer API触发图像加载好了，现在我们先学习下： 1. API用法非常简单 1var io = new IntersectionObserver(callback, option); 上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。 构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。 12345678// 开始观察io.observe(document.getElementById('example'));// 停止观察io.unobserve(element);// 关闭观察器io.disconnect(); 上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。 12io.observe(elementA);io.observe(elementB); 2. callback 参数目标元素的可见性变化时，就会调用观察器的回调函数callback。 callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。 12345var io = new IntersectionObserver( entries =&gt; &#123; console.log(entries); &#125;); 3. IntersectionObserverEntry 对象IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。 12345678910111213141516171819&#123; time: 3893.92, rootBounds: ClientRect &#123; bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 &#125;, boundingClientRect: ClientRect &#123; // ... &#125;, intersectionRect: ClientRect &#123; // ... &#125;, intersectionRatio: 0.54, target: element&#125; 每个属性的含义如下。 time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target：被观察的目标元素，是一个 DOM 节点对象 rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动）， 则- 返回null boundingClientRect：目标元素的矩形区域的信息 intersectionRect：目标元素与视口（或根元素）的交叉区域的信息 intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见 时- 小于等于0 学到这里先来实现下我们上个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849document.addEventListener(\"DOMContentLoaded\", function() &#123; var lazyloadImages; if (\"IntersectionObserver\" in window) &#123; lazyloadImages = document.querySelectorAll(\".lazy\"); var imageObserver = new IntersectionObserver(function(entries, observer) &#123; entries.forEach(function(entry) &#123; if (entry.isIntersecting) &#123; var image = entry.target; image.src = image.dataset.src; image.classList.remove(\"lazy\"); imageObserver.unobserve(image); &#125; &#125;); &#125;); lazyloadImages.forEach(function(image) &#123; imageObserver.observe(image); &#125;); &#125; else &#123; var lazyloadThrottleTimeout; lazyloadImages = document.querySelectorAll(\".lazy\"); function lazyload () &#123; if(lazyloadThrottleTimeout) &#123; clearTimeout(lazyloadThrottleTimeout); &#125; lazyloadThrottleTimeout = setTimeout(function() &#123; var scrollTop = window.pageYOffset; lazyloadImages.forEach(function(img) &#123; if(img.offsetTop &lt; (window.innerHeight + scrollTop)) &#123; img.src = img.dataset.src; img.classList.remove('lazy'); &#125; &#125;); if(lazyloadImages.length == 0) &#123; document.removeEventListener(\"scroll\", lazyload); window.removeEventListener(\"resize\", lazyload); window.removeEventListener(\"orientationChange\", lazyload); &#125; &#125;, 20); &#125; document.addEventListener(\"scroll\", lazyload); window.addEventListener(\"resize\", lazyload); window.addEventListener(\"orientationChange\", lazyload); &#125;&#125;) 4. Option 对象IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。 threshold 属性threshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。 123456new IntersectionObserver( entries =&gt; &#123;/* ... */&#125;, &#123; threshold: [0, 0.25, 0.5, 0.75, 1] &#125;); 用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。 root 属性，rootMargin 属性很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。 IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。 123456789var opts = &#123; root: document.querySelector('.container'), rootMargin: \"500px 0px\" &#125;;var observer = new IntersectionObserver( callback, opts); 上面代码中，除了root属性，还有rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom和 left 四个方向的值。 延迟加载CSS背景图像1234.my-class &#123; background-image: url('/path/to/some/image.jpg'); /* more styles */&#125; CSS背景图像不像图像标记那么简单。要加载它们，浏览器需要构建DOM树以及CSSOM树来确定CSS样式是否适用于当前文档中的DOM节点。如果指定背景图像的CSS规则不适用于文档中的元素，则浏览器不会加载背景图像。如果CSS规则适用于当前文档中的元素，则浏览器会加载图像。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 &lt;style&gt; * &#123; font-family: sans-serif;&#125;#container &#123; font-size: 20px; line-height: 30px; max-width: 600px;&#125;#bg-image.lazy &#123; background-image: none; background-color: #F1F1FA;&#125;#bg-image &#123; background-image: url(\"https://ik.imagekit.io/demo/img/image10.jpeg?tr=w-600,h-400\"); max-width: 600px; height: 400px;&#125; &lt;/style&gt; &lt;div id=\"container\"&gt; &lt;h3&gt;Lazy loading CSS background images&lt;/h3&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam at ligula non lorem facilisis finibus. Suspendisse turpis lacus, tempus sit amet dignissim sit amet, pretium non sem. Ut malesuada purus ac magna placerat, tempus commodo turpis consectetur. Nunc vitae metus vehicula nunc congue varius. Suspendisse egestas urna non finibus feugiat. Vestibulum maximus, nunc et tempus convallis, dui ante vestibulum est, in lobortis purus sapien eget lacus. Suspendisse cursus enim non quam mollis imperdiet. Pellentesque convallis eget nunc vitae fringilla. Fusce interdum, velit semper varius aliquet, eros sapien facilisis erat, iaculis vulputate erat arcu vel neque. Suspendisse dignissim hendrerit lorem. Etiam metus ex, finibus vitae iaculis vitae, iaculis non ex. Phasellus commodo id ante id consequat. Nunc consectetur viverra lacus non fringilla. Pellentesque nec nisl vulputate, sagittis nisl id, venenatis nisi. Nunc malesuada tellus a elit suscipit tempor. &lt;/p&gt; &lt;p&gt;Nam lacinia tortor quis volutpat lacinia. Aliquam in orci in nunc vehicula maximus. Phasellus elementum nulla augue, at aliquam sem pulvinar dapibus. Vivamus molestie venenatis risus pulvinar interdum. Phasellus blandit tortor eget nulla sagittis auctor. Cras sed leo in velit lobortis euismod. Suspendisse non ante tellus. &lt;/p&gt; &lt;div id=\"bg-image\" class=\"lazy\"&gt;&lt;/div&gt; &lt;p&gt;Nam lacinia tortor quis volutpat lacinia. Aliquam in orci in nunc vehicula maximus. Phasellus elementum nulla augue, at aliquam sem pulvinar dapibus. Vivamus molestie venenatis risus pulvinar interdum. Phasellus blandit tortor eget nulla sagittis auctor. Cras sed leo in velit lobortis euismod. Suspendisse non ante tellus. &lt;/p&gt;&lt;/div&gt; &lt;script&gt; document.addEventListener(\"DOMContentLoaded\", function() &#123; var lazyloadImages; if (\"IntersectionObserver\" in window) &#123; lazyloadImages = document.querySelectorAll(\".lazy\"); var imageObserver = new IntersectionObserver(function(entries, observer) &#123; entries.forEach(function(entry) &#123; if (entry.isIntersecting) &#123; var image = entry.target; image.classList.remove(\"lazy\"); imageObserver.unobserve(image); &#125; &#125;); &#125;); lazyloadImages.forEach(function(image) &#123; imageObserver.observe(image); &#125;); &#125; else &#123; var lazyloadThrottleTimeout; lazyloadImages = document.querySelectorAll(\".lazy\"); function lazyload () &#123; if(lazyloadThrottleTimeout) &#123; clearTimeout(lazyloadThrottleTimeout); &#125; lazyloadThrottleTimeout = setTimeout(function() &#123; var scrollTop = window.pageYOffset; lazyloadImages.forEach(function(img) &#123; if(img.offsetTop &lt; (window.innerHeight + scrollTop)) &#123; img.src = img.dataset.src; img.classList.remove('lazy'); &#125; &#125;); if(lazyloadImages.length == 0) &#123; document.removeEventListener(\"scroll\", lazyload); window.removeEventListener(\"resize\", lazyload); window.removeEventListener(\"orientationChange\", lazyload); &#125; &#125;, 20); &#125; document.addEventListener(\"scroll\", lazyload); window.addEventListener(\"resize\", lazyload); window.addEventListener(\"orientationChange\", lazyload); &#125;&#125;) &lt;/script&gt; 使用延迟加载创建更好的用户体验使用正确的占位符为要加载的图像添加缓冲时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;style&gt;img &#123; background: #F1F1FA; width: 400px; height: 300px; display: block; margin: 10px auto; border: 0;&#125;#container &#123; height: 420px; overflow-y: scroll;&#125;&lt;/style&gt;&lt;div id=\"container\"&gt;&lt;img src=\"https://ik.imagekit.io/demo/img/image1.jpeg?tr=w-400,h-300\" /&gt;&lt;img src=\"https://ik.imagekit.io/demo/img/image2.jpeg?tr=w-400,h-300\" /&gt;&lt;img src=\"https://ik.imagekit.io/demo/img/image3.jpg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image4.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image5.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image6.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image7.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image8.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image9.jpeg?tr=w-400,h-300\" /&gt;&lt;img class=\"lazy\" data-src=\"https://ik.imagekit.io/demo/img/image10.jpeg?tr=w-400,h-300\" /&gt;&lt;/div&gt;&lt;script&gt;$(document).ready(function() &#123; var lazyloadImages; if (\"IntersectionObserver\" in window) &#123; lazyloadImages = document.querySelectorAll(\".lazy\"); var imageObserver = new IntersectionObserver(function(entries, observer) &#123; console.log(observer); entries.forEach(function(entry) &#123; if (entry.isIntersecting) &#123; var image = entry.target; image.src = image.dataset.src; image.classList.remove(\"lazy\"); imageObserver.unobserve(image); &#125; &#125;); &#125;, &#123; root: document.querySelector(\"#container\"), rootMargin: \"0px 0px 500px 0px\" &#125;); lazyloadImages.forEach(function(image) &#123; imageObserver.observe(image); &#125;); &#125; else &#123; var lazyloadThrottleTimeout; lazyloadImages = $(\".lazy\"); function lazyload () &#123; if(lazyloadThrottleTimeout) &#123; clearTimeout(lazyloadThrottleTimeout); &#125; lazyloadThrottleTimeout = setTimeout(function() &#123; var scrollTop = $(window).scrollTop(); lazyloadImages.each(function() &#123; var el = $(this); if(el.offset().top &lt; window.innerHeight + scrollTop + 500) &#123; var url = el.attr(\"data-src\"); el.attr(\"src\", url); el.removeClass(\"lazy\"); lazyloadImages = $(\".lazy\"); &#125; &#125;); if(lazyloadImages.length == 0) &#123; $(document).off(\"scroll\"); $(window).off(\"resize\"); &#125; &#125;, 20); &#125; $(document).on(\"scroll\", lazyload); $(window).on(\"resize\", lazyload); &#125;&#125;)&lt;/script&gt; 避免延迟加载每张图片","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"图片懒加载指南","slug":"技术/图片懒加载指南","permalink":"https://www.kaige1220.top/categories/技术/图片懒加载指南/"}],"tags":[{"name":"图片懒加载指南","slug":"图片懒加载指南","permalink":"https://www.kaige1220.top/tags/图片懒加载指南/"}]},{"title":"webpack进阶知识","slug":"webpack进阶知识","date":"2018-11-16T00:49:52.164Z","updated":"2018-11-16T01:05:38.628Z","comments":true,"path":"2018/11/16/webpack进阶知识/","link":"","permalink":"https://www.kaige1220.top/2018/11/16/webpack进阶知识/","excerpt":"","text":"webpack模块化思想 类似于Node.js 的模块化：先看下Node模块对象的数据结构： 1234567891011121314&#123; '/Users/alienzhou/programming/gitrepo/test.js': Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/alienzhou/programming/gitrepo/test.js', loaded: false, children: [], paths: [ '/Users/alienzhou/programming/gitrepo/node_modules', '/Users/alienzhou/programming/node_modules', '/Users/alienzhou/node_modules', '/Users/node_modules', '/node_modules' ] &#125; &#125; Node会自动将每个模块进行包装（wrap），将其变为一个function。 当你require它时，一个完整的方法调用大致包括下面几个过程： 1234567891011st=&gt;start: require()引入模块op1=&gt;operation: 调用._load()加载模块op2=&gt;operation: new Module(filename, parent)创建模块对象op3=&gt;operation: 将模块对象存入缓存op4=&gt;operation: 根据文件类型调用Module._extensionsop5=&gt;operation: 调用.compile()编译执行js模块cond=&gt;condition: Module._cache是否无缓存e=&gt;end: 返回module.exports结果st-&gt;op1-&gt;condcond(yes)-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;econd(no)-&gt;e webpack实现的前端模块化和Node的模块化实现类似，在webpack打包出的代码中，每个模块也有一个对应的模块对象。在webpack_require()方法中，有这么一段代码： 12345678910111213function __webpack_require__(moduleId) &#123; // …… other code var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125;, parents: null, children: [] &#125;; // …… other code&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"webpack","slug":"技术/webpack","permalink":"https://www.kaige1220.top/categories/技术/webpack/"},{"name":"webpack进阶知识","slug":"技术/webpack/webpack进阶知识","permalink":"https://www.kaige1220.top/categories/技术/webpack/webpack进阶知识/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.kaige1220.top/tags/webpack/"},{"name":"webpack进阶知识","slug":"webpack进阶知识","permalink":"https://www.kaige1220.top/tags/webpack进阶知识/"}]},{"title":"css模块化","slug":"css模块化","date":"2018-11-15T08:36:34.728Z","updated":"2018-11-15T09:16:25.878Z","comments":true,"path":"2018/11/15/css模块化/","link":"","permalink":"https://www.kaige1220.top/2018/11/15/css模块化/","excerpt":"BEM了解BEM 命名规范 BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。在具体CSS类选择器上的表现就像下面这样 1234.block &#123;&#125;.block__element &#123;&#125;.block--modifier &#123;&#125;.block__element--modifier &#123;&#125;","text":"BEM了解BEM 命名规范 BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。在具体CSS类选择器上的表现就像下面这样 1234.block &#123;&#125;.block__element &#123;&#125;.block--modifier &#123;&#125;.block__element--modifier &#123;&#125; 12345&lt;ul class=\"list\"&gt; &lt;li class=\"list__item\"&gt;learn html&lt;/li&gt; &lt;li class=\"list__item list__item--underline\"&gt;learn css&lt;/li&gt; &lt;li class=\"list__item\"&gt;learn js&lt;/li&gt;&lt;/ul&gt; 规定项目的命名空间 Object: o-当你使用面向对象的CSS（Object-Oriented CSS）时，o-这个namespace将会非常有用。 Component: c-c-应该是一个更为常见的namespace，表示Components（组件）。 Utility: u-Utilities符合单一职责原则，实现一个具体的功能或效果。其概念有些类似JavaScript中的通用工具方法。例如一个清除浮动的Utility，或者一个文字居中的Utility。 12.u-clearfix &#123;&#125;.u-textCenter &#123;&#125; 在SASS中使用BEM-constructorBEM-constructor是基于SASS的一个工具。使用BEM-constructor可以帮助规范并快速地创建符合BEM与namespace规范的class。BEM-constructor的语法非常简单。 1npm install sass-bem-constructor --save-dev 首先在SASS引入@import &#39;bem-constructor&#39;;，然后使用@include block($name, $type) { ... }创建block，其中$name是block的名字，$type是namespace的类型（&#39;object&#39;, &#39;component&#39;和&#39;utility&#39;）。类似得，使用element($name...)和modifier($name...)可以快速生成block中的其他部分。 1234567891011121314151617@import 'sass-bem-constructor/dist/_sass-bem-constructor.scss';@include block('list', 'component') &#123; margin: 15px; padding: 0; @include element('item') &#123; margin: 10px 0; border-left: 3px solid #333; font-size: 15px; color: #333; list-style: none; @include modifier('underline') &#123; color: #111; text-decoration: underline; &#125; &#125;&#125; 生成如下内容： 123456789101112131415.c-list &#123; margin: 15px; padding: 0;&#125;.c-list__item &#123; margin: 10px 0; border-left: 3px solid #333; font-size: 15px; color: #333; list-style: none;&#125;.c-list__item--underline &#123; color: #111; text-decoration: underline;&#125; webpack中的Local Scope什么是Local Scope通常来说，CSS中的所有选择器可以算是“全局作用域”。而“Local Scope”顾名思义，使CSS具有类似于局部作用域的能力，同时搭配类似JavaScript中模块化的写法，到达CSS模块化的效果。 使用方法首先，需要在webpack中对css-loader进行一定的配置。123456789101112131415161718192021const config = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true, localIdentName: '[local]__[name]--[hash:base64:5]' &#125; &#125;] &#125;] &#125;&#125;; 上面的123456&#123; loader: 'css-loader', options: &#123; modules: true, localIdentName: '[local]__[name]--[hash:base64:5]' &#125; 就是需要配置的部分了。 使用styled-components来进行react开发在react中使用styled-components基本用法基本语法： 123456789101112131415import styled from 'styled-components';const ListWrap = styled.ul` margin: 0; padding: 0;`;const Item = styled.li` margin: 10px 0; padding: 5px 15px; border-left: 3px solid #333; font-size: 16px; list-style: none; font-weight: bold;`; 当我们将这个styled的li元素赋给了Item这个变量时，我们也就创建了一个叫Item的React组件。因此，我们可以在JSX中直接使用Item 123456789101112import React, &#123;Component&#125; from 'react';export default class List extends Component &#123; render() &#123; return ( &lt;ListWrap&gt; &lt;Item&gt;这是一条普通的记录&lt;/Item&gt; &lt;Item&gt;这也是一条普通的记录&lt;/Item&gt; &lt;/ListWrap&gt; ) &#125;&#125; 在使用styled设置css样式的语法里，用到了模板字符串。因此，对于样式，我们完全可以加入变量计算。更进一步的，我们可以通过获取React组件的props来更改相应的css属性：123456789const Item = styled.li` margin: 10px 0; padding: 5px 15px; border-left: 3px solid #333; font-size: 16px; list-style: none; font-weight: bold; text-decoration: $&#123;props =&gt; props.underline ? 'underline' : 'none'&#125;;`; 1234567891011export default class List extends Component &#123; render() &#123; return ( &lt;ListWrap&gt; &lt;Item&gt;这是一条普通的记录&lt;/Item&gt; &lt;Item&gt;这也是一条普通的记录&lt;/Item&gt; &lt;Item underline&gt;这条记录有一条下划线&lt;/Item&gt; &lt;/ListWrap&gt; ) &#125;&#125; 扩展已有样式对于上一节中的Item组件，我们想要在此基础上，创建一个红底白字的新Item样式，但是其他属性（字体、边距等）保持一致。使用styled-components的styled方法可以很容易实现： 1234567891011121314151617const RedItem = styled(Item)` color: #fff; background: #991302;`;export default class List extends Component &#123; render() &#123; return ( &lt;ListWrap&gt; &lt;Item&gt;这是一条普通的记录&lt;/Item&gt; &lt;Item&gt;这也是一条普通的记录&lt;/Item&gt; &lt;Item underline&gt;这条记录有一条下划线&lt;/Item&gt; &lt;RedItem&gt;这是一条红色的记录&lt;/RedItem&gt; &lt;/ListWrap&gt; ) &#125;&#125; 样式继承在styled-components中，对于组件的样式继承可以使用extend方法。因此，对于上一小节中的RedItem组件，我们也完全可以使用extend方法来实现： 1234const RedItem = Item.extend` color: #fff; background: #991302;`; 扩展样式和样式继承的区别： styled方法会创建一个新的类.iVuaxi来应用这两行样式，而Item本身的样式依旧存在于.bWdYgn类中； 而使用extend方法后则会在.fYpJfw类中实现所有的样式，并不会创建两个css类。 尽量使用继承方式。 修改标签类型除了需要继承组件样式外，有时候，我们可能想要更换该组件的HTML标签。例如按钮，我们已经有了一个button组件的样式，想要再创造一个一样的a标签按钮。这时候，我们就可以使用withComponent方法： 12345678910111213141516const DivItem = Item.withComponent('div');export default class List extends Component &#123; render() &#123; return ( &lt;ListWrap&gt; &lt;Item&gt;这是一条普通的记录&lt;/Item&gt; &lt;Item&gt;这也是一条普通的记录&lt;/Item&gt; &lt;Item underline&gt;这条记录有一条下划线&lt;/Item&gt; &lt;RedItem&gt;这是一条红色的记录&lt;/RedItem&gt; &lt;ExtendedItem&gt;这条记录使用了‘extend’&lt;/ExtendedItem&gt; &lt;DivItem&gt;这实际上是个div &lt;/DivItem&gt; &lt;/ListWrap&gt; ) &#125;&#125; 添加动画keyframes需要从styled-components库中导出一个keyframes方法。 首先，使用keyframes方法创建css3动画 12345678910111213import styled, &#123;keyframes&#125; from 'styled-components';const MyAnimation = keyframes` from &#123; padding-left: 0; background: #991302; &#125; to &#123; padding-left: 50px; background: #009317; &#125;`; 然后，使用继承的方式，创建一个带动画的组件 123const AnimateItem = RedItem.extend` animation: $&#123;MyAnimation&#125; 2s linear infinite alternate;`; 全局样式有些时候，在开发中需要设置一些全局的样式，这个该怎么处理呢？典型的，当我们想要为body元素设置一些属性时，该怎么办呢？ styled-components提供了injectGlobal方法来实现它。调用injectGlobal并不会返回一个组件，而是会将injectGlobal中的css相关样式直接添加到标签内部。同样的，需要导出injectGlobal方法： 12345678import styled, &#123;keyframes, injectGlobal&#125; from 'styled-components';injectGlobal` body &#123; border: 5px solid #991302; background: #ddd; &#125;`; &lt;-完-&gt;","categories":[{"name":"技术规范","slug":"技术规范","permalink":"https://www.kaige1220.top/categories/技术规范/"},{"name":"css模块化","slug":"技术规范/css模块化","permalink":"https://www.kaige1220.top/categories/技术规范/css模块化/"}],"tags":[{"name":"css模块化","slug":"css模块化","permalink":"https://www.kaige1220.top/tags/css模块化/"}]},{"title":"Koa 学习","slug":"koa学习","date":"2018-11-07T08:46:10.774Z","updated":"2018-11-08T01:08:24.597Z","comments":true,"path":"2018/11/07/koa学习/","link":"","permalink":"https://www.kaige1220.top/2018/11/07/koa学习/","excerpt":"中间件引擎1234567891011121314151617181920212223242526272829303132333435363738const Koa = require('koa');let app = new Koa();const middleware1 = async (ctx, next) =&gt; &#123; console.log(1); await next(); console.log(6); &#125;const middleware2 = async (ctx, next) =&gt; &#123; console.log(2); await next(); console.log(5); &#125;const middleware3 = async (ctx, next) =&gt; &#123; console.log(3); await next(); console.log(4); &#125;app.use(middleware1);app.use(middleware2);app.use(middleware3);app.use(async(ctx, next) =&gt; &#123; ctx.body = 'hello world'&#125;)app.listen(3001)// 启动访问浏览器// 控制台会出现以下结果// 1// 2// 3// 4// 5// 6","text":"中间件引擎1234567891011121314151617181920212223242526272829303132333435363738const Koa = require('koa');let app = new Koa();const middleware1 = async (ctx, next) =&gt; &#123; console.log(1); await next(); console.log(6); &#125;const middleware2 = async (ctx, next) =&gt; &#123; console.log(2); await next(); console.log(5); &#125;const middleware3 = async (ctx, next) =&gt; &#123; console.log(3); await next(); console.log(4); &#125;app.use(middleware1);app.use(middleware2);app.use(middleware3);app.use(async(ctx, next) =&gt; &#123; ctx.body = 'hello world'&#125;)app.listen(3001)// 启动访问浏览器// 控制台会出现以下结果// 1// 2// 3// 4// 5// 6 路由koa原生路由的实现ctx.request.path 12345678const main = ctx =&gt; &#123; if (ctx.request.path !== '/') &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;a href=\"/\"&gt;Index Page&lt;/a&gt;'; &#125; else &#123; ctx.response.body = 'Hello World'; &#125;&#125;; koa 路由组件1、安装 install --save koa-router@7```1234567891011121314151617182、快速使用koa-router```jsconst route = require(&apos;koa-route&apos;);const about = ctx =&gt; &#123; ctx.response.type = &apos;html&apos;; ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;&#125;;const main = ctx =&gt; &#123; ctx.response.body = &apos;Hello World&apos;;&#125;;app.use(route.get(&apos;/&apos;, main));app.use(route.get(&apos;/about&apos;, about)); 1234567891011121314151617181920212223242526272829303132333435363738const Koa = require('koa')const fs = require('fs')const app = new Koa()const Router = require('koa-router')let home = new Router()// 子路由1home.get('/', async ( ctx )=&gt;&#123; let html = ` &lt;ul&gt; &lt;li&gt;&lt;a href=\"/page/helloworld\"&gt;/page/helloworld&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/page/404\"&gt;/page/404&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; ` ctx.body = html&#125;)// 子路由2let page = new Router()page.get('/404', async ( ctx )=&gt;&#123; ctx.body = '404 page!'&#125;).get('/helloworld', async ( ctx )=&gt;&#123; ctx.body = 'helloworld page!'&#125;)// 装载所有子路由let router = new Router()router.use('/', home.routes(), home.allowedMethods())router.use('/page', page.routes(), page.allowedMethods())// 加载路由中间件app.use(router.routes()).use(router.allowedMethods())app.listen(3000, () =&gt; &#123; console.log('[demo] route-use-middleware is starting at port 3000')&#125;) 数据请求get 请求数据在koa中，获取GET请求数据源头是koa中request对象中的query方法或querystring方法，query返回是格式化好的参数对象，querystring返回的是请求字符串，由于ctx对request的API有直接引用的方式，所以获取GET请求数据有两个途径。 1.是从上下文中直接获取 请求对象ctx.query，返回如 { a:1, b:2 } 请求字符串 ctx.querystring，返回如 a=1&amp;b=22.是从上下文的request对象中获取 请求对象ctx.request.query，返回如 { a:1, b:2 } 请求字符串 ctx.request.querystring，返回如 a=1&amp;b=2 1234567891011121314151617181920212223242526const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123; let url = ctx.url // 从上下文的request对象中获取 let request = ctx.request let req_query = request.query let req_querystring = request.querystring // 从上下文中直接获取 let ctx_query = ctx.query let ctx_querystring = ctx.querystring ctx.body = &#123; url, req_query, req_querystring, ctx_query, ctx_querystring &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] request get is starting at port 3000')&#125;) post 请求koa-bodyparser中间件 对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中 安装koa2版本的koa-bodyparser@3中间件 install --save koa-bodyparser@3```1234567891011121314151617181920212223242526272829303132333435363738394041424344```jsconst Koa = require(&apos;koa&apos;)const app = new Koa()const bodyParser = require(&apos;koa-bodyparser&apos;)// 使用ctx.body解析中间件app.use(bodyParser())app.use( async ( ctx ) =&gt; &#123; if ( ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos; ) &#123; // 当GET请求时候返回表单页面 let html = ` &lt;h1&gt;koa2 request post demo&lt;/h1&gt; &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt; &lt;p&gt;nickName&lt;/p&gt; &lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt; &lt;p&gt;email&lt;/p&gt; &lt;input name=&quot;email&quot; /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html &#125; else if ( ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;POST&apos; ) &#123; // 当POST请求的时候，中间件koa-bodyparser解析POST表单里的数据，并显示出来 let postData = ctx.request.body ctx.body = postData &#125; else &#123; // 其他请求显示404 ctx.body = &apos;&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;&apos; &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log(&apos;[demo] request post is starting at port 3000&apos;)&#125;) 加载静态资源使用koa-static中间件 12345const path = require('path');const serve = require('koa-static');const main = serve(path.join(__dirname));app.use(main); 123456789101112131415161718192021const Koa = require('koa')const path = require('path')const static = require('koa-static')const app = new Koa()// 静态资源目录对于相对入口文件index.js的路径const staticPath = './static'app.use(static( path.join( __dirname, staticPath)))app.use( async ( ctx ) =&gt; &#123; ctx.body = 'hello world'&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] static-use-middleware is starting at port 3000')&#125;) 重定向有些场合，服务器需要重定向（redirect）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由。 123456const redirect = ctx =&gt; &#123; ctx.response.redirect('/'); ctx.response.body = '&lt;a href=\"/\"&gt;Index Page&lt;/a&gt;';&#125;;app.use(route.get('/redirect', redirect)); 使用cookie/sessionkoa提供了从上下文直接读取、写入cookie的方法 ctx.cookies.get(name, [options]) 读取上下文请求中的cookie ctx.cookies.set(name, value, [options]) 在上下文中写入cookie 12345678910111213141516171819202122232425262728const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123;if ( ctx.url === '/index' ) &#123; ctx.cookies.set( 'cid', 'hello world', &#123; domain: 'localhost', // 写cookie所在的域名 path: '/index', // 写cookie所在的路径 maxAge: 10 * 60 * 1000, // cookie有效时长 expires: new Date('2017-02-15'), // cookie失效时间 httpOnly: false, // 是否只用于http请求中获取 overwrite: false // 是否允许重写 &#125; ) ctx.body = 'cookie is ok'&#125; else &#123; ctx.body = 'hello world' &#125;&#125;) app.listen(3000, () =&gt; &#123;console.log('[demo] cookie is starting at port 3000')&#125;) koa2原生功能只提供了cookie的操作，但是没有提供session操作。session就只用自己实现或者通过第三方中间件实现。在koa2中实现session的方案有以下几种： 如果session数据量很小，可以直接存在内存中 如果session数据量很大，则需要存储介质存放session数据 数据库存储方案将session存放在MySQL数据库中 需要用到中间件 koa-session-minimal 适用于koa2 的session中间件，提供存储介质的读写接口 。 koa-mysql-session 为koa-session-minimal中间件提供MySQL数据库的session数据读写操作。 将sessionId和对于的数据存到数据库 将数据库的存储的sessionId存到页面的cookie中 根据cookie的sessionId去获取对于的session信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const Koa = require('koa')const session = require('koa-session-minimal')const MysqlSession = require('koa-mysql-session')const app = new Koa()// 配置存储session信息的mysqllet store = new MysqlSession(&#123; user: 'root', password: 'abc123', database: 'koa_demo', host: '127.0.0.1',&#125;)// 存放sessionId的cookie配置let cookie = &#123; maxAge: '', // cookie有效时长 expires: '', // cookie失效时间 path: '', // 写cookie所在的路径 domain: '', // 写cookie所在的域名 httpOnly: '', // 是否只用于http请求中获取 overwrite: '', // 是否允许重写 secure: '', sameSite: '', signed: '',&#125;// 使用session中间件app.use(session(&#123; key: 'SESSION_ID', store: store, cookie: cookie&#125;))app.use( async ( ctx ) =&gt; &#123; // 设置session if ( ctx.url === '/set' ) &#123; ctx.session = &#123; user_id: Math.random().toString(36).substr(2), count: 0 &#125; ctx.body = ctx.session &#125; else if ( ctx.url === '/' ) &#123; // 读取session信息 ctx.session.count = ctx.session.count + 1 ctx.body = ctx.session &#125; &#125;)app.listen(3000)console.log('[demo] session is starting at port 3000') 模板引擎加载安装模板install --save koa-views```1234567891011121314151617181920212223242526272829303132### 使用模板目录结构：├── package.json├── index.js└── view └── index.ejs### ./index.js 下配置：```jsconst Koa = require(&apos;koa&apos;)const views = require(&apos;koa-views&apos;)const path = require(&apos;path&apos;)const app = new Koa()// 加载模板引擎app.use(views(path.join(__dirname, &apos;./view&apos;), &#123; extension: &apos;ejs&apos;&#125;))app.use( async ( ctx ) =&gt; &#123; let title = &apos;hello koa2&apos; await ctx.render(&apos;index&apos;, &#123; title, &#125;)&#125;)app.listen(3000) ./view/index.ejs 模板12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;EJS Welcome to &lt;%= title %&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;未完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"node","slug":"技术/node","permalink":"https://www.kaige1220.top/categories/技术/node/"},{"name":"koa","slug":"技术/node/koa","permalink":"https://www.kaige1220.top/categories/技术/node/koa/"}],"tags":[{"name":"node","slug":"node","permalink":"https://www.kaige1220.top/tags/node/"},{"name":"koa","slug":"koa","permalink":"https://www.kaige1220.top/tags/koa/"}]},{"title":"投资感想一二","slug":"投资感想","date":"2018-09-03T09:11:40.702Z","updated":"2018-09-03T09:58:21.232Z","comments":true,"path":"2018/09/03/投资感想/","link":"","permalink":"https://www.kaige1220.top/2018/09/03/投资感想/","excerpt":"","text":"卖出的理由： １、 当时为啥买，现在这个逻辑发生变化了么？ 2、 有更便宜的标的，我买更便宜的。 3、 企业发展出现了重大变化。 4、 另外一个就是仓位的控制，每一个标的不要超过25%。 做短的话， 按照收益比， 止损3% 止盈9% 熊市艰难缩短距离。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"感想","slug":"投资/感想","permalink":"https://www.kaige1220.top/categories/投资/感想/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"}]},{"title":"jquery 学习","slug":"jquery学习","date":"2018-08-30T06:05:24.831Z","updated":"2018-08-31T01:04:40.395Z","comments":true,"path":"2018/08/30/jquery学习/","link":"","permalink":"https://www.kaige1220.top/2018/08/30/jquery学习/","excerpt":"","text":"jquery 的起始句子： 123$(document).ready(function()&#123;&#125;); $(“button”).addClass(“animated bounce”) 来学习下方法 1、 .css(“color”,”blue”) 2、 .prop(“disabled”, ture) 让属性不可用 3、 .html(“”) 更换内容 和 。text(“”) 的区别 4、 .remove() 5、 .appendTo() 把一个标签元素移动另一个标签里面。 这个是剪切 还有一种是复制 .clone().appendTo() 6、 .parent() .children() 7、 伪类选择器 ：nth-child(*) :odd :even","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"jquery","slug":"技术/jquery","permalink":"https://www.kaige1220.top/categories/技术/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://www.kaige1220.top/tags/jquery/"}]},{"title":"bootstrap 学习","slug":"bootstrap学习","date":"2018-08-29T07:09:35.704Z","updated":"2018-08-30T06:05:14.332Z","comments":true,"path":"2018/08/29/bootstrap学习/","link":"","permalink":"https://www.kaige1220.top/2018/08/29/bootstrap学习/","excerpt":"","text":"组织排版内容，更多的请参考官方文档。 1、 内容一般都包含在class为：container-fluid 的div里面 2、图片自适应 class=”img-reponsive” 3、文字居中 class=”text-center” 另外文字 text-danger 文字红色 4、 按钮 class=”btn” 或者是 ntn-block btn-primary btn-info btn-danger注意他们的区别 5、 网格布局 全局被 div.row 包裹 每个块被div.col-xs- 或者div.col-md- 包裹 6、 Font Awesome 图标库非常好用 i元素 指代图标 i.fa fa-thumbs-up 等等 7、 class=”well” Bootstrap 有一个 class 属性叫做 well，它的作用是为设定的列创造出一种视觉上的深度感。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"bootstrap","slug":"技术/bootstrap","permalink":"https://www.kaige1220.top/categories/技术/bootstrap/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://www.kaige1220.top/tags/bootstrap/"}]},{"title":"每周总结","slug":"每周总结18.8.26","date":"2018-08-27T13:31:26.367Z","updated":"2018-09-03T09:59:39.866Z","comments":true,"path":"2018/08/27/每周总结18.8.26/","link":"","permalink":"https://www.kaige1220.top/2018/08/27/每周总结18.8.26/","excerpt":"一、好软件1、一款功能强大的 macOS 版微信小助手 功能多样： 消息防撤回 自动回复微信多开 远程控制 (测试关闭Chrome、QQ、开启屏幕保护) 免认证 &amp; 置底 &amp; 多选删除 通知中心快捷回复 聊天窗口表情复制 &amp; 存储一键已读 &amp; 一键清除空回话 具体使用情参考网站详情","text":"一、好软件1、一款功能强大的 macOS 版微信小助手 功能多样： 消息防撤回 自动回复微信多开 远程控制 (测试关闭Chrome、QQ、开启屏幕保护) 免认证 &amp; 置底 &amp; 多选删除 通知中心快捷回复 聊天窗口表情复制 &amp; 存储一键已读 &amp; 一键清除空回话 具体使用情参考网站详情 2、listen1 音乐播放器 多平台最强大的音乐播放器， 不解释系列。 具体请看网站详情。 二、好网站1、3D图像构建 特别好的3D网站 2、 交到更好的朋友，学到更好的技能，来吧，朋友 3、100d 学习机器学习 三、好插件以下是关于chrome的插件 1、Refined GitHub 2、简悦 ( SimpRead ) - 让你瞬间进入沉浸式阅读的扩展 3、划词翻译 四、好图片亲子系列 蜗牛系列","categories":[{"name":"每周总结","slug":"每周总结","permalink":"https://www.kaige1220.top/categories/每周总结/"}],"tags":[{"name":"每周总结1","slug":"每周总结1","permalink":"https://www.kaige1220.top/tags/每周总结1/"}]},{"title":"javascript十九个小技巧","slug":"js十九个小技巧","date":"2018-08-20T00:30:21.069Z","updated":"2018-08-20T00:37:45.275Z","comments":true,"path":"2018/08/20/js十九个小技巧/","link":"","permalink":"https://www.kaige1220.top/2018/08/20/js十九个小技巧/","excerpt":"三元操作符如果使用if...else语句，那么这是一个很好节省代码的方式。 Longhand: 12345678const x = 20;let big;if (x &gt; 10) &#123; big = true;&#125; else &#123; big = false;&#125;","text":"三元操作符如果使用if...else语句，那么这是一个很好节省代码的方式。 Longhand: 12345678const x = 20;let big;if (x &gt; 10) &#123; big = true;&#125; else &#123; big = false;&#125; Shorthand: 1const big = x &gt; 10 ? true : false; 你还可以像下面这样嵌套if语句： 1const big = x &gt; 10 ? 'greater 10' : x &lt; 5 ? 'less 5' : 'between 5 and 10'; Short-circuit Evaluation分配一个变量值到另一个变量的时候，你可能想要确保变量不是null、undefined或空。你可以写一个有多个if的条件语句或者Short-circuit Evaluation。 Longhand: 123if (variable1 !== null || variable1 !== undefined || variable1 !== '') &#123; let variable2 = variable1;&#125; Shorthand: 1const variable2 = variable1 || 'new'; 不要相信我，请先相信自己的测试（可以把下面的代码粘贴在es6console） 1234567let variable1;let variable2 = variable1 || '';console.log(variable2 === ''); // truevariable1 = 'foo';variable2 = variable1 || '';console.log(variable2); // foo 声明变量在函数中声明变量时，像下面这样同时声明多个变量可以节省你大量的时间和空间： Longhand: 123let x;let y;let x = 3; Shorthand: 1let x, y, z = 3; 如果存在这可能是微不足道的，但值得提及。做“如果检查”时，赋值操作符有时可以省略。 Longhand: 1if (likeJavaScript === true) Shorthand: 1if (likeJavaScript) 注：这两种方法并不完全相同，简写检查只要likeJavaScript是true都将通过。 这有另一个示例。如果a不是true，然后做什么。 Longhand: 1234let a;if (a !== true) &#123; // do something ...&#125; Shorthand: 1234let a;if (!a) &#123; // do something ...&#125; JavaScript的for循环如果你只想要原生的JavaScript，而不想依赖于jQuery或Lodash这样的外部库，那这个小技巧是非常有用的。 Longhand: 1for (let i = 0; i &lt; allImgs.length; i++) Shorthand: 1for (let index in allImgs) Array.forEach简写： 12345678910function logArrayElements(element, index, array) &#123; console.log('a[' + index + ']=' + element);&#125;[2, 5, 9].forEach(logArrayElements);// logs:// a[0] = 2// a[1] = 5// a[2] = 9 Short-circuit Evaluation如果参数是null或者是undefined，我们可以简单的使用一个Short-circuit逻辑运算，实现一行代码替代六行代码的写法。 Longhand: 123456let dbHost;if (process.env.DB_HOST) &#123; dbHost = process.env.DB_HOST;&#125; else &#123; dbHost = &apos;localhost&apos;;&#125; Shorthand: 1const dbHost = process.env.DB_HOST || &apos;localhost&apos;; 十进制指数你可能看过这个。它本质上是一个写数字的奇特写法，就是一个数字后面有很多个0。例如1e7本质相当于10000000（1的后面有7个0）。它代表了十进制计数等于10000000。 Longhand: 1for (let i = 0; i &lt; 10000; i++) &#123;&#125; Shorthand: 12345678for (let i = 0; i &lt; 1e7; i++) &#123;&#125;// All the below will evaluate to true1e0 === 1;1e1 === 10;1e2 === 100;1e3 === 1000;1e4 === 10000;1e5 === 100000; 对象属性定义对象文字（Object literals）让JavaScript变得更有趣。ES6提供了一个更简单的办法来分配对象的属性。如果属性名和值一样，你可以使用下面简写的方式。 Longhand: 1const obj = &#123;x: x, y: y&#125;; Shorthand: 1const obj = &#123;x, y&#125;; 箭头函数经典函数很容易读和写，但它们确实会变得有点冗长，特别是嵌套函数中调用其他函数时还会让你感到困惑。 Longhand: 1234567891011function sayHello(name) &#123; console.log('Hello', name);&#125;setTimeout(function() &#123; console.log('Loaded')&#125;, 2000);list.forEach(function(item)&#123; console.log(item)&#125;) Shorthand: 123sayHello = name =&gt; console.log('Hello', name);setTimeout(() =&gt; console.log('Loaded'), 2000);list.forEach(item =&gt; console.log(item)); 隐式返回return在函数中经常使用到的一个关键词，将返回函数的最终结果。箭头函数用一个语句将隐式的返回结果（函数必须省略{}，为了省略return关键词）。 如果返回一个多行语句（比如对象），有必要在函数体内使用()替代{}。这样可以确保代码是否作为一个单独的语句返回。 Longhand: 123function calcCircumference(diameter) &#123; return Math.PI * diameter&#125; Shorthand: 123calcCircumference = diameter =&gt; ( Math.PI * diameter;) 默认参数值你可以使用if语句来定义函数参数的默认值。在ES6中，可以在函数声明中定义默认值。 Longhand: 1234567function volume(l, w, h) &#123; if (w === undefined) w = 3; if (h === undefined) h = 4; return l * w * h;&#125; Shorthand: 12volume = (l, w = 3, h = 4) =&gt; (l * w * h);volume(2); // 24 Template Literals是不是厌倦了使用+来连接多个变量变成一个字符串？难道就没有一个更容易的方法吗？如果你能使用ES6，那么你是幸运的。在ES6中，你要做的是使用撇号和${}，并且把你的变量放在大括号内。 Longhand: 12const welcome = 'You have logged in as' + first + ' ' + last + '.';const db = 'http://' + host + ':' + port + '/' + database; Shorthand: 12const welcome = `You have logged in as $&#123;first&#125; $&#123;last&#125;`;const db = `http://$&#123;host&#125;:$&#123;port&#125;/$&#123;database&#125;`; Destructuring Assignment如果你正在使用任何一个流行的Web框架时，就有很多机会使用数组的形式或数据对象的形式与API之间传递信息。一旦数据对象达到一个对个组件时，你需要将其展开。 Longhand: 123456789const observable = require('mobx/observable');const action = require('mobx/action');const runInAction = require('mobx/runInAction');const store = this.props.store;const form = this.props.form;const loading = this.props.loading;const errors = this.props.errors;const entity = this.props.entity; Shorthand: 12import &#123;observable, action, runInAction&#125; from 'mobx';const &#123;store, form, loading, errors, entity&#125; = this.props; 你甚至可以自己指定变量名： 1const &#123;store, form, loading, errors, entity:contact&#125; = this.props; 多行字符串你会发现以前自己写多行字符串的代码会像下面这样： Longhand: 123456const lorem = 'Lorem ipsum dolor sit amet, consectetur\\n\\t' + 'adipisicing elit, sed do eiusmod tempor incididunt\\n\\t' + 'ut labore et dolore magna aliqua. Ut enim ad minim\\n\\t' + 'veniam, quis nostrud exercitation ullamco laboris\\n\\t' + 'nisi ut aliquip ex ea commodo consequat. Duis aute\\n\\t' + 'irure dolor in reprehenderit in voluptate velit esse.\\n\\t' 但还有一个更简单的方法。使用撇号。 Shorthand: 123456const lorem = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse.` Spread OperatorSpread Operator是ES6中引入的，使JavaScript代码更高效和有趣。它可以用来代替某些数组的功能。Spread Operator只是一个系列的三个点(...)。 Longhand: 1234567// Joining arraysconst odd = [1, 3, 5];const nums = [2, 4, 6].concat(odd);// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = arr.slice(); Shorthand: 12345678// Joining arraysconst odd = [1, 3, 5];const nums = [2, 4, 6, ...odd];console.log(nums); // [2, 4, 6, 1, 3, 5]// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = [...arr]; 不像concat()函数，使用Spread Operator你可以将一个数组插入到另一个数组的任何地方。 12const odd = [1, 3, 5];const nums = [2, ...odd, 4, 6]; 另外还可以当作解构符： 1234const &#123;a, b, ...z&#125; = &#123;a: 1, b: 2, c: 3, d: 4&#125;;console.log(a); // 1console.log(b); // 2console.log(z); // &#123;c: 3, d: 4&#125; 强制参数默认情况下，JavaScript如果不给函数参数传一个值的话，将会是一个undefined。有些语言也将抛出一个警告或错误。在执行参数赋值时，你可以使用if语句，如果未定义将会抛出一个错误，或者你可以使用强制参数（Mandatory parameter）。 Longhand: 123456function foo(bar) &#123; if (bar === undefined) &#123; throw new Error('Missing parameter!'); &#125; return bar;&#125; Shorthand: 1234567mandatory = () =&gt; &#123; throw new Error('Missing parameter!');&#125;foo = (bar = mandatory()) =&gt; &#123; return bar;&#125; Array.find如果你以前写过一个查找函数，你可能会使用一个for循环。在ES6中，你可以使用数组的一个新功能find()。 Longhand: 12345678910111213const pets = [ &#123;type: 'Dog', name: 'Max'&#125;, &#123;type: 'Cat', name: 'Karl'&#125;, &#123;type: 'Dog', name: 'Tommy'&#125;]function findDog(name) &#123; for (let i = 0; i &lt; pets.length; ++i) &#123; if (pets[i].type === 'Dog' &amp;&amp; pets[i].name === name) &#123; return pets[i]; &#125; &#125;&#125; Shorthand: 12pet = pets.find(pet =&gt; pet.type === 'Dog' &amp;&amp; pet.name === 'Tommy');console.log(pet); // &#123;type: 'Dog', name: 'Tommy'&#125; Object[key]你知道Foo.bar也可以写成Foo[bar]吧。起初，似乎没有理由应该这样写。然而，这个符号可以让你编写可重用代码块。 下面是一段简化后的函数的例子： 12345678function validate(values) &#123; if (!values.first) return false; if (!values.last) return false; return true;&#125;console.log(validate(&#123;first: 'Bruce', last: 'Wayne'&#125;)); // true 这个函数可以正常工作。然而，需要考虑一个这样的场景：有很多种形式需要应用验证，而且不同领域有不同规则。在运行时很难创建一个通用的验证功能。 Shorthand: 123456789101112131415161718192021222324// object validation rulesconst schema = &#123; first: &#123; required: true &#125;, last: &#123; required: true &#125;&#125;// universal validation functionconst validate = (schema, values) =&gt; &#123; for(field in schema) &#123; if (schema[field].required) &#123; if(!values[field]) &#123; return false; &#125; &#125; &#125; return true;&#125;console.log(validate(schema, &#123;first: 'Bruce'&#125;)); // falseconsole.log(validate(schema, &#123;first: 'Bruce', last: 'Wayne'&#125;)); // true 现在我们有一个验证函数，可以各种形式的重用，而不需要为每个不同的功能定制一个验证函数。 Double Bitwise NOT如果你是一位JavaScript新手的话，对于逐位运算符（Bitwise Operator）你应该永远不会在任何地方使用。此外，如果你不处理二进制0和1，那就更不会想使用。 然而，一个非常实用的用例，那就是双位操作符。你可以用它替代Math.floor()。Double Bitwise NOT运算符有很大的优势，它执行相同的操作要快得多。你可以在这里阅读更多关于位运算符相关的知识。 Longhand: 1Math.floor(4.9) === 4; // true Shorthand: 1~~4.9 === 4; //true","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"十九个小技巧","slug":"技术/JavaScript/十九个小技巧","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/十九个小技巧/"}],"tags":[{"name":"JavaScript十九个小技巧","slug":"JavaScript十九个小技巧","permalink":"https://www.kaige1220.top/tags/JavaScript十九个小技巧/"}]},{"title":"javascript函数式编程","slug":"js函数式编程","date":"2018-08-20T00:30:16.904Z","updated":"2018-08-20T00:36:43.077Z","comments":true,"path":"2018/08/20/js函数式编程/","link":"","permalink":"https://www.kaige1220.top/2018/08/20/js函数式编程/","excerpt":"","text":"用递归来做循环，而不是常见的for123456function sumRange(star,end,acc)&#123; if(star&gt;end)&#123; return acc &#125; return sumRange(star+1, end, acc + start)&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"函数式编程","slug":"技术/JavaScript/函数式编程","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/函数式编程/"}],"tags":[{"name":"JavaScript函数式编程","slug":"JavaScript函数式编程","permalink":"https://www.kaige1220.top/tags/JavaScript函数式编程/"}]},{"title":"javascript 算法练习等","slug":"js复习","date":"2018-08-20T00:30:13.284Z","updated":"2018-08-20T00:30:13.668Z","comments":true,"path":"2018/08/20/js复习/","link":"","permalink":"https://www.kaige1220.top/2018/08/20/js复习/","excerpt":"字符翻转用数组自带的函数搞定 123456function reverseString(str)&#123; return str.split(\"\").reverse().join(\"\");&#125;reverseString(\"hello\");","text":"字符翻转用数组自带的函数搞定 123456function reverseString(str)&#123; return str.split(\"\").reverse().join(\"\");&#125;reverseString(\"hello\"); 用for循环 123456789function reverseString(str)&#123; //创建一个新字符串用来保存翻转的 var newString = \"\"; for(var i = str.length-1; i&gt;=0; i--)&#123; newString += str[i]; &#125; return newString;&#125; ES6的方法： 1[...str].reverse().join(''); 二、 js的小技巧学习1 使用!!操作符转换布尔值 有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回true值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用!!variable做检测，只要变量的值为:0、null、&quot; &quot;、undefined或者NaN都将返回的是false，反之返回的是true。比如下面的示例： 1234567891011function Account(cash) &#123; this.cash = cash; this.hasMoney = !!cash;&#125;var account = new Account(100.50);console.log(account.cash); // 100.50console.log(account.hasMoney); // truevar emptyAccount = new Account(0);console.log(emptyAccount.cash); // 0console.log(emptyAccount.hasMoney); // false 在这个示例中，只要account.cash的值大于0，那么account.hasMoney返回的值就是true。 2 使用+将字符串转换成数字 这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例： 12345function toNumber(strNumber) &#123; return +strNumber;&#125;console.log(toNumber(\"1234\")); // 1234console.log(toNumber(\"ACB\")); // NaN 这个也适用于Date，在本例中，它将返回的是时间戳数字： 1console.log(+new Date()) // 1461288164385 3 并条件符 如果你有一段这样的代码： 123if (conected) &#123; login();&#125; 你也可以将变量简写，并且使用&amp;&amp;和函数连接在一起，比如上面的示例，可以简写成这样： 1conected &amp;&amp; login(); 如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示： 1user &amp;&amp; user.login(); 3 使用||运算符 在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用||操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为false，那么第二个值将会认为是一个默认值。如下面这个示例： 1234567891011function User(name, age) &#123; this.name = name || \"Oliver Queen\"; this.age = age || 27;&#125;var user1 = new User();console.log(user1.name); // Oliver Queenconsole.log(user1.age); // 27var user2 = new User(\"Barry Allen\", 25);console.log(user2.name); // Barry Allenconsole.log(user2.age); // 25 4 在循环中缓存array.length 这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组： 123for(var i = 0; i &lt; array.length; i++) &#123; console.log(array[i]);&#125; 如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存： 1234var length = array.length;for(var i = 0; i &lt; length; i++) &#123; console.log(array[i]);&#125; 你也可以写在这样： 123for(var i = 0, length = array.length; i &lt; length; i++) &#123; console.log(array[i]);&#125; 5 检测对象中属性 当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用document.querySelector()来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例： 12345if ('querySelector' in document) &#123; document.querySelector(\"#id\");&#125; else &#123; document.getElementById(\"id\");&#125; 在这个示例中，如果document不存在querySelector函数，那么就会调用docuemnt.getElementById(&quot;id&quot;)。 6 获取数组中最后一个元素 Array.prototype.slice(begin,end)用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如： 1234var array = [1,2,3,4,5,6];console.log(array.slice(-1)); // [6]console.log(array.slice(-2)); // [5,6]console.log(array.slice(-3)); // [4,5,6] 7 数组截断 这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例： 12345var array = [1,2,3,4,5,6];console.log(array.length); // 6array.length = 3;console.log(array.length); // 3console.log(array); // [1,2,3] 8 替换所有 String.replace()函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll()函数功能： 123var string = \"john john\";console.log(string.replace(/hn/, \"ana\")); // \"joana john\"console.log(string.replace(/hn/g, \"ana\")); // \"joana joana\" 9 合并数组 如果你要合并两个数组，一般情况之下你都会使用Array.concat()函数： 123var array1 = [1,2,3];var array2 = [4,5,6];console.log(array1.concat(array2)); // [1,2,3,4,5,6]; 然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用Array.pus().apply(arr1,arr2)来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用： 123var array1 = [1,2,3];var array2 = [4,5,6];console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6]; 10 将NodeList转换成数组 如果你运行document.querySelectorAll(“p”)函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort()、reduce()、map()、filter()等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用[].slice.call(elements)来实现： 123var elements = document.querySelectorAll(\"p\"); // NodeListvar arrayElements = [].slice.call(elements); // Now the NodeList is an arrayvar arrayElements = Array.from(elements); // This is another way of converting NodeList to Array 11 数组元素的洗牌 对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做： 12var list = [1,2,3];console.log(list.sort(function() &#123; Math.random() - 0.5 &#125;)); // [2,1,3] 三、 算法练习之 首字母大写 1、for + replace() 123456789101112131415function titleCase(str)&#123; //将字符串分解并转换为小写 var convertToArray = str.toLowerCase().split(\" \"); for(var i=0; i&lt; convertToArray.length; i++)&#123; //找到首字母 var char = convertToArray[i].charAt[0]; //使用replace()方法替换首字母为大写 convertTOArray[i] = convertToArray[i].replace(char,function(char)&#123; return char.toUpperCase(); &#125;); &#125; return convertToArray.join(\" \");&#125;titleCase(\"hello kaige\"); //\"Hello Kaige\" 2、 for in + replace() 1234567function titleCase(str)&#123; str = str.toLowerCase().split(' '); for(var i in str)&#123; str[i] = str[i].replace(str[i].charAt(0),str[i].charAt(0).toUpperCase()); &#125;; return str.join(' ');&#125; 四、使用js 截断字符串 1234567891011function truncateString (str, num) &#123; var truncd = ''; if (str.length &lt;= num) &#123; truncd = str; &#125; else if (num &lt;= 3) &#123; truncd = str.slice(0, num).trim() + '...'; &#125; else &#123; truncd = str.slice(0, num - 3).trim() + '...'; &#125; return truncd;&#125; 五、阶乘算法 12345678910function factorial(num)&#123; if(num&lt;0)&#123; return -1; &#125;else if(num ===0 || num===1)&#123; return 1; &#125;else&#123; return(num*factorial(((num-1)) &#125;&#125; 循环方法 1234567891011121314function factorial (num) &#123; var result = num; if (num &lt; 0) &#123; return -1; &#125; else if (num === 0 || num === 1) &#123; return 1; &#125; else &#123; while (num &gt; 1) &#123; num--; result *= num; &#125; &#125; return result;&#125; 12345678910111213function factorial (num) &#123; if (num &lt; 0) &#123; return -1; &#125; else if (num === 0 || num === 1) &#123; return 1; &#125; else &#123; for (var i = num - 1; i &gt;= 1; i--) &#123; num *= i; &#125; &#125; return num;&#125; 六、 js实现快速排序 采用分治法实现的 123456789101112131415161718192021222324var quicksort = function (arr)&#123; if(arr.length&lt;= 1)&#123; return arr; &#125; //选一个基准，然后设置两个空数组，小于基准的放左边，大于基准的放右边 var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i=0; i&lt; arr.length; i++)&#123; if(arr[i]&lt;pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; //递归操作及连接左右部分 return quicksort(left).concat(quicksort(right));&#125;;var array = [1,2,4,5,9,6,8,7];quicksort(array);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"算法练习","slug":"技术/JavaScript/算法练习","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/算法练习/"}],"tags":[{"name":"JavaScript 算法练习","slug":"JavaScript-算法练习","permalink":"https://www.kaige1220.top/tags/JavaScript-算法练习/"}]},{"title":"javascript操作样式","slug":"js操作样式","date":"2018-08-20T00:30:08.550Z","updated":"2018-08-20T00:30:09.696Z","comments":true,"path":"2018/08/20/js操作样式/","link":"","permalink":"https://www.kaige1220.top/2018/08/20/js操作样式/","excerpt":"","text":"在Web页面中元素的样式处理通常有两种方式 在HTML添加类名，然后在CSS样式文件中处理样式 通过JavaScript控制HTML元素的style属性，改变元素样式 虽然上面提到的方法都可以处理页面元素的样式，但CSS始终是最佳选择 —— 不仅对HTML如此，在JavaScript中也是如此。因为我们一直遵守的是：分离。 当然很多时候，只使用CSS的类方式并不一定能达到我们要的结果（也就是说类再也无法处理时），那么我们就必须使用JavaScript操作HTML元素中的style属性。 比如，如果我们要动态计算元素的坐标，并想通过JavaScript来设置，那么我们就可以像下面这样做： 12elem.style.left = leftelem.style.top = top getAttribute、setAttribute和removeAttribute等方法来读写或删除DOM元素的style属性。就上面的示例，咱们可以使用setAttribute()实现同样的效果，比如： 1234$0.setAttribute( 'style', 'background-color: orange; z-index: 9999; border-left-width: 5px;') HTMLElement.style.cssText1$0.style.cssText = 'color:#f36; font-size: 2rem;padding: 10px' 使用HTMLElement.style.cssText给元素的style添加值是要特别注意，如果元素的style属性一开始就有值，使用上面的方式添加值的话将会覆盖原有的属性值。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"操作样式","slug":"技术/JavaScript/操作样式","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/操作样式/"}],"tags":[{"name":"JavaScript操作样式","slug":"JavaScript操作样式","permalink":"https://www.kaige1220.top/tags/JavaScript操作样式/"}]},{"title":"股魔2","slug":"股魔总结","date":"2018-08-14T00:45:37.923Z","updated":"2018-08-16T10:48:40.580Z","comments":true,"path":"2018/08/14/股魔总结/","link":"","permalink":"https://www.kaige1220.top/2018/08/14/股魔总结/","excerpt":"","text":"总结： 我的买入点： 神奇线， vcp 缩量， 背柄形态产生。 一般从神奇线处买， 如果出现杯柄，并有了vcp缩量可以加仓。 一、时刻跟着计划走制定一个流程： 建仓机制如何处理风险如何锁定利润如何控制头寸大小 何时决定重新进行资产配置 应急预案: 如果头寸表现与预期不同，应该离场的点位止损离场后，重新买入股票的标准止盈离场的盈利目标 预期内行为：网球行为一般优秀的股票表现出网球的行为， 回撤事件短： 一般4-5天 甚至1-2周，之后股价反弹。超越前期高点。股票在回撤过程中会有个缩量的过程。 最好的股票一般都是反弹最快， 这样我们要持有事件更久。 跟随的数量股价在上涨的第一周和第二周，上涨的日子大于下跌的日子。 MVP法则M 代表动量 股票在15d内有12d上涨v 交易量 在15d 内，交易量增加了25%以上p 价格 股价在15d内， 涨幅增加了20以上 等待一个自然回调或一个新的基地形成。 如果没有像预期内一样发展1、 突破基底后，价格应始终保持在20日均线上方。 我会建仓一般，如果低于50日线，我会卖掉。 2、 股价连续三天下跌 当天没有收回振幅上半部分，卖掉。 3、 低交易量买入，高交易量卖出是个危险的信号。 突破后，不一定会继续突破，也可能出现深蹲， 这时，我们看看深蹲的量，以及当天价格处在20日线的什么位置来决定我们的持仓情况， 如果第二天或者后面几天出现了翻转修复，这就是个积极的信号了。 购买后只要没触及到你的止损线，尽量给股票一定的时间。 如果是牛市可以放长点时间。 优先考虑风险不是只有回报， 风险防范往往比回报重要。 不要专注于上涨空间，专注于下跌空间。 不要精神止损， 期待这股价回到某个位置再止损， 而是按照计划来实施。 波动较大的股票你可以放弃， 为啥一定要选择他呢！ 永远不要让风险超过预期收益 让失败成为一部分 关于止损说明： 市场环境不好的情况下： 1、收紧止损线 5-6%2、更早止盈 10%- 15% 3、头寸大小减少 使用卖半规则当你的股票获得的不菲的收益，你不值得是不是需要卖出，如果出现回撤，你可以尝试卖掉一半。 如果亏损的话，情况是不一样的，达到止损位置你需要立即卖完。 当股票市场领头羊到达顶点后，股价可能在经过一段时间的下跌后看起来比较便宜，但它实际上是很贵的，原因是未来的贴现。 如果股票的价格动作没有证实基本面，请远离！ 让成功产生复利而不是失败当交易顺利时可以逐步加强你的敞口，当你交易最好的时候你也将仓位放到最大，这就是你成功的步骤。 如果你的头寸经历亏损，那么你没理由加仓。 通常，拿1/4的仓位开始，在每胜利后我翻倍我的仓位。直到建仓完毕。 在我失败的时候我会降低仓位。 永远不要让好好的收益变成亏损一旦股票从我的购买价格上涨了一个体面的幅度后，我就要进入利润保护模式。 随着价格的上升，你的止损位也是要提高的。 跟着自己的节奏走报告期内不要持有该股票 不要被迫交易， 学会等待是非常重要的行为。 如何买入股票趋势模板 股价高于150日（30周）均线，和200日（40周）均线 150均线高于200均线 50日均线高于150均线 股价在50日均线上方 200日均线上涨了1个月左右 目前的股价在52周高点的25%内 rs 最好达到80-90 rs线上涨了至少6周。 波动收窄模式vcp期间，你通常会看到2-6次价格的一系列收缩。 技术足迹股票的足迹： 1、 时间 自基低开始经过的天数或周数 2、 价格 3、 对称性 在整改筑底过程中的收缩数量 第一次下跌幅度25% 第二次17% 第三次8% 这是它的收缩数量 三次收缩一般差不多了。 每一次收缩对应成交量变小！ vcp 发生在上升趋势中， 中枢点让市场的力量告诉你路该怎么走大部分积极的价格修正幅度在10%-35%； 成为赢家的股票都是那些不断创新高的股票； 关于持仓比例的问题以20万为例 12.5% 的比例一个标的的话 就是投入2.5万 你的止损点为10% 25% 的比例 就是投入5万， 你的止损点为5% 头寸永远不要超过50% 也就是10万 通常持有4到5个票最为稳妥。选择最好的。 不要太早的卖出领头羊股票 卖出的系统数基地， 第一个到第三个基地都是好的买入机会， 第五个到第六个就比较危险了。 产生巨额投资业绩的四个要素1、时机 2、不要过度分散投资 3、风险和收益的关系 4、控制下行风险 强势卖出，一般而言早卖比晚卖好 5、在大额交易前先进行小额交易 6、总是顺势交易 7、一旦有了不错的收益，保护你的盈亏平衡点","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"感悟","slug":"投资/感悟","permalink":"https://www.kaige1220.top/categories/投资/感悟/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"感悟","slug":"感悟","permalink":"https://www.kaige1220.top/tags/感悟/"}]},{"title":"投资语录","slug":"股市语录","date":"2018-08-09T01:17:18.852Z","updated":"2018-08-13T00:37:38.685Z","comments":true,"path":"2018/08/09/股市语录/","link":"","permalink":"https://www.kaige1220.top/2018/08/09/股市语录/","excerpt":"","text":"不要随大流； 低估和高成长的结合 或者其一； 市场情绪的观察； 不要有买入并侥幸潘涨的心里， 要有对应的措施。 要理解风险回报比； 记住要让股票再涨一会； 众人皆知的事情毫无价值； 信用平级没啥大用； 要有乐观精神； 耐心 性情的控制 至关重要； 11. 行动是盈利的敌人； 选择周线图： 当所有人都不抱希望时买入； 不要立即买入你中意的股票，等待时机买入； 逆人性； 买卖时机的把握真的很重要！ 选择超级强势股的原则：a. 你要确定潜在的目标价格；b. 低风险买入点；c. 控制好你的仓位 选择的原则： a. 强劲的底部突破；b. 向上突破30周移动平均线；c. 周成交量放大d. 陡峭的上攻e. 不要出现剧烈的波动 基本面分析的原则 高额收益 每股收益比收入重要的多； 收益是可持续的么？ 公司最近是否发布了新产品或增设了新产品线，重要的是你要搜集信息来佐证收益是否可持续。 低于10倍的年华市盈率 业绩的持续改善 漂亮的每股收益对比 内部人士回购 行事保守的管理团队， 行事低调。 简明深刻的财务报告 市场垄断地位 流通股较少 买入法则 如果在一只股票的上升阶段买入，那么股价有可能走高，也有可能掉头向下。概率为1：1； 但如果在股价回调之后的爬升阶段买入，胜算的机会就会加大！ 坚实的底部支撑 横盘够长！ 神奇支撑线 多数情况位于 10周移动均线 附近 ，估计轻触神奇支撑线后的几周内。 缓慢收紧 关于神奇支撑线： 可以通过改变周线来寻找！ 股价成交量缩小，股价窄幅震荡时买入 在持续数周的筑底期末端， 会在一个非常窄的区间内运行。 最理想的状态是成交量降至峰值的30% 到 50%； 在股价上涨的早期买入 等到巨额盈利公告公布的2-3周后再介入 在BCD形态买入 股票连续创三次新低时， 50日均线 10日周线 在下方或者在上面持续不要超过15天，所以先建立部分头寸，然后如果保持强劲就加仓。 陡峭的上攻角度 向上突破30周移动平均线 总结:放量升高（突破过程中放量多少？）—–回撤—–形成杯柄—-成交量缩小—-到达神奇支撑线（神奇支撑线追上股价）——–买入卖出法则技术性卖出指标 在正确的时间主动抛售，而不是在错误的时间被迫离场。 大幅度脱离神奇线（最常见的是10周线） 股价脱离底部9个月左右 股价第四次突破神奇线 股价出现剧烈波动时 高点跳空 股价到达止损位置 股价连创三次新高时卖掉股票 同类股走弱 基本面卖出指标 二次发行或公开配售 股票拆分 内部人士卖出 公司消息上头条时 公司宣布扩张 当你感觉成了投资天才时 市场充斥着盲目乐观的收益预期 超级强势股的构成要素 可持续的盈利报告， 漂亮的每股收益 巨额周成交量让股价向上突破坚实的底部 站上30周移动平均线 股价在90元以下， 市盈率在10倍以内 低流通性和保守的管理团队（低调的管理团队） 买入时机 神奇支撑线处买入； 失败教训总结 不要买入热门股，不要投资不了解的股票 不要追涨 ，之道在合适的位置进入 上涨的股票不要加仓了，了解位置很重要，有时候你以为是高点，其实是起点，相对位置，和绝对位置的利用。 化繁为简，不要过度交易！ 坚定持有你的大牛股 除非有明显的卖出信号（和第四点过度交易一样） 最重要的事情是学会如何卖出 不要失去纪律 就算暂时的失败，不要报复性投资！ 人人皆知的消息是没有价值的，人人都做的事情是毫无意义的，你必须要独立判断。 恐惧不是卖出的信号！ 每一笔投资必须是经过深思熟虑的，各种对策都在你的掌控中才是一笔成功投资！ 成功的投资之道 卖出比买入更重要 关注周线图 周线图处于横盘期时是比较好的买点 买入延神奇支撑线展开的股票 成交量减少，股价与神奇支撑线重合是好的买点 不要急于买入你看好的标的，要等待，等待非常关键！ 做一名波段交易者 几周—-几月 如果是超级大牛股甚至持有一年多！ 在别人恐惧的时候买入，学会控制自己的情绪 不要让别人影响你的投资决策！ 只投资你了解的股票，不要过度分化 上涨过程中不要加仓，所以在合适的位置仓位一定是放大的。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"感悟","slug":"投资/感悟","permalink":"https://www.kaige1220.top/categories/投资/感悟/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"感悟","slug":"感悟","permalink":"https://www.kaige1220.top/tags/感悟/"}]},{"title":"投资语录","slug":"股市投资的机会","date":"2018-08-07T02:53:23.485Z","updated":"2018-08-07T05:12:45.009Z","comments":true,"path":"2018/08/07/股市投资的机会/","link":"","permalink":"https://www.kaige1220.top/2018/08/07/股市投资的机会/","excerpt":"","text":"投资向来是反人性的，在这个时点，如果不懂公司可以配置些ETF，大概率在两年内能有一个不错的收成，可惜人一个是恐惧，一个是等不及，所以成功注定是和大多数人无缘的。 记录于2008年8月7日，过两年回过头来验证今天说过的话！","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"感悟","slug":"投资/感悟","permalink":"https://www.kaige1220.top/categories/投资/感悟/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"感悟","slug":"感悟","permalink":"https://www.kaige1220.top/tags/感悟/"}]},{"title":"node server","slug":"node学习之server","date":"2018-07-30T02:49:34.643Z","updated":"2018-07-30T02:56:03.343Z","comments":true,"path":"2018/07/30/node学习之server/","link":"","permalink":"https://www.kaige1220.top/2018/07/30/node学习之server/","excerpt":"创建server12345678var http = require('http');var requestListener = function(req,res)&#123; res.end('ok');&#125;;var server = http.createServer(requestListenner);server.listen(3000);","text":"创建server12345678var http = require('http');var requestListener = function(req,res)&#123; res.end('ok');&#125;;var server = http.createServer(requestListenner);server.listen(3000); 获取请求方信息HTTP版本、HTTP method、headers、url1234567891011var http = require('http');var server = http.createServer(function(req, res)&#123; console.log('客户端请求url：' + req.url); console.log('http版本：' + req.httpVersion); console.log('http请求方法：' + req.method); res.end('ok');&#125;);server.listen(3000); 获取get请求参数123456789101112131415var http = require('http');var url = require('url');var querystring = require('querystring');var server = http.createServer(function(req, res)&#123; var urlObj = url.parse(req.url); var query = urlObj.query; var queryObj = querystring.parse(query); console.log( JSON.stringify(queryObj) ); res.end('ok');&#125;);server.listen(3000); 获取post请求参数代码如下 123456789101112131415161718var http = require('http');var url = require('url');var querystring = require('querystring');var server = http.createServer(function(req, res)&#123; var body = ''; req.on('data', function(thunk)&#123; body += thunk; &#125;); req.on('end', function()&#123; console.log( 'post body is: ' + body ); res.end('ok'); &#125;); &#125;);server.listen(3000);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"https://www.kaige1220.top/categories/技术/node-js/"},{"name":"server","slug":"技术/node-js/server","permalink":"https://www.kaige1220.top/categories/技术/node-js/server/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.kaige1220.top/tags/node-js/"},{"name":"server","slug":"server","permalink":"https://www.kaige1220.top/tags/server/"}]},{"title":"node http.client","slug":"node学习之http.client","date":"2018-07-27T12:05:32.187Z","updated":"2018-07-27T12:14:09.150Z","comments":true,"path":"2018/07/27/node学习之http.client/","link":"","permalink":"https://www.kaige1220.top/2018/07/27/node学习之http.client/","excerpt":"ClientRequest概览当你调用 http.request(options) 时，会返回 ClientRequest实例，主要用来创建HTTP客户端请求。","text":"ClientRequest概览当你调用 http.request(options) 时，会返回 ClientRequest实例，主要用来创建HTTP客户端请求。 简单的GET请求下面构造了个GET请求，访问 http://id.qq.com/ ，并将返回的网页内容打印在控制台下。 123456789101112var http = require('http');http.get('http://id.qq.com/', function(res)&#123; var data = ''; res.setEncoding('utf8'); res.on('data', function(chunk)&#123; data += chunk; &#125;); res.on('end', function()&#123; console.log(data); &#125;);&#125;); 简单的post请求在下面例子中，首先创建了个http server，负责将客户端发送过来的数据回传。 接着，创建客户端POST请求，向服务端发送数据。需要注意的点有： method 指定为 POST。 headers 里声明了 content-type 为 application/x-www-form-urlencoded。 数据发送前，用 querystring.stringify(obj) 对传输的对象进行了格式化。 123456789101112131415161718192021222324252627282930313233343536373839var http = require('http');var querystring = require('querystring');var createClientPostRequest = function()&#123; var options = &#123; method: 'POST', protocol: 'http:', hostname: '127.0.0.1', port: '3000', path: '/post', headers: &#123; \"connection\": \"keep-alive\", \"content-type\": \"application/x-www-form-urlencoded\" &#125; &#125;; // 发送给服务端的数据 var postBody = &#123; nick: 'chyingp' &#125;; // 创建客户端请求 var client = http.request(options, function(res)&#123; // 最终输出：Server got client data: nick=chyingp res.pipe(process.stdout); &#125;); // 发送的报文主体，记得先用 querystring.stringify() 处理下 client.write( querystring.stringify(postBody) ); client.end();&#125;;// 服务端程序，只是负责回传客户端数据var server = http.createServer(function(req, res)&#123; res.write('Server got client data: '); req.pipe(res);&#125;);server.listen(3000, createClientPostRequest);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"https://www.kaige1220.top/categories/技术/node-js/"},{"name":"http.client","slug":"技术/node-js/http-client","permalink":"https://www.kaige1220.top/categories/技术/node-js/http-client/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.kaige1220.top/tags/node-js/"},{"name":"http.client","slug":"http-client","permalink":"https://www.kaige1220.top/tags/http-client/"}]},{"title":"node http-res","slug":"node学习之http-res","date":"2018-07-27T08:05:17.648Z","updated":"2018-07-27T12:00:04.896Z","comments":true,"path":"2018/07/27/node学习之http-res/","link":"","permalink":"https://www.kaige1220.top/2018/07/27/node学习之http-res/","excerpt":"概述http模块四剑客之一的res，应该都不陌生了。一个web服务程序，接受到来自客户端的http请求后，向客户端返回正确的响应内容，这就是res的职责。","text":"概述http模块四剑客之一的res，应该都不陌生了。一个web服务程序，接受到来自客户端的http请求后，向客户端返回正确的响应内容，这就是res的职责。 返回的内容包括：状态代码/状态描述信息、响应头部、响应主体。下文会举几个简单的例子。 12345var http = require('http');var server = http.createServer(function(req, res)&#123; res.send('ok');&#125;);server.listen(3000); 例子在下面的例子中，我们同时设置了 状态代码/状态描述信息、响应头部、响应主体，就是这么简单。 1234567891011var http = require('http');// 设置状态码、状态描述信息、响应主体var server = http.createServer(function(req, res)&#123; res.writeHead(200, 'ok', &#123; 'Content-Type': 'text/plain' &#125;); res.end('hello');&#125;);server.listen(3000); 设置状态代码、状态描述信息res提供了 res.writeHead()、res.statusCode/res.statusMessage 来实现这个目的。 举例，如果想要设置 200/ok ，可以 1res.writeHead(200, 'ok'); 也可以12res.statusCode = 200;res.statusMessage = 'ok'; 设置响应头部res提供了 res.writeHead()、response.setHeader() 来实现响应头部的设置。 举例，比如想把 Content-Type 设置为 text-plain，那么可以 1234567// 方法一res.writeHead(200, 'ok', &#123; 'Content-Type': 'text-plain'&#125;);// 方法二res.setHeader('Content-Type', 'text-plain'); 两者的差异点在哪里呢？ res.writeHead() 不单单是设置header。 已经通过 res.setHeader() 设置了header，当通过 res.writeHead() 设置同名header，res.writeHead() 的设置会覆盖之前的设置。 其他响应头部操作增、删、改、查 是配套的。下面分别举例说明下，例子太简单就直接上代码了。 123456789101112// 增res.setHeader('Content-Type', 'text/plain');// 删res.removeHeader('Content-Type');// 改res.setHeader('Content-Type', 'text/plain');res.setHeader('Content-Type', 'text/html'); // 覆盖// 查res.getHeader('content-type'); 设置响应主体主要用到 res.write() 以及 res.end() 两个方法。 res.write() API的信息量略大，建议看下官方文档。 response.write(chunk[, encoding][, callback])chunk：响应主体的内容，可以是string，也可以是buffer。当为string时，encoding参数用来指明编码方式。（默认是utf8）encoding：编码方式，默认是 utf8。callback：当响应体flushed时触发。（TODO 这里想下更好的解释。。。） 使用上没什么难度，只是有些注意事项： 如果 res.write() 被调用时， res.writeHead() 还没被调用过，那么，就会把header flush出去。 res.write() 可以被调用多次。 当 res.write(chunk) 第一次被调用时，node 会将 header 信息 以及 chunk 发送到客户端。第二次调用 res.write(chunk) ，node 会认为你是要streaming data（WTF，该怎么翻译）。。。 response.end([data][, encoding][, callback])掌握了 res.write() 的话，res.end() 就很简单了。res.end() 的用处是告诉nodejs，header、body都给你了，这次响应就到这里吧。 有点像个语法糖，可以看成下面两个调用的组合。至于callback，当响应传递结束后触发。 12res.write(data, encoding);res.end() chunk数据如果是 text/html 123456789101112var http = require('http');http.createServer(function(req, res) &#123; res.setHeader('Content-Type', 'text/html; charset=utf-8'); res.write('hello'); setTimeout(function() &#123; res.write(' world!'); res.end(); &#125;, 2000);&#125;).listen(3000); 如果是 text/plain 123456789101112131415var http = require('http');http.createServer(function (req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain; charset=utf-8', 'X-Content-Type-Options': 'nosniff' &#125;); res.write('hello'); setTimeout(function()&#123; res.write('world'); res.end() &#125;, 2000); &#125;).listen(3000);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"https://www.kaige1220.top/categories/技术/node-js/"},{"name":"http-res","slug":"技术/node-js/http-res","permalink":"https://www.kaige1220.top/categories/技术/node-js/http-res/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.kaige1220.top/tags/node-js/"},{"name":"http-res","slug":"http-res","permalink":"https://www.kaige1220.top/tags/http-res/"}]},{"title":"node http-req","slug":"node学习之http-req","date":"2018-07-27T07:31:19.134Z","updated":"2018-07-27T08:05:59.962Z","comments":true,"path":"2018/07/27/node学习之http-req/","link":"","permalink":"https://www.kaige1220.top/2018/07/27/node学习之http-req/","excerpt":"服务端例子： 12345678var http = require('http');var server = http.createServer(function(requ,res)&#123; console.log(requ.headers); res.end('ok')&#125;);server.listen(3000);","text":"服务端例子： 12345678var http = require('http');var server = http.createServer(function(requ,res)&#123; console.log(requ.headers); res.end('ok')&#125;);server.listen(3000); 客户端例子： 12345var http = require('http');http.get('http://127.0.0.1:3000',function(res)&#123; console.log(res.statusCode);&#125;) 服务端的例子例子一：获取httpVersion/method/url下面是一个典型的HTTP请求报文，里面最重要的内容包括：HTTP版本、请求方法、请求地址、请求头部。1234GET /hello HTTP/1.1Host: 127.0.0.1:3000Connection: keep-aliveCache-Control: no-cache 那么，如何获取上面提到的信息呢？很简单，直接上代码 12345678910111213// getClientInfo.jsvar http = require('http');var server = http.createServer(function(req, res)&#123; console.log( '1、客户端请求url：' + req.url ); console.log( '2、http版本：' + req.httpVersion ); console.log( '3、http请求方法：' + req.method ); console.log( '4、http请求头部' + JSON.stringify(req.headers) ); res.end('ok');&#125;);server.listen(3000); 例子二：获取get请求参数服务端代码如下： 12345678910111213141516// getClientGetQuery.jsvar http = require('http');var url = require('url');var querystring = require('querystring');var server = http.createServer(function(req, res)&#123; var urlObj = url.parse(req.url); var query = urlObj.query; var queryObj = querystring.parse(query); console.log( JSON.stringify(queryObj) ); res.end('ok');&#125;);server.listen(3000); 例子三：获取post请求参数服务端代码如下 12345678910111213141516171819// getClientPostBody.jsvar http = require('http');var url = require('url');var querystring = require('querystring');var server = http.createServer(function(req, res)&#123; var body = ''; req.on('data', function(thunk)&#123; body += thunk; &#125;); req.on('end', function()&#123; console.log( 'post body is: ' + body ); res.end('ok'); &#125;); &#125;);server.listen(3000); 通过curl构造post请求： curl -d ‘nick=casper&amp;hello=world’ http://127.0.0.1:3000 服务端打印如下： post body is: nick=casper&amp;hello=world 客户端处例子例子一：获取httpVersion/statusCode/statusMessage代码如下： 123456789101112131415var http = require('http');var server = http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'content-type': 'text/plain',&#125;); res.end('from server');&#125;);server.listen(3000);var client = http.get('http://127.0.0.1:3000', function(res)&#123; console.log('1、http版本：' + res.httpVersion); console.log('2、返回状态码：' + res.statusCode); console.log('3、返回状态描述信息：' + res.statusMessage); console.log('4、返回正文：'); res.pipe(process.stdout);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"https://www.kaige1220.top/categories/技术/node-js/"},{"name":"http-req","slug":"技术/node-js/http-req","permalink":"https://www.kaige1220.top/categories/技术/node-js/http-req/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.kaige1220.top/tags/node-js/"},{"name":"http-req","slug":"http-req","permalink":"https://www.kaige1220.top/tags/http-req/"}]},{"title":"node 域名解析","slug":"node学习之域名解析","date":"2018-07-27T06:52:07.235Z","updated":"2018-07-27T11:59:34.388Z","comments":true,"path":"2018/07/27/node学习之域名解析/","link":"","permalink":"https://www.kaige1220.top/2018/07/27/node学习之域名解析/","excerpt":"域名解析：dns.lookup()比如我们要查询域名 www.qq.com 对应的ip，可以通过 dns.lookup() 123456var dns = require('dns');dns.lookup('www.qq.com', function(err, address, family)&#123; if(err) throw err; console.log('例子A: ' + address);&#125;);","text":"域名解析：dns.lookup()比如我们要查询域名 www.qq.com 对应的ip，可以通过 dns.lookup() 123456var dns = require('dns');dns.lookup('www.qq.com', function(err, address, family)&#123; if(err) throw err; console.log('例子A: ' + address);&#125;); 我们知道，同一个域名，可能对应多个不同的ip。那么，如何获取一个域名对应的多个ip呢？可以这样。 1234567var dns = require('dns');var options = &#123;all: true&#125;;dns.lookup('www.qq.com', options, function(err, address, family)&#123; if(err) throw err; console.log('例子B: ' + address);&#125;); 域名解析：dns.resolve4()上文的例子，也可以通过 dns.resolve4() 来实现。 123456var dns = require('dns');dns.resolve4('id.qq.com', function(err, address)&#123; if(err) throw err; console.log( JSON.stringify(address) );&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"https://www.kaige1220.top/categories/技术/node-js/"},{"name":"域名解析","slug":"技术/node-js/域名解析","permalink":"https://www.kaige1220.top/categories/技术/node-js/域名解析/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.kaige1220.top/tags/node-js/"},{"name":"域名解析","slug":"域名解析","permalink":"https://www.kaige1220.top/tags/域名解析/"}]},{"title":"node 文件读取","slug":"node学习之文件读取","date":"2018-07-27T05:33:51.387Z","updated":"2018-07-27T06:52:22.302Z","comments":true,"path":"2018/07/27/node学习之文件读取/","link":"","permalink":"https://www.kaige1220.top/2018/07/27/node学习之文件读取/","excerpt":"文件读取普通读取同步读取 123456789var fs = require('fs');var data;ty&#123; dat = fs.redFileSync('./fileForRead.txt','utf8'); console.log('文件内容：' + data);&#125;catch(err)&#123; console.error('读取文件出错' + err.message)&#125;","text":"文件读取普通读取同步读取 123456789var fs = require('fs');var data;ty&#123; dat = fs.redFileSync('./fileForRead.txt','utf8'); console.log('文件内容：' + data);&#125;catch(err)&#123; console.error('读取文件出错' + err.message)&#125; 异步读取12345678var fs = require('fs');fs.readFile('./fileForRead.txt', 'utf8', function(err,data)&#123; if(err)&#123; return console.error('读取文件出错：' + err.message); &#125; console.log('文件内容：' + data);&#125;) 通过文件流读取适合读取大文件 12345678910111213141516var fs = require('fs');var readStream = fs.createReadStream('./fileForRead.txt', 'utf8');readStream .on('data', function(chunk) &#123; console.log('读取数据: ' + chunk); &#125;) .on('error', function(err)&#123; console.log('出错: ' + err.message); &#125;) .on('end', function()&#123; // 没有数据了 console.log('没有数据了'); &#125;) .on('close', function()&#123; // 已经关闭，不会再有事件抛出 console.log('已经关闭'); &#125;); 文件写入 以下代码，如果文件不存在，则创建文件；如果文件存在，则覆盖文件内容； 异步写入123456var fs = require('fs');fs.writeFile('./fileForWrite.txt', 'hello world', 'utf8', function(err)&#123; if(err) throw err; console.log('文件写入成功');&#125;); 同步写入12345678var fs = require('fs');try&#123; fs.writeFileSync('./fileForWrite1.txt', 'hello world', 'utf8'); console.log('文件写入成功');&#125;catch(err)&#123; throw err;&#125; 通过文件流写入1234567891011var fs = require('fs');var writeStream = fs.createWriteStream('./fileForWrite1.txt', 'utf8');writeStream .on('close', function()&#123; // 已经关闭，不会再有事件抛出 console.log('已经关闭'); &#125;);writeStream.write('hello');writeStream.write('world');writeStream.end(''); 相对底层的接口fd：写入的文件句柄。buffer：写入的内容。offset：将buffer从offset位置开始，长度为length的内容写入。length：写入的buffer内容的长度。position：从打开文件的position处写入。callback：参数为 (err, written, buffer)。written表示有xx字节的buffer被写入。 文件是否存在fs.exists()已经是deprecated状态，现在可以通过下面代码判断文件是否存在。 1234567891011var fs = require('fs');fs.access('./fileForRead.txt', function(err)&#123; if(err) throw err; console.log('fileForRead.txt存在');&#125;);fs.access('./fileForRead2.txt', function(err)&#123; if(err) throw err; console.log('fileForRead2.txt存在');&#125;); 创建目录异步版本（如果目录已存在，会报错）123456var fs = require('fs');fs.mkdir('./hello', function(err)&#123; if(err) throw err; console.log('目录创建成功');&#125;); 同步版本123var fs = require('fs');fs.mkdirSync('./hello'); 删除文件123456var fs = require('fs');fs.unlink('./fileForUnlink.txt', function(err)&#123; if(err) throw err; console.log('文件删除成功');&#125;); 123var fs = require('fs');fs.unlinkSync('./fileForUnlink.txt'); 遍历目录同步版本，注意：fs.readdirSync()只会读一层，所以需要判断文件类型是否目录，如果是，则进行递归遍历。 12345678910111213141516171819202122232425262728// fs.readdirSync(path[, options])var fs = require('fs');var path = require('path');var getFilesInDir = function(dir)&#123; var results = [ path.resolve(dir) ]; var files = fs.readdirSync(dir, 'utf8'); files.forEach(function(file)&#123; file = path.resolve(dir, file); var stats = fs.statSync(file); if(stats.isFile())&#123; results.push(file); &#125;else if(stats.isDirectory())&#123; results = results.concat( getFilesInDir(file) ); &#125; &#125;); return results;&#125;;var files = getFilesInDir('../');console.log(files); 文件重命名1234567// fs.rename(oldPath, newPath, callback)var fs = require('fs');fs.rename('./hello', './world', function(err)&#123; if(err) throw err; console.log('重命名成功');&#125;); 监听文件修改fs.watchFile()实现原理：轮询。每隔一段时间检查文件是否发生变化。所以在不同平台上表现基本是一致的。 123456789101112var fs = require('fs');var options = &#123; persistent: true, // 默认就是true interval: 2000 // 多久检查一次&#125;;// curr, prev 是被监听文件的状态, fs.Stat实例// 可以通过 fs.unwatch() 移除监听fs.watchFile('./fileForWatch.txt', options, function(curr, prev)&#123; console.log('修改时间为: ' + curr.mtime);&#125;); 修改所有者修改权限可以用fs.chmod()，也可以用fs.fchmod()。两者的区别在于，前面传的是文件路径，后面传的的文件句柄。 fs.chmod)、fs.fchmod()区别：传的是文件路径，还是文件句柄。 fs.chmod()、fs.lchmod()区别：如果文件是软连接，那么fs.chmod()修改的是软连接指向的目标文件；fs.lchmod()修改的是软连接。 123456var fs = require('fs');fs.chmod('./fileForChown.txt', '777', function(err)&#123; if(err) console.log(err); console.log('权限修改成功');&#125;); 获取文件状态区别： fs.stat() vs fs.fstat()：传文件路径 vs 文件句柄。 fs.stat() vs fs.lstat()：如果文件是软链接，那么fs.stat()返回目标文件的状态，fs.lstat()返回软链接本身的状态。 主要关注Class: fs.Stats。首先是方法 stats.isFile() – 是否文件 stats.isDirectory() – 是否目录 stats.isBlockDevice() – 什么鬼 stats.isCharacterDevice() – 什么鬼 stats.isSymbolicLink() (only valid with fs.lstat()) – 什么鬼 stats.isFIFO() – 什么鬼 stats.isSocket() – 是不是socket文件 123456789101112 var fs = require('fs');var getTimeDesc = function(d)&#123; return [d.getFullYear(), d.getMonth()+1, d.getDate()].join('-') + ' ' + [d.getHours(), d.getMinutes(), d.getSeconds()].join(':');&#125;;fs.stat('./fileForStat.txt', function(err, stats)&#123; console.log('文件大小: ' + stats.size); console.log('创建时间: ' + getTimeDesc(stats.birthtime)); console.log('访问时间: ' + getTimeDesc(stats.atime)); console.log('修改时间: ' + getTimeDesc(stats.mtime));&#125;); 访问/权限检测1234567// fs.access(path[, mode], callback)var fs = require('fs');fs.access('./fileForAccess.txt', function(err)&#123; if(err) throw err; console.log('可以访问');&#125;); 文件内容截取要点： offset不会变化。比如通过fs.read()读取文件内容，就需要特别注意。 如果len小于文件内容长度，剩余文件内容部分会丢失；如果len大于文件内容长度，那么超出的部分，会用\\0进行填充。 如果传的是文件路径，需要确保文件是可写的；如果传的是文件句柄，需要确保文件句柄已经打开并且可写入。 删除目录123456var fs = require('fs');fs.rmdir('./dirForRemove', function(err)&#123; if(err) throw err; console.log('目录删除成功');&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"https://www.kaige1220.top/categories/技术/node-js/"},{"name":"文件读取","slug":"技术/node-js/文件读取","permalink":"https://www.kaige1220.top/categories/技术/node-js/文件读取/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.kaige1220.top/tags/node-js/"},{"name":"文件读取","slug":"文件读取","permalink":"https://www.kaige1220.top/tags/文件读取/"}]},{"title":"HTTP笔记实录6","slug":"http笔记实录6","date":"2018-07-25T13:43:16.515Z","updated":"2018-07-25T13:43:16.724Z","comments":true,"path":"2018/07/25/http笔记实录6/","link":"","permalink":"https://www.kaige1220.top/2018/07/25/http笔记实录6/","excerpt":"第 6 章 HTTP 首部6.1 HTTP 报文首部HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。对于客户端户来说，这些信息中的大部分内容都无须亲自查看。报文首部由几个字段构成。","text":"第 6 章 HTTP 首部6.1 HTTP 报文首部HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。对于客户端户来说，这些信息中的大部分内容都无须亲自查看。报文首部由几个字段构成。 HTTP 请求报文在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。 HTTP 响应报文在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、 HTTP 首部字段 3 部分构成。 6.2 HTTP 首部字段6.2.1 HTTP 首部字段传递重要信息HTTP 首部字段是构成 HTTP 报文的要素之一。在客户端与服务器之 间以 HTTP 协议进行通信的过程中，无论是请求还是响应都会使用首 部字段，它能起到传递额外重要信息的作用。 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的 语言、认证信息等内容。 6.2.2 HTTP 首部字段结构HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分 隔。 Content-Type: text/html 6.2.3 4 种 HTTP 首部字段类型HTTP 首部字段根据实际用途被分为以下 4 种类型。 通用首部字段（General Header Fields） 请求报文和响应报文两方都会使用的首部。 请求首部字段（Request Header Fields） 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加 内容、客户端信息、响应内容相关优先级等信息。 响应首部字段（Response Header Fields） 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加 内容，也会要求客户端附加额外的内容信息。 实体首部字段（Entity Header Fields） 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更 新时间等与实体有关的信息。 6.2.4 HTTP/1.1 首部字段一览 请求首部字段 6.3 HTTP/1.1 通用首部字段通用首部字段是指，请求报文和响应报文双方都会使用的首部。 6.3.1 Cache-Control通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机 制。 指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 CacheControl 的指令可用于请求及响应时。 Cache-Control: private, max-age=0, no-cache 表示是否能缓存的指令 public 指令 Cache-Control: public 当指定使用 public 指令时，则明确表明其他用户也可利用缓存。 private 指令 Cache-Control: private 当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。 缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送 过来的请求，代理服务器则不会返回缓存。 no-cache 指令https://ws1.sinaimg.cn/large/006c6oKBgy1ftl9tzf3bzj30jh09kmzu.jpg Cache-Control: no-cache 使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接 收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发 给源服务器。 如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对 资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资 源有效性进行确认，且禁止其对响应资源进行缓存操作。 Cache-Control: no-cache=Location 由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首 部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首 部字段可以使用缓存。只能在响应指令中指定该参数。 控制可执行缓存的对象的指令 no-store 指令 Cache-Control: no-store 当使用 no-store 指令机密信息时，暗示请求（和对应的响应）或响应中包含机密信息。 从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓 存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-notserve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存。 指定缓存期限和认证的指令 s-maxage 指令 Cache-Control: s-maxage=604800（单位 ：秒） s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 smaxage 指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。 当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓 存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。 另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。 当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。 max-stale 指令 Cache-Control: max-stale=3600（单位：秒） 使用 max-stale 可指示缓存资源，即使过期也照常接收。 如果指令未指定参数值，那么无论经过多久，客户端都会接收响应； 如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。 only-if-cached 指令 Cache-Control: only-if-cached 使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资 源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新 加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本 地缓存无响应，则返回状态码 504 Gateway Timeout。 must-revalidate 指令 Cache-Control: must-revalidate 使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响 应缓存目前是否仍然有效。 若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端 一条 504（Gateway Timeout）状态码。 另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已 经在首部使用了 max-stale，也不会再有效果）。 proxy-revalidate 指令 Cache-Control: proxy-revalidate proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性。 no-transform 指令 Cache-Control: no-transform 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改 变实体主体的媒体类型。 这样做可防止缓存或代理压缩图片等类似操作。 6.3.2 ConnectionConnection 首部字段具备如下两个作用。 控制不再转发给代理的首部字段 管理持久连接 Connection: 不再转发的首部字段名 在客户端发送请求和服务器返回响应内，使用 Connection 首部字 段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首 部）。 Connection: close HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持 久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。 Connection: Keep-Alive HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为 此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。 6.3.3 Date首部字段 Date 表明创建 HTTP 报文的日期和时间。 6.3.4 PragmaPragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。 规范定义的形式唯一，如下所示。 Pragma: no-cache 该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户 端会要求所有的中间服务器不返回缓存的资源。 所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 CacheControl: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握 全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的 请求会同时含有下面两个首部字段。 Cache-Control: no-cache Pragma: no-cache 6.3.5 Trailer首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP/1.1 版本分块传输编码时。 6.3.6 Transfer-Encoding首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。 6.3.7 Upgrade首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议。 上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两 个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。 Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务 器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 Connection:Upgrade。 对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。 6.3.8 Via使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文 的传输路径。 报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信 息，然后再进行转发。这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。 首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。 所以必须在经过代理时附加该首部字段内容。 6.3.9 WarningHTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演 变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。 Warning: 113 gw.hackr.jp:8080 “Heuristic expiration” Tue, 03 Jul 2012 Warning 首部的格式如下。最后的日期时间部分可省略。 Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间]) HTTP/1.1 中定义了 7 种警告。警告码对应的警告内容仅推荐参考。 另外，警告码具备扩展性，今后有可能追加新的警告码。 6.4 请求首部字段&lt;待续&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"https://www.kaige1220.top/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.kaige1220.top/tags/HTTP/"}]},{"title":"一种hover效果","slug":"一种悬浮hover","date":"2018-07-25T13:43:07.009Z","updated":"2018-07-25T13:43:07.419Z","comments":true,"path":"2018/07/25/一种悬浮hover/","link":"","permalink":"https://www.kaige1220.top/2018/07/25/一种悬浮hover/","excerpt":"效果如下 主要运用了不同的动画实现方式，可以学习下。","text":"效果如下 主要运用了不同的动画实现方式，可以学习下。 实现方式如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* 定义按钮 */ .button &#123; top:100px; margin: 0.2em; left: 50%; padding: 1em; cursor: pointer; background: #ececec; text-decoration: none; color: #666; &#125; /* 让我们先定义个动画 我们知道定义动画需要先用关键字@keyframes 来定义我们需要用到的动画 hover 和 hover-shadow 就是两个动画的名字了 0 50% 100% 代表的是过度效果。里面的内容就是变化的内容 里面的 transform 是另外一种二D动画 其中translateY 代表的是沿着Y轴移动 opacity代表的是透明度 */ @keyframes hover &#123; 50% &#123; transform: translateY(-3px); &#125; 100% &#123; transform: translateY(-6px); &#125; &#125; @keyframes hover-shadow &#123; 0% &#123; transform: translateY(6px); opacity: 0.4; &#125; 50% &#123; transform: translateY(3px); opacity: 1; &#125; 100% &#123; transform: translateY(6px); opacity: 0.4; &#125; &#125; .hover-shadow &#123; display: inline-block; position: relative; transition-duration: .3s; transition-property: transform; /* Prevent highlight colour when element is tapped 只适用于ios 不用管它 */ -webkit-tap-highlight-color: rgba(0, 0, 0, 0); transform: translateZ(0); /* 做一点小的阴影效果 */ box-shadow: 0 0 1px rgba(0, 0, 0, 0); &#125;/* 下面是添加阴影效果，过会用来实现动画的 */ .hover-shadow:before &#123; pointer-events: none; position: absolute; z-index: -1; content: ''; top: 100%; left: 5%; height: 10px; width: 90%; opacity: 0; background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.35) 0%, rgba(0, 0, 0, 0) 80%); /* W3C */ transition-duration: .3s; transition-property: transform opacity; &#125;/* 添加效果 */ .hover-shadow:hover &#123; transform: translateY(-6px); animation-name: hover; animation-duration: 1.5s; animation-delay: .3s; animation-timing-function: linear; animation-iteration-count: infinite; animation-direction: alternate; &#125; .hover-shadow:hover:before &#123; opacity: 0.4; transform: translateY(6px); animation-name: hover-shadow; animation-duration: 1.5s; animation-delay: 0.3s; animation-timing-function: linear; animation-iteration-count: infinite; animation-direction: alternate; &#125;&lt;/style&gt;&lt;div class=\"button hover-shadow\"&gt; 点击我吧&lt;/div&gt; &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"css","slug":"技术/css","permalink":"https://www.kaige1220.top/categories/技术/css/"},{"name":"hover","slug":"技术/css/hover","permalink":"https://www.kaige1220.top/categories/技术/css/hover/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.kaige1220.top/tags/css/"},{"name":"hover","slug":"hover","permalink":"https://www.kaige1220.top/tags/hover/"}]},{"title":"投资语录","slug":"投资语录","date":"2018-07-16T12:30:33.592Z","updated":"2018-07-16T12:52:57.331Z","comments":true,"path":"2018/07/16/投资语录/","link":"","permalink":"https://www.kaige1220.top/2018/07/16/投资语录/","excerpt":"","text":"其实做投资和军事是一样的，面对不可预见性，优秀的将领有必备两大要素：第一，即便在最黑暗的时刻，也具有能够发现一线微光的慧眼；第二，敢于跟随这一线微光前进。那为什么将军能打胜仗呢？这是因为’对手不知道我的厉害’。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"感悟","slug":"投资/感悟","permalink":"https://www.kaige1220.top/categories/投资/感悟/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"感悟","slug":"感悟","permalink":"https://www.kaige1220.top/tags/感悟/"}]},{"title":"运气的定义","slug":"运气的定义","date":"2018-07-16T07:41:43.268Z","updated":"2018-07-16T12:45:34.214Z","comments":true,"path":"2018/07/16/运气的定义/","link":"","permalink":"https://www.kaige1220.top/2018/07/16/运气的定义/","excerpt":"","text":"气好的背后，是不为人知的布局。运气，最重要的是“运”，运作，布局，“气”自然而来。","categories":[{"name":"生活","slug":"生活","permalink":"https://www.kaige1220.top/categories/生活/"},{"name":"杂谈","slug":"生活/杂谈","permalink":"https://www.kaige1220.top/categories/生活/杂谈/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.kaige1220.top/tags/生活/"},{"name":"杂谈","slug":"杂谈","permalink":"https://www.kaige1220.top/tags/杂谈/"}]},{"title":"什么标的不能买","slug":"什么标的不能买","date":"2018-07-16T05:22:54.194Z","updated":"2018-07-16T06:00:18.103Z","comments":true,"path":"2018/07/16/什么标的不能买/","link":"","permalink":"https://www.kaige1220.top/2018/07/16/什么标的不能买/","excerpt":"","text":"一般，我们都比较倾向于买什么，而不不买什么，其实相较而言，不买什么更重要，那么与我而言，有哪些是不能买的呢？ 上一波的大牛股，大热股 不能买， 不管跌 50% 70% 都不能买。这些股票一般来说涨幅都10倍计， 在牛市中集中释放利好， 股票涨幅远超业绩涨幅，而且牛市过后，需要一段时间为前期牛市的利好及超涨来还债，迎来相当长时期的双杀期。 高市盈率+ 高市净率+ 高市销率 不能买， 这种是纯粹的泡沫， 单一指标的高不代表泡沫，需要仔细分析， 但3个指标齐高，基本没救。。只能慢慢去泡沫，我觉得碰到下一个亚马逊的几率微乎其微。 低市盈率，大幅飙高的周期股不能买， 这个大家都知道。。 对于周期股，看股价位置和市净率远比看市盈率靠谱。 短期关注极高的股不能买。。基本大家都开始讨论的时候就是最高点了，就是为了吸引你的目光你才开始关注他的，否则你都不知道有这个股票。 。。 有过造假历史的不能买。。历史证明，造假是有传统的，绝不会只有一次，而是不负众望的一次次造假。 应收账款增加幅度 远大于 营收增加幅度的不能买，一般这种情况就是明白告诉你，产品不太受顾客喜爱了，只有放宽条件放货，要不就是下游困难了。，后面有的苦日子。 广告费用大幅增加， 营收增加缓慢的不能买。说明这个行业开始下滑。或则出现了强大的竞争者 。 大股东减持的不能买。。不管怎样花言巧语。。只要出现这个信号，无条件清空。 新股前3年不能买， 首先估值消化起码要3年， 1年后小股东减持，3年后大股东减持，这2波扛下来，再来慢慢看。 连续逆势2年以上走牛的板块不能买。我做过统计。基本后面都会走输大盘。所以就不去筹这个热闹了。 前期连续小阳攀升，到一个平台连拉3根巨量阳线的不能买。。90%都是套啊 。。。 国家大力支持行业。前期可以介入。。后面绝不能碰。。全是产能过剩啊 。。。 一群大v强力推荐的成长股。。说的老泪纵横，相见恨晚， 市盈率超过30倍以上不能买。。80%就是顶。。 大家都赋予众望， 也都看好，股价也没怎么涨过，有一定品牌优势，但几次让大家失望的不能买， 坏的管理极难改变， 可能100次碰不到一次。所以不要浪费时间和金钱在它身上，虽然不会亏很多。。但带给你只有失望。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"感悟","slug":"投资/感悟","permalink":"https://www.kaige1220.top/categories/投资/感悟/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"感悟","slug":"感悟","permalink":"https://www.kaige1220.top/tags/感悟/"}]},{"title":"有趣的国名","slug":"有趣的国名","date":"2018-07-13T07:43:42.616Z","updated":"2018-07-13T07:44:29.602Z","comments":true,"path":"2018/07/13/有趣的国名/","link":"","permalink":"https://www.kaige1220.top/2018/07/13/有趣的国名/","excerpt":"","text":"《诸蕃志》记述了交趾国、占城国、真腊国、宾瞳龙国、登留眉国、蒲甘国、三佛齐国、单马令国、凌牙斯加国、佛罗安国、新拖国、监篦国、兰无里国、细兰、苏吉丹、南毗国、故临国 ，胡茶辣国、麻囉华国、注辇国、鹏茄罗国、南尼华囉国、大秦国、大食国、麻嘉国、弼琶囉国、 层拔国、 中理国、瓮蛮国、白达国、吉兹尼国、忽厮离国、木兰皮国、遏根陀国、茶弼沙国、斯伽里野国、默伽猎国、渤泥国、麻逸国、三屿国、蒲哩鲁国、流求国、毗舍耶国、新罗国、倭国等五十八个国。","categories":[{"name":"文学常识","slug":"文学常识","permalink":"https://www.kaige1220.top/categories/文学常识/"},{"name":"有趣的国名","slug":"文学常识/有趣的国名","permalink":"https://www.kaige1220.top/categories/文学常识/有趣的国名/"}],"tags":[{"name":"文学常识","slug":"文学常识","permalink":"https://www.kaige1220.top/tags/文学常识/"},{"name":"有趣的国名","slug":"有趣的国名","permalink":"https://www.kaige1220.top/tags/有趣的国名/"}]},{"title":"持股周期","slug":"关于持股周期问题","date":"2018-07-13T07:42:08.691Z","updated":"2018-07-13T07:43:03.617Z","comments":true,"path":"2018/07/13/关于持股周期问题/","link":"","permalink":"https://www.kaige1220.top/2018/07/13/关于持股周期问题/","excerpt":"","text":"我试过持有过一些股票上涨了100%没卖，然后亏损了50%我才止损出局；也试过亏损了50%没卖，然后涨了好几倍；还试过亏损一直坚持，然后被低价私有化，略亏出局。所以，问题的核心不是涨还是跌，而是股票的变化与基本面的变化差距有多大？如果一个基本面变化影响一年10%盈利，股价却跌了30%，这个时候才匆忙进行基本面止损就没意义了，反过来也是一样。 但是一般来说企业都有生意周期，突然的差往往不是短暂现象。好的时候连续增长好几年，差的时候又会连续倒退好几年，因此连续增长/倒退几年的企业，就很容易给人一种盈利状况会延续下去的印象，所以才会出现钟摆现象。施老说他平均持股四年，周期好转阶段不轻易換股，这是为什么呢？","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"持股周期","slug":"投资/持股周期","permalink":"https://www.kaige1220.top/categories/投资/持股周期/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"持股周期","slug":"持股周期","permalink":"https://www.kaige1220.top/tags/持股周期/"}]},{"title":"钟摆理论","slug":"钟摆理论","date":"2018-07-13T07:32:36.020Z","updated":"2018-07-13T07:33:24.062Z","comments":true,"path":"2018/07/13/钟摆理论/","link":"","permalink":"https://www.kaige1220.top/2018/07/13/钟摆理论/","excerpt":"","text":"好的时候大家都会去顶期更好的利润会出现，差的时候大家都会去预测更坏的结果，不然哪来的钟摆现象？市场上傻子都“理性”的很，他们卖出的原因都是有理有据的，不然谁会低价卖出，总得有个原因吧？15年的时候，福特单车利润都去到不可思议的三万元一辆了，而且又没新款，大家却还不断有更高的预期，现在明摆着会有很多新款上市了，大家又……不过算了，最近看到市场又一致性认为房地产公司10%利润率会是可持续性的，钟摆现象永不过时 。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"钟摆理论","slug":"投资/钟摆理论","permalink":"https://www.kaige1220.top/categories/投资/钟摆理论/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"钟摆理论","slug":"钟摆理论","permalink":"https://www.kaige1220.top/tags/钟摆理论/"}]},{"title":"人生态度","slug":"人生态度","date":"2018-07-13T07:27:45.187Z","updated":"2018-07-13T07:28:42.765Z","comments":true,"path":"2018/07/13/人生态度/","link":"","permalink":"https://www.kaige1220.top/2018/07/13/人生态度/","excerpt":"","text":"人的一生，选择非常重要。很多人在小事上斤斤计较，大事选择上却简单草率。终其原因是智慧不够。要做好选择，首先要提高自己的知识和智慧，明白自己真正想要什么，什么最重要。知道了这个，就不存在选择难得事情了。","categories":[{"name":"生活","slug":"生活","permalink":"https://www.kaige1220.top/categories/生活/"},{"name":"态度","slug":"生活/态度","permalink":"https://www.kaige1220.top/categories/生活/态度/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.kaige1220.top/tags/生活/"},{"name":"态度","slug":"态度","permalink":"https://www.kaige1220.top/tags/态度/"}]},{"title":"布局机会","slug":"布局机会","date":"2018-07-13T07:17:13.470Z","updated":"2018-07-13T07:31:14.864Z","comments":true,"path":"2018/07/13/布局机会/","link":"","permalink":"https://www.kaige1220.top/2018/07/13/布局机会/","excerpt":"","text":"好的布局机会往往是在市场感觉痛苦的阶段，但是不是值得去买，一定是基于对未来价值的判断。这个阶段有高估回撤下的真跌，也有好票错杀的假摔，有些跌下去要很久才能起来，有些跌下去，却是难得的机遇。真等到市场又拨云见日的时候，你又会感叹无处下手了吧。买还是不买，始终考验每个人的决断能力。 散户之所以喜涨怕跌，还是因为跌下去手里没有子弹了，就算明明知道跌出价值了，也惶恐于账面上的浮亏。所以跌久了跌多了，要么就地躺下，要么忍痛割肉，这是大部分散户无奈的抉择。套和涨一样，都是持仓状态里面的必然过程，只是你一定要明白，你这个套值不值得，而不是纠结于波动。 指数用来管控仓位，选股看行业，行业看龙头。不要试图总做最热门的。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"布局机会","slug":"投资/布局机会","permalink":"https://www.kaige1220.top/categories/投资/布局机会/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"布局机会","slug":"布局机会","permalink":"https://www.kaige1220.top/tags/布局机会/"}]},{"title":"关于估值的理解","slug":"关于估值的理解","date":"2018-07-13T07:12:35.028Z","updated":"2018-07-13T08:36:42.323Z","comments":true,"path":"2018/07/13/关于估值的理解/","link":"","permalink":"https://www.kaige1220.top/2018/07/13/关于估值的理解/","excerpt":"什么样的估值是合理，什么样的预期是饱满？ 我今年以来重点强调的使用PEG，14~15年的行情，我们习惯用市值，因为这个过程可以有大量外延式并购来拓展预期，当市场回归到内在成长的阶段，按照标的属性，就可以用PEG来找一些可博弈的机会。 利用PEG去确认估值，简单点说，做估值，既要看过往的增长路径，也要看未来预期，且主要是未来预期，如果一家公司保持未来三年30~40%的业绩增速，它的PEG低于1的时候就一定是大概率的好估值了。对应PE就是30~40倍。","text":"什么样的估值是合理，什么样的预期是饱满？ 我今年以来重点强调的使用PEG，14~15年的行情，我们习惯用市值，因为这个过程可以有大量外延式并购来拓展预期，当市场回归到内在成长的阶段，按照标的属性，就可以用PEG来找一些可博弈的机会。 利用PEG去确认估值，简单点说，做估值，既要看过往的增长路径，也要看未来预期，且主要是未来预期，如果一家公司保持未来三年30~40%的业绩增速，它的PEG低于1的时候就一定是大概率的好估值了。对应PE就是30~40倍。 如果未来增速更加饱满，PEG自然越低越好，所以对应PE你就有一个弹性的估值区间。（周期股或者业绩状态不稳定的公司，不适合用PEG估值） 基于PEG你需要解决的一个是当下的估值，一个是未来两三年的业绩增长预期。这些预期，你既要有认知行业的能力，根据公司业绩公布的状态，预报，以及机构给的各种研报去佐证。如果有调研能力，还可以去参加公司的集体接待日亦或年度季度的股东大会。这些可以让自己有更多接触公司管理层的机会，他们的认知，理解以及愿景也能让你感受到这家企业是不是值得期待。 所以，你需要做的便是，通过ROE找出优质公司，且辨识ROE是否是因为通过负债来调节的，理论上负债率越低，但ROE越高的公司越优质。 然后才是结合市场阶段或者中长期的估值状态来找你的布局点，但凡发现公司的PEG已经低于1，且PE绝对值不是很离谱（低于45以下），你大概率已经拿到了好牌！ 最后总结，长期复合增速20%+是找牛股的基础，对应PEG合理甚至低估「PEG≦1」，意味着PE状态的合理性，如果预期未来增速超预期也会获得更高收益。 再结合市值体量，行业景气度，市场天花板来找成长属性好的细分龙头，你的整个投资方向基本就有了轮廓。 这样借助企业增速来实现年度复利增长的便构成了投资策略。 做投资，找准方向了，其实很多事情就自然而然，水到渠成了。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"估值","slug":"投资/估值","permalink":"https://www.kaige1220.top/categories/投资/估值/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"},{"name":"估值","slug":"估值","permalink":"https://www.kaige1220.top/tags/估值/"}]},{"title":"我喜欢你","slug":"好句子","date":"2018-07-13T07:08:12.175Z","updated":"2018-07-13T08:35:15.689Z","comments":true,"path":"2018/07/13/好句子/","link":"","permalink":"https://www.kaige1220.top/2018/07/13/好句子/","excerpt":"","text":"我喜欢你并不是因为你长的好看不好看而是因为你在特殊的时间给了我别人给不了的东西说不清哪里好但就是谁都替代不了的","categories":[{"name":"语句","slug":"语句","permalink":"https://www.kaige1220.top/categories/语句/"}],"tags":[{"name":"我喜欢你","slug":"我喜欢你","permalink":"https://www.kaige1220.top/tags/我喜欢你/"}]},{"title":"我的投资悟道之旅2","slug":"我的投资之道2","date":"2018-07-13T06:51:46.575Z","updated":"2018-07-13T08:40:25.068Z","comments":true,"path":"2018/07/13/我的投资之道2/","link":"","permalink":"https://www.kaige1220.top/2018/07/13/我的投资之道2/","excerpt":"逆向投资买入因各种原因遭到人们抛弃，受到打压的公司，只要情况稍有好转，在杠杆效应作用下就能赚很多。不跟随大众所有人都想抓住正确的时机。大家都玩的游戏，我就不跟着掺和。如果你买的是价值，可能会买得太早，要是跌到更低了，就继续买入，必须对自己做的事有信心。","text":"逆向投资买入因各种原因遭到人们抛弃，受到打压的公司，只要情况稍有好转，在杠杆效应作用下就能赚很多。不跟随大众所有人都想抓住正确的时机。大家都玩的游戏，我就不跟着掺和。如果你买的是价值，可能会买得太早，要是跌到更低了，就继续买入，必须对自己做的事有信心。 严格遵守原则实现成功投资的最佳途径就是制定一些原则，制定一些只要严格遵循就会减少亏损几率的原则，并严格遵守这些原则。 对宏观经济的看法 不预测有些人能预测出来，但大数多人是不行的，也不要尝试预测宏观经济和牛熊市。 不追涨、不追热点要是市场涨疯了，你还想留在市场里，要么降低标准，要么买入不会参与到疯狂中的股票。 不关注大宗商品走势我对大宗商品毫不所知，不知道它们的价格走向。我买入开采铜矿的大宗商品公司，只是根据股价看觉得便宜，不是因为我知道铜价或白银的价格走向。 分散投资喜欢分散投资我们差不多有100家公司。我喜欢拥有多支股票，巴菲特喜欢拥有几只股票，他是巴菲特，这么做没有错。但如果你不是，你必须选择适合自己的方式，就我而言，我喜欢晚上睡得安稳。分散是对不确定性的保护。 注意总体仓位控制我们常犯的错误是开始的时候太激进，一开始买得太多，股价跌到更低时，要投入大量资金才能把成本摊下来。有时候，我们开始买得实在太多了，股价跌到更低，这时再加仓就会导致过于集中。 重点 我觉得如果真是非常看好的机会，第一次买入时可能最少投入这只股票计划仓位的50%，有时候我觉得最好是70%。 谁都不知道下面会怎么样，股票可能一下子就涨起来。有时候，我们觉得股票不是太便宜，不过会先买一点，先进到里面去，可能只买计划仓位的10%。 最高单股仓位我们要是真看好了，会投入投资组合高达10%-15%的仓位。 换手率我们的平均换手率为每年25%，也就是持股时间一般为3-4年。 重点 不赞同卖A换B一只股票一步步渐入佳境，你也慢慢熟悉这只股票，要是因为相对价值换股，在新买入的股票上还要熬三年。这些东西都有生命周期。所以说，我们不愿意用A股票换B股票。 行业和企业选择市盈率高低与是否买入无直接因果关系只看市盈率低就买入股票而遭到亏损的人不在少数，我们买的股票可能是市盈率低的，也可能是市盈率高的。 如何pass掉一些标的：很简单，看过去8年应收账款比例，库存比例的变化。然后看看过去8年累计现金流和利润相比是否匹配。 这2条就把推荐的大多数企业给刷了。。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"沃尔特·施洛斯","slug":"投资/沃尔特·施洛斯","permalink":"https://www.kaige1220.top/categories/投资/沃尔特·施洛斯/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"}]},{"title":"我的投资悟道之旅","slug":"我的投资之道1","date":"2018-07-13T05:46:25.178Z","updated":"2018-07-13T08:36:55.296Z","comments":true,"path":"2018/07/13/我的投资之道1/","link":"","permalink":"https://www.kaige1220.top/2018/07/13/我的投资之道1/","excerpt":"一个正确的买点，一般有一下几个逻辑支撑： 一定是强势股 经过充分调整 回调到30到60 日线可以考虑 有增量交易 最重要是跌无可跌时进入","text":"一个正确的买点，一般有一下几个逻辑支撑： 一定是强势股 经过充分调整 回调到30到60 日线可以考虑 有增量交易 最重要是跌无可跌时进入 第一买点：欧奈尔RPS值在95以上，股价在高度完整的中期调整结束之际，向上放量开始做右杯壁的时候。此时，股价并没有突破前期最高点，也就是说还没有一年新高。 这里解释下什么叫做欧奈尔RPS值：其定义是在一段时间内，个股涨幅在全部股票涨幅排名中的位次值。例如，假设某证券市场共有50只股票进行交易，若某股票的月涨幅在50只股票中排名第5位，则该股的RPS指标值为： （1-5/50）×100=90 该指标值的意义即表明该股的月涨幅超过其他90%股票的涨幅。通过这个指标可以很好地体现个股股价走势在同期整个市场走势中表现的相对强弱。 RPS作为选股模式的选股标准： 1、 月度RPS值＞90之个股； 2、 股价已脱离底部形态，但向上突破尚未超过15%之个股。 注意对于上市不足一年的新股，RPS值参考意义不大。 下面我们通过通达信来看看如何一步一步操作：第一步，新建一个“上市一年以上”的自定义板块我们首先需要建立一个排除上市时间不足一年股票的板块。这个板块我取名为：上市一年以上。通达信软件的菜单—工具—自定义板块设置—新建板块。下图中，点击确定，就建立了“上市一年以上”板块，但板块中的股票需要另外添加 第二步，选入股票建立一个条件选股公式来选股到“上市一年以上”这个板块。条件选股公式很简单，如下：BARSCOUNT(C)&gt;N; N为参数，一般设为250 通达信软件，Control+F，条件选股公式—其他类型 点击上图中的确定，即完成建立公式。然后选股到这样板块：通达信软件，Control+T，条件选股公式的下拉菜单中，选中：上市一年以上，选股范围为：沪深A股，然后点：加入条件，如下图： 上图中，点击：选股入板块，再选中“上市一年以上”，确定，确定，最后选中2830只股票。 新建一个技术指标的公式： 通达信软件，Control+F，技术指标公式—其他类型 点击上图中的新建，进入下图： 点击上图中的确定，即完成建立公式 其他请参考：https://xueqiu.com/1669779901/85556955 第二类买点第二个买点是一年新高+高RPS值+明显放量+突破长期整理平台。例如2017年5月10日的中国*平安，RPS值翻红到达90以上，股价一年新高，突破长期整理平台，这是一个完美的买点。","categories":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/categories/投资/"},{"name":"买点","slug":"投资/买点","permalink":"https://www.kaige1220.top/categories/投资/买点/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://www.kaige1220.top/tags/投资/"}]},{"title":"mac下终端命令学习","slug":"终端命令集","date":"2018-07-08T11:44:40.008Z","updated":"2018-11-19T00:53:36.185Z","comments":true,"path":"2018/07/08/终端命令集/","link":"","permalink":"https://www.kaige1220.top/2018/07/08/终端命令集/","excerpt":"最近，好多东西从win下迁移到mac上了，所以再学习下终端命令的知识：clear 清空屏幕的内容 percent work directary pwd 查看我们所在的目录（位置），刚打开终端的时候，默认在用户目录下。 list show ls 显示当前目录下的文件内容 ls 可以和路径配合使用，用于显示路径下的内容 ls后面如果什么都不加，默认显示当前目录下的内容。 ls / 显示跟目录下的内容 cd - 回到上一个目录 cd ~ 回到用户目录(刚打开终端时的目录) / 根目录 ./ 当前目录 ../ 上一级目录","text":"最近，好多东西从win下迁移到mac上了，所以再学习下终端命令的知识：clear 清空屏幕的内容 percent work directary pwd 查看我们所在的目录（位置），刚打开终端的时候，默认在用户目录下。 list show ls 显示当前目录下的文件内容 ls 可以和路径配合使用，用于显示路径下的内容 ls后面如果什么都不加，默认显示当前目录下的内容。 ls / 显示跟目录下的内容 cd - 回到上一个目录 cd ~ 回到用户目录(刚打开终端时的目录) / 根目录 ./ 当前目录 ../ 上一级目录 make directory mkdir xxx 在当前目录下，创建一个xxx名字的文件夹 touch aaa 在当前目录下创建一个aaa名字的文件 remove rm 1.txt 删除名字为1.txt的文件 rm -rf 456/ 删除当前目录下456名字的文件夹，删除文件夹的同时，里面的文件统统删除。 (方向键上下键，可以翻看历史命令) move mv 1.txt 123.txt 移动+改名，将当前目录的1.txt 移动到当前目录，并改名为123.txt cp 1.txt 2.txt 将当前目录下的1.txt拷贝一份，并放到当前目录下，并命名为2.txt vi 一般模式，命令模式，编辑模式 按a，就由一般模式进入编辑模式 由编辑模式退回一般模式，Esc 命令模式，以：开头的 :q 退出 :wq 保存退出 :q! 强制退出 （不保存退出） :set nu 显示行号 :set nonu 隐藏行号 一般模式下 dd 删除一行（剪切） ctrl+x num dd 删除num行 p 将剪切的内容粘贴到光标所在行下面 ctrl+v yy 拷贝一行 ctrl+c num yy 拷贝num行 u 撤销 undo ctrl+r 恢复 redo gg 定位到第一行 shift+g 定位到最后一行 num shift+g 定位到num行","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"终端命令","slug":"技术/终端命令","permalink":"https://www.kaige1220.top/categories/技术/终端命令/"}],"tags":[{"name":"终端命令","slug":"终端命令","permalink":"https://www.kaige1220.top/tags/终端命令/"}]},{"title":"node 文件压缩","slug":"node学习文件压缩","date":"2018-07-03T01:48:48.425Z","updated":"2018-07-05T12:17:36.807Z","comments":true,"path":"2018/07/03/node学习文件压缩/","link":"","permalink":"https://www.kaige1220.top/2018/07/03/node学习文件压缩/","excerpt":"简单的压/解压缩压缩在nodejs里，是如何对资源进行压缩的呢——Zlib模块。 1234567891011var fs = require ('fs');var zlib = require('zlib');var gzip = zlib.createGzip();var inFile = fs.createReadStream('./extra/fileForCompress.txt')var out = fs.createWriteStream(./extra/fileForCompress.txt.gz;)inFile.pipe(gzip).pipe(out);","text":"简单的压/解压缩压缩在nodejs里，是如何对资源进行压缩的呢——Zlib模块。 1234567891011var fs = require ('fs');var zlib = require('zlib');var gzip = zlib.createGzip();var inFile = fs.createReadStream('./extra/fileForCompress.txt')var out = fs.createWriteStream(./extra/fileForCompress.txt.gz;)inFile.pipe(gzip).pipe(out); 解压的例子反向操作： 123456789var fs = require('fs');var zlib = require('zlib');var gunzip = zlib.createGunzip();var inFile = fs.createReadStream('./extra/fileForCompress.txt.gz');var outFile = fs.createWriteStream('./extra/fileForCompress1.txt');inFile.pipe(gunzip).pipe(outFile); 服务端gzip压缩首先判断 是否包含 accept-encoding 首部，且值为gzip。 否：返回未压缩的文件。 是：返回gzip压缩后的文件。 123456789101112131415161718192021var http = require('http');var zlib = require('zlib');var fs = require('fs');var filepath = './extra/fileForGzip.html'var server = http.createServer(function(req,res)&#123; var acceptEncoding = req.headers['accept-encoding']; var gzip; if(acceptEncoding.indexOf('gzip')!=-1)&#123; gzip = zlib.createGzip(); res.writeHead(200,&#123; 'Content-Encoding' : 'gzip' &#125;); fs.createReadStream(filepath).pipe(gzip).pipe(res); &#125;else&#123; fs.createReadStream(filepath).pipe(res); &#125;&#125;)server.listen('3000'); 服务端字符串gzip压缩代码跟前面例子大同小异。这里采用了slib.gzipSync(str)对字符串进行gzip压缩。 12345678910111213141516171819var http = require('http');var zlib = require('zlib');var responseText = 'hello world';var server = http.createServer(function(req, res)&#123; var acceptEncoding = req.headers['accept-encoding']; if(acceptEncoding.indexOf('gzip')!=-1)&#123; res.writeHead(200, &#123; 'content-encoding': 'gzip' &#125;); res.end( zlib.gzipSync(responseText) ); &#125;else&#123; res.end(responseText); &#125;&#125;);server.listen('3000'); 学习来源","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"https://www.kaige1220.top/categories/技术/node-js/"},{"name":"文件压缩","slug":"技术/node-js/文件压缩","permalink":"https://www.kaige1220.top/categories/技术/node-js/文件压缩/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.kaige1220.top/tags/node-js/"},{"name":"文件压缩","slug":"文件压缩","permalink":"https://www.kaige1220.top/tags/文件压缩/"}]},{"title":"CSS专业技巧","slug":"css专业技巧","date":"2018-07-01T09:58:07.008Z","updated":"2018-07-05T12:08:30.818Z","comments":true,"path":"2018/07/01/css专业技巧/","link":"","permalink":"https://www.kaige1220.top/2018/07/01/css专业技巧/","excerpt":"使用CSS复位CSS复位可以在不同的浏览器上保持一致的样式风格。您可以使用CSS reset 库normalize等，也可以使用一个更简化的复位方法： 12345* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125; 注意：如果你遵循接下来继承 box-sizing讲解的这个技巧, 你不需要在以上代码中添加 box-sizing 属性。 继承 box-sizing从 html 元素继承 box-sizing ： 123456789html &#123; box-sizing: border-box;&#125;*,*::before,*::after &#123; box-sizing: inherit;&#125;","text":"使用CSS复位CSS复位可以在不同的浏览器上保持一致的样式风格。您可以使用CSS reset 库normalize等，也可以使用一个更简化的复位方法： 12345* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125; 注意：如果你遵循接下来继承 box-sizing讲解的这个技巧, 你不需要在以上代码中添加 box-sizing 属性。 继承 box-sizing从 html 元素继承 box-sizing ： 123456789html &#123; box-sizing: border-box;&#125;*,*::before,*::after &#123; box-sizing: inherit;&#125; 使用unset而不是重置所有属性重置元素的属性时，不需要重置每个单独的属性： 123button &#123; all: unset;&#125; 所有速记在IE11中不被支持，目前正在考虑Edge的支持。 IE11不支持unset。 使用 :not() 选择器来决定表单是否显示边框先为元素添加边框 1234/* 添加边框 */.nav li &#123; border-right: 1px solid #666;&#125; 然后，为最后一个元素去除边框 1234/* 去掉边框 */.nav li:last-child &#123; border-right: none;&#125; 不过不要这么做，使用 :not() 伪类来达到同样的效果： 123.nav li:not(:last-child) &#123; border-right: 1px solid #666;&#125; 为 body 元素添加行高不必为每一个 ，&lt;h*&gt; 元素逐一添加 line-height，直接添加到 body 元素：123body &#123; line-height: 1.5;&#125; 文本元素可以很容易地继承 body 的样式。 垂直居中任何元素12345678910111213html,body &#123; height: 100%; margin: 0;&#125;body &#123; -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex;&#125; 逗号分隔列表使列表的每项都由逗号分隔： 123ul &gt; li:not(:last-child)::after &#123; content: \",\";&#125; 这一技巧对于无障碍，特别是屏幕阅读器而言并不理想。而且复制粘贴并不会带走CSS生成的内容,需要注意。 使用负的 nth-child 来选择元素使用负的 nth-child 可以选择 1 至 n 个元素。 12345678li &#123; display: none;&#125;/* 选择第 1 至第 3 个元素并显示出来 */li:nth-child(-n+3) &#123; display: block;&#125; 使用 “形似猫头鹰” 的选择器这个名字可能比较陌生，不过通用选择器 (*) 和 相邻兄弟选择器 (+) 一起使用，效果非凡： 123* + * &#123; margin-top: 1.5em;&#125; 在此示例中，文档流中的所有的相邻兄弟元素将都将设置 margin-top: 1.5em 的样式。 使用 max-height 来建立纯 CSS 的滑块12345678910.slider &#123; max-height: 200px; overflow-y: hidden; width: 300px;&#125;.slider:hover &#123; max-height: 600px; overflow-y: scroll;&#125; 创造格子等宽的表格table-layout: fixed 可以让每个格子保持等宽： 123.calendar &#123; table-layout: fixed;&#125; 利用 Flexbox 去除多余的外边距与其使用 nth-， first-， 和 last-child 去除列之间多余的间隙，不如使用 flexbox 的 space-between 属性： 12345678.list &#123; display: flex; justify-content: space-between;&#125;.list .person &#123; flex-basis: 23%;&#125; 利用属性选择器来选择空链接当 &lt;a&gt;元素没有文本内容，但有 href 属性的时候，显示它的 href 属性： 123a[href^=\"http\"]:empty::before &#123; content: attr(href);&#125; 给 “默认” 链接定义样式给 “默认” 链接定义样式： 1234a[href]:not([class]) &#123; color: #008000; text-decoration: underline;&#125; 一致垂直节奏通用选择器 (*) 跟元素一起使用，可以保持一致的垂直节奏： 123.intro &gt; * &#123; margin-bottom: 1.25rem;&#125; 固定比例盒子要创建具有固定比例的一个盒子，所有你需要做的就是给 div 设置一个 padding： 1234567891011121314.container &#123; height: 0; padding-bottom: 20%; position: relative;&#125;.container div &#123; border: 2px dashed #ddd; height: 100%; left: 0; position: absolute; top: 0; width: 100%;&#125; 使用20％的padding-bottom使得框等于其宽度的20％的高度。与视口宽度无关，子元素的div将保持其宽高比（100％/ 20％= 5:1）。 为破碎图象定义样式只要一点CSS就可以美化破碎的图象： 1234567891011img::before &#123; content: \"We're sorry, the image below is broken :(\"; display: block; margin-bottom: 10px;&#125;img::after &#123; content: \"(url: \" attr(src) \")\"; display: block; font-size: 12px;&#125; 用 rem 来调整全局大小；用 em 来调整局部大小在根元素设置基本字体大小后 (html { font-size: 100%; }), 使用 em 设置文本元素的字体大小: 1234567h2 &#123; font-size: 2em;&#125;p &#123; font-size: 1em;&#125; 然后设置模块的字体大小为 rem: 1234567article &#123; font-size: 1.25rem;&#125;aside .module &#123; font-size: .9rem;&#125; 现在，每个模块变得独立，更容易、灵活的样式便于维护。rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。 使用选择器:root来控制字体弹性在响应式布局中，字体大小应需要根据不同的视口进行调整。你可以计算字体大小根据视口高度的字体大小和宽度，这时需要用到:root:123:root &#123; font-size: calc(1vw + 1vh + .5vmin);&#125; 现在，您可以使用 root em 123body &#123; font: 1rem/1.6 sans-serif;&#125; 使用指针事件來控制鼠标事件指针事件允許您指定鼠标如何与其触摸的元素进行交互。 要禁用按钮上的默认指针事件，例如： 1234.button-disabled &#123; opacity: .5; pointer-events: none;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"css","slug":"技术/css","permalink":"https://www.kaige1220.top/categories/技术/css/"},{"name":"CSS专业技巧","slug":"技术/css/CSS专业技巧","permalink":"https://www.kaige1220.top/categories/技术/css/CSS专业技巧/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.kaige1220.top/tags/css/"},{"name":"CSS专业技巧","slug":"CSS专业技巧","permalink":"https://www.kaige1220.top/tags/CSS专业技巧/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2018-07-01T08:33:46.578Z","updated":"2018-07-16T04:38:10.335Z","comments":true,"path":"2018/07/01/正则表达式/","link":"","permalink":"https://www.kaige1220.top/2018/07/01/正则表达式/","excerpt":"什么是正则简单来说，正则就可以理解为一个规则，用来处理字符串的一个规则（正则就是用来处理字符串的），这里所说处理一般是包含匹配和捕获。","text":"什么是正则简单来说，正则就可以理解为一个规则，用来处理字符串的一个规则（正则就是用来处理字符串的），这里所说处理一般是包含匹配和捕获。 匹配：判断一个字符串是否符合指定的规则，使用test方法：reg.test(str) 1234var reg = /\\d/; // 包含一个0~9之间的数字console.log(reg.test('天')); // falseconsole.log(reg.test('1')); // trueconsole.log(reg.test('现在是2017')); // true，只要包含了数字就返回true 捕获：把字符串中符合指定的正则规则的内容捕获到，使用exec方法：reg.exec(str) 12345var reg = /\\d/;console.log(reg.exec('天')); // nullconsole.log(reg.exec('1')); // [\"1\", index: 0, input: \"1\"]console.log(reg.exec('现在是2017')); // [\"2\", index: 3, input: \"现在是2017\"] 如何创建正则字面量方式1var reg = /\\d/; 实例方式 1var reg = new RegExp('/\\d/'); 正则的组成从上面的内容中已经了解到，每一个正则表达式是包含在//中的，正则表达式就是匹配规则，正则的组成就是元字符和修饰符。 元字符具有特殊意义的元字符 \\：转义字符，转义后面字符所代表的含义 ^：以某一个元字符开始 $：以某一个元字符结束 \\n：匹配一个换行符 .：除了\\n以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 语法： \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 如果就是想要匹配 . 或者?这样的字符呢？转义字符 \\. * \\? 12345678var reg = /^0.2$/; // 以0开头，以2结尾，中间可以是除了\\n的任意字符console.log(reg.test('0.2')); // trueconsole.log(reg.test('0-2')); // truereg = /^0\\.2$/; // 将\".\"转义console.log(reg.test('0.2')); // trueconsole.log(reg.test('0-2')); // false 代表出现次数的量词元字符 *：出现0到多次 +：出现1到多次 ?：出现0次或者1次 {n}：出现n次 {n,m}：出现n到m次 12var reg = /^\\d+$/;console.log(reg.test('2015')); // true 修饰符 x|y：x或y中的一个 [xyz]：x或y或z中的一个 [^xyz]：除了xyz以外的任意一个字符 [a-z]：a-z之间的任何一个字符 [^a-z]：除了a-z之间的任何一个字符 \\d：一个0~9之间的数字 \\D：除了0~9之间的数字以外的任何字符 \\b：一个边界符 \\w：数字、字母、下划线中的任意一个字符 \\s：匹配一个空白字符、空格 ()：分组，把一个大正则本身划分成几个小的正则，例如：var reg = /^(\\d+)zhufeng(\\d+)$/; 分枝条件 用|把不同的规则分隔开 从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了 0\\d{2}-\\d{8}|0\\d{3}-\\d{7} 元字符的应用[]的规律 在中括号中出现的所有的字符都是代表本身的意思的字符（没有特殊含义） 123456var reg = /^[.]$/; console.log(reg.test('1')); // false console.log(reg.test('.')); // true reg = /^[\\w-]$/; // 数字、字母、下划线、- 中的一个 console.log(reg.test('-')); // true 中括号不识别两位数 12var reg = /^[12]$/; // --&gt; 1或者2中的一个（符合[xyz]）var reg = /^[12-68]$/; // --&gt; 1、2-6中的一个、8 三个中的一个 ()的作用分组的作用有很多，现在先讲其中的一个：改变x|y的默认的优先级，还有的在后面的内容会详细介绍。 12var reg = /^18|19$/; // 18、19、181、189、119、819、1819这些都符合var reg = /^(18|19)$/; // 只能18或者19 应用一：有效数字的正则有效数字可以是正数、负数、零、小数，所以其特点为： “.”可以出现也可以不出现，一旦出现，后面必须跟着一位或多为数字； 最开始可能有“+/-”，也可以没有； 整数部分，一位数的情况可以是0-9中的一个，多位数的情况下不能以0开头 1var reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/; 应用二：年龄介于18~65之间年龄介于18~65之间的数字可以是18-19、20-59、60-65。 1var reg = /^1[8-9]|[2-5]\\d|6[0-5]$/; 应用三：简单的邮箱验证1var reg = /^[\\w.-]+@[0-9a-zA-Z]+(\\.[a-zA-Z]&#123;2,4&#125;)&#123;1,2&#125;$/; 两种方式创建正则的区别 字面量方式中出现的一切都是元字符，不能进行变量值的拼接，而实例创建的方式可以； 字面量方式中直接写\\d可以，而在实例中需要把它转义 \\d 正则的捕获及其贪婪性和懒惰性在上面有介绍到正则的捕获使用exec方法。在每一次捕获的时候都是先进行默认的匹配，如果没有匹配成功，则捕获的结果是null。只有有匹配的内容，才能捕获到。 懒惰性定义正则及字符串： 12var reg = /\\d+/;var str = 'iceman2016learn2017'; reg默认有一个lastIndex字段，该字段是正则每一次捕获时，在字符串中开始查找的位置，默认的值是0。 现在先进行第一次捕获： 123console.log(reg.lastIndex); // 0，第一次捕获的时候，从字符串索引0处开始查找var res = reg.exec(str);console.log(res); // [\"2016\", index: 6, input: \"iceman2016learn2017\"] 从代码的输出可知，正则捕获的内容格式：捕获到的内容是一个数组 数组的第一项是当前大正则捕获的内容； 有一项是index：捕获内容在字符串中开始的索引位置； 有一项是input：捕获的原始字符串； 现在进行第二次捕获： 1234console.log(reg.lastIndex); // 0 说明第二次捕获的时候，也要从字符串索引0处开始查找// 第二次通过exec捕获的内容还是第一个\"2016\"res = reg.exec(str);console.log(res); //[\"2016\", index: 6, input: \"iceman2016learn2017\"] 由上面的两次捕获可知，每次的捕获都是从字符串的索引0处开始查找的，这就是正则的懒惰型。 很明显正则的懒惰性是我们所要解决的问题，那么该如何解决懒惰性呢？ 答案就是在正则的末尾加一个修饰“g”（全局匹配），类似g这样的修饰符还有两个：i、m，这三者的作用是： global（g）：全局匹配 ignoreCase（i）：忽略大小写 multiline（m）：多行匹配 12345678910var reg = /\\d+/g;var str = 'iceman2016learn2017';console.log(reg.lastIndex); // 0console.log(reg.exec(str)); // [\"2016\", index: 6, input: \"iceman2016learn2017\"]console.log(reg.lastIndex); // 10console.log(reg.exec(str)); // [\"2017\", index: 15, input: \"iceman2016learn2017\"]console.log(reg.lastIndex); // 19console.log(reg.exec(str)); // null 贪婪性123var reg = /\\d+/g; // 出现一到多个0~9之间的数字var str = 'iceman2016learn2017javascript2018';console.log(reg.exec(str)); // [\"2016\", index: 6, input: \"iceman2016learn2017javascript2018\"] 看到这段代码的时候不知道您有没有一些疑惑，正则的内容是/\\d+/，是匹配1到多个数字，2016是符合正则的，那么2也是符合正则的啊，为什么默认就捕获了2016呢？ 这就是正则的贪婪性。 如何解决正则的贪婪性：在量词元字符后面添加一个”?”即可 123456789var reg = /\\d+?/g; // 出现一到多个0~9之间的数字var str = 'iceman2016learn2017javascript2018';console.log(reg.exec(str)); // [\"2\", index: 6, input: \"iceman2016learn2017javascript2018\"]var ary = [] , res = reg.exec(str);while (res) &#123; ary.push(res[0]); res = reg.exec(str)&#125;console.log(ary); // [\"0\", \"1\", \"6\", \"2\", \"0\", \"1\", \"7\", \"2\", \"0\", \"1\", \"8\"] “?”在正则中的作用： 放在一个普通的元字符后面，代表出现0~1次； 放在一个量词的元字符后面，取消捕获时候的贪婪性； 字符串中的match方法match方法的作用是，把所有和正则匹配的字符都获取到。 1234var reg = /\\d+?/g;var str = 'zhufeng2015peixun2016dasgdas2017';var ary = str.match(reg);console.log(ary); // [\"2\", \"0\", \"1\", \"5\", \"2\", \"0\", \"1\", \"6\", \"2\", \"0\", \"1\", \"7\"] 虽然在当前的情况下，match比exec更加的简洁一些，但是match存在一些自己处理不了的问题：在分组捕获的情况下，match只能捕获到大正则，而对于小正则捕获的内容是无法获取的。 分组捕获正则分组正则分组的两个作用： 改变优先级 分组引用 \\2代表和第二个分组出现一模一样（和对应的分组中的内容和值都要一样）的内容，\\1代表和第一个分组出现一模一样的内容； 123var reg = /^(\\w)(\\w)\\1\\2$/;console.log(reg.test(\"icic\")); // trueconsole.log(reg.test(\"r0g_\")); // false 正则在捕获的时候，不仅仅把大正则匹配的内容捕获到，而且还可以把小分组匹配的内容捕获到。 身份证中的数字都有意义的，比如开头的两位代表省，中间的四位代表…所以对于一个身份中，有必要对其中的数字按照其意义进行分组捕获。 123var reg = /^(\\d&#123;2&#125;)(\\d&#123;4&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(?:\\d&#123;2&#125;)(\\d)(?:\\d|X)$/;var str = \"350324202904190216\";console.log(reg.exec(str)); 注意：(?:) 在分组中?:的意思是只匹配不捕获 输出的内容为：[“350324200904190216”, “35”, “0324”, “2009”, “04”, “19”, “1”, index: 0, input: “350324200904190216”] replace基础1var str = 'iceman2016iceman2017'; 在上面定义的字符串中，现在需要将iceman替换成shoushou，我们知道字符串提供了一个replace方法，那么我们用replace来做一次： 12str = str.replace('iceman','shoushou');console.log(str); // shoushou2016iceman2017 从打印的结果可知，并没有实现我们想要的效果，只替换了第一个iceman字符串，看MDN中对于replace方法的定义： str.replace(regexp|substr, newSubStr|function)replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。 由replace的定义可知，匹配模式可以是一个正则的，所以我们用正则试一次： 12str = str.replace(/iceman/g, 'shoushou');console.log(str); // shoushou2016shoushou2017 再看replace函数的定义，第二个参数可以是一个函数： 12345678var str = 'iceman2016iceman2017';str = str.replace(/iceman/g, function () &#123; // 第一次执行匿名函数输出arguments的结果：[\"iceman\", 0, \"iceman2016iceman2017\"] // 第二次执行匿名函数输出arguments的结果：[\"iceman\", 10, \"iceman2016iceman2017\"] console.log(arguments); return 'shoushou';&#125;);console.log(str); // shoushou2016shoushou2017 从打印结果可知： 先按照正则指定的规则，到字符串中把正则匹配的内容捕获到，然后在每一次捕获到之后，都把捕获的内容替换成新的内容； 匿名函数执行多少次，取决于正则能在字符串中捕获多少次，在这里正则捕获两次，所以匿名函数也执行两次； 每一次执行匿名函数，里面传递的参数值arguments和自己通过exec捕获到的结果是一样的（每一次执行匿名函数，和单独执行exec捕获的内容一致）； 小分组捕获的内容，在这里同样可以获取到（所以说，replace和exec原理是一模一样的，比match要强大） return的结果是什么，就相当于把当前这一次大正则捕获的内容替换成返回的内容。如果不写return，默认使用undefined来进行替换，如果不想实现替换的话，我们可以把捕获的内容再返回回去 return arguments[0]； 1234567var str = 'iceman2015iceman2016';var reg = /iceman(\\d+)/g;str = str.replace(reg, function () &#123; // 第一次捕获arguments的值：[\"iceman2015\", \"2015\", 0, \"iceman2015iceman2016\"] // 第二次捕获arguments的值：[\"iceman2016\", \"2016\", 10, \"iceman2015iceman2016\"] console.log(arguments);&#125;); replace实战从上面的介绍中已经知道，正则的捕获有三种方式：正则的exec方法、字符串的match方法、字符串的replace方法。 其中replace是将原有的字符串替换成我们想要的新的字符串，在不适用正则的情况下，执行一次replace只能替换字符串中的一个，而使用正则的话，可以一次批量的把所有的正则匹配的内容都替换掉。 实战一：小写数字替换成大写数字123456789101112var str = '今年是2017年'; //var ary = ['零', '壹', '贰', '叁', '肆', '伍', '陆','柒', '捌', '玖', '拾'];// 实现替换的话，需要捕获到数字，并且把数字当作ary的索引获取对应的汉字进行替换str = str.replace(/\\d/g, function () &#123; /* * 第一次执行：大正则捕获的是2，返回的是ary[2] --&gt; '贰' * 第二次执行：大正则捕获的是0，返回的是ary[0] --&gt; '零' * ..... */ return ary[arguments[0]];&#125;);console.log(str);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"js","slug":"技术/js","permalink":"https://www.kaige1220.top/categories/技术/js/"},{"name":"正则表达式","slug":"技术/js/正则表达式","permalink":"https://www.kaige1220.top/categories/技术/js/正则表达式/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.kaige1220.top/tags/正则表达式/"}]},{"title":"CSS 各种用法","slug":"css巧用方法","date":"2018-07-01T02:47:10.432Z","updated":"2018-07-05T12:09:56.131Z","comments":true,"path":"2018/07/01/css巧用方法/","link":"","permalink":"https://www.kaige1220.top/2018/07/01/css巧用方法/","excerpt":"一、CSS写自适应大小的正方形12345678910111213141516171819202122232425262728293031&lt;style type=\"text/css\"&gt;/* 以图片为例background 写法 */ .img&#123; width: 100%; height: 0; padding-bottom: 100%; //关键所在 overflow: hidden; background:url(../res/images/haha.png) center/100% 100% no-repeat; &#125; .img img&#123; width: 100%; &#125;/* img 写法 */ .img&#123; position: relative; width: 100%; height: 0; padding-bottom: 100%; //关键所在 overflow: hidden; &#125; .img img&#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; &#125;&lt;/style&gt;&lt;div class=\"img\"&gt;&lt;/div&gt;","text":"一、CSS写自适应大小的正方形12345678910111213141516171819202122232425262728293031&lt;style type=\"text/css\"&gt;/* 以图片为例background 写法 */ .img&#123; width: 100%; height: 0; padding-bottom: 100%; //关键所在 overflow: hidden; background:url(../res/images/haha.png) center/100% 100% no-repeat; &#125; .img img&#123; width: 100%; &#125;/* img 写法 */ .img&#123; position: relative; width: 100%; height: 0; padding-bottom: 100%; //关键所在 overflow: hidden; &#125; .img img&#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; &#125;&lt;/style&gt;&lt;div class=\"img\"&gt;&lt;/div&gt; 二、多列等高代码： 123456789101112131415161718192021&lt;style type=\"text/css\"&gt; .web_width&#123; width: 100%; overflow: hidden; //关键所在 &#125; .left&#123; float: left; width: 20%; min-height: 10em; background: #66afe9; padding-bottom: 2000px; //关键所在 margin-bottom: -2000px; //关键所在 &#125; .right&#123; float: right; width: 80%; height: 20em; background: #f00; &#125;&lt;/style&gt; padding补偿法 在高度小的元素上加一个数值为正padding-bottom和一个数值为负margin-bottom，再在父级加上overflow: hidden隐藏子元素超出的padding-bottom padding-bottom、margin-bottom之和要等于0（建议值不要太大，够用就行） 三、绘制三角形代码 123456789&lt;style type=\"text/css\"&gt;.demo &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 50px solid red;&#125;&lt;/style&gt; 利用盒模型中的border属性当盒模型的width/height为 0 时，border 边的形状是一个三角形，通过只设置三条边的 border ，并将所绘制的三角形相邻两边的 border 的颜色设置为 transparent, 最后通过调整border-width的比例绘制自己所需要的三角形","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/"},{"name":"css 各种用法","slug":"技术/前端基础知识/css-各种用法","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/css-各种用法/"}],"tags":[{"name":"CSS 各种用法","slug":"CSS-各种用法","permalink":"https://www.kaige1220.top/tags/CSS-各种用法/"}]},{"title":"动画","slug":"动画","date":"2018-07-01T02:10:30.444Z","updated":"2018-07-01T02:45:40.449Z","comments":true,"path":"2018/07/01/动画/","link":"","permalink":"https://www.kaige1220.top/2018/07/01/动画/","excerpt":"","text":"transition 与 animation 的选用元素一旦绑定 transition 之后，会对下个 Event Loop 中变更的样式（如异步 hover 或通过 js 变更 style/class），给予过度效果。要想更细颗粒度定制动画，可为元素添加诸如 animation: keyframeName 1s 的样式，animation 在绑定时立即执行动画。 两者有一些异同之处： transition 需在绑定后的下一个 Event Loop 中实现动画，而 animation 在当时立即执行，因此，transition 常用于反复执行的场合，如 hover、toggle 等 animation 在绑定时候立即执行，执行完会默认恢复到原态，所以在 0% 帧和 100% 帧处可能有跳变，如果加上 animation-fill-mode: forwards 属性，会保持 100% 帧的，像 transition 动画那样。因此在串联执行多个 animation 动画时，常用 forwards 来保持连贯，避免每次都要“重头再来”。 两者都可在后续的 Event Loop 中修改样式，触发动画 animation 中省略样式的帧animation 在时间粒度上的操控更灵活，可以通过 % 来定义特定时间帧。我们先来看一个案例，其中 color 样式并未在 0% 帧定义。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"css","slug":"技术/css","permalink":"https://www.kaige1220.top/categories/技术/css/"},{"name":"动画","slug":"技术/css/动画","permalink":"https://www.kaige1220.top/categories/技术/css/动画/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.kaige1220.top/tags/css/"},{"name":"动画","slug":"动画","permalink":"https://www.kaige1220.top/tags/动画/"}]},{"title":"promise","slug":"promise理解","date":"2018-06-30T12:54:39.177Z","updated":"2018-07-05T12:18:59.598Z","comments":true,"path":"2018/06/30/promise理解/","link":"","permalink":"https://www.kaige1220.top/2018/06/30/promise理解/","excerpt":"","text":"待更新！","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"js","slug":"技术/js","permalink":"https://www.kaige1220.top/categories/技术/js/"},{"name":"promise","slug":"技术/js/promise","permalink":"https://www.kaige1220.top/categories/技术/js/promise/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.kaige1220.top/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://www.kaige1220.top/tags/promise/"}]},{"title":"编码规范","slug":"编码规范","date":"2018-06-30T03:44:40.091Z","updated":"2018-06-30T12:13:12.836Z","comments":true,"path":"2018/06/30/编码规范/","link":"","permalink":"https://www.kaige1220.top/2018/06/30/编码规范/","excerpt":"一定要培养自己好的编码习惯！","text":"一定要培养自己好的编码习惯！ 一、命名规范项目命名全部采用小写方式， 以下划线分隔。 例：my_project_name 目录命名参照项目命名规则； 有复数结构时，要采用复数命名法。 例：scripts, styles, images, data_models JS文件命名参照项目命名规则。 例：account_model.js CSS, SCSS文件命名参照项目命名规则。 例：retina_sprites.scss HTML文件命名参照项目命名规则。 例：error_report.html 二、html语法语法 缩进使用soft tab（4个空格）； 嵌套的节点应该缩进； 在属性上，使用双引号，不要使用单引号； 属性名全小写，用中划线做分隔符； 不要在自动闭合标签结尾处使用斜线（HTML5 规范 指出他们是可选的）； 不要忽略可选的关闭标签，例：&lt;/li&gt; 和 &lt;/body&gt;。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Page title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"images/company_logo.png\" alt=\"Company\"&gt; &lt;h1 class=\"hello-world\"&gt;Hello, world!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; HTML5 doctype在页面开头使用这个简单地doctype来启用标准模式，使其在每个浏览器中尽可能一致的展现； 虽然doctype不区分大小写，但是按照惯例，doctype大写 1234&lt;!DOCTYPE html&gt;&lt;html&gt; ...&lt;/html&gt; lang属性根据HTML5规范： 应在html标签上加上lang属性。这会给语音工具和翻译工具帮助，告诉它们应当怎么去发音和翻译。 1234&lt;!DOCTYPE html&gt;&lt;html lang=\"en-us\"&gt; ...&lt;/html&gt; 字符编码通过声明一个明确的字符编码，让浏览器轻松、快速的确定适合网页内容的渲染方式，通常指定为’UTF-8’。 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; ...&lt;/html&gt; IE兼容模式用 &lt;meta&gt; 标签可以指定页面应该用什么版本的IE来渲染； 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt; &lt;/head&gt; ...&lt;/html&gt; 引入CSS, JS根据HTML5规范, 通常在引入CSS和JS时不需要指明 type，因为 text/css 和 text/javascript 分别是他们的默认值。 属性顺序属性应该按照特定的顺序出现以保证易读性； classidnamedata-src, for, type, href, value , max-length, max, min, patternplaceholder, title, altaria-, rolerequired, readonly, disabledclass是为高可复用组件设计的，所以应处在第一位； id更加具体且应该尽量少使用，所以将它放在第二位。 减少标签数量在编写HTML代码时，需要尽量避免多余的父节点； 很多时候，需要通过迭代和重构来使HTML变得更少。 1234567&lt;!-- Not well --&gt;&lt;span class=\"avatar\"&gt; &lt;img src=\"...\"&gt;&lt;/span&gt;&lt;!-- Better --&gt;&lt;img class=\"avatar\" src=\"...\"&gt; 三、css scss缩进使用soft tab（4个空格）。 123456789.element &#123; position: absolute; top: 10px; left: 10px; border-radius: 10px; width: 50px; height: 50px;&#125; 分号每个属性声明末尾都要加分号。 空格以下几种情况不需要空格： 属性名后多个规则的分隔符’,’前!important ‘!’后属性值中’(‘后和’)’前行末不要有多余的空格以下几种情况需要空格： 属性值前选择器’&gt;’, ‘+’, ‘~’前后‘{‘前!important ‘!’前@else 前后属性值中的’,’后注释’/‘后和’/‘前 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* not good */.element &#123; color :red! important; background-color: rgba(0,0,0,.5);&#125;/* good */.element &#123; color: red !important; background-color: rgba(0, 0, 0, .5);&#125;/* not good */.element ,.dialog&#123; ...&#125;/* good */.element,.dialog &#123;&#125;/* not good */.element&gt;.dialog&#123; ...&#125;/* good */.element &gt; .dialog&#123; ...&#125;/* not good */.element&#123; ...&#125;/* good */.element &#123; ...&#125;/* not good */@if&#123; ...&#125;@else&#123; ...&#125;/* good */@if &#123; ...&#125; @else &#123; ...&#125; 空行以下几种情况需要空行： 文件最后保留一个空行‘}’后最好跟一个空行，包括scss中嵌套的规则属性之间需要适当的空行，具体见属性声明顺序 1234567891011121314151617181920212223/* not good */.element &#123; ...&#125;.dialog &#123; color: red; &amp;:after &#123; ... &#125;&#125;/* good */.element &#123; ...&#125;.dialog &#123; color: red; &amp;:after &#123; ... &#125;&#125; 换行以下几种情况不需要换行： ‘{‘前以下几种情况需要换行： ‘{‘后和’}’前每个属性独占一行多个规则的分隔符’,’后 123456789101112131415161718192021/* not good */.element&#123;color: red; background-color: black;&#125;/* good */.element &#123; color: red; background-color: black;&#125;/* not good */.element, .dialog &#123; ...&#125;/* good */.element,.dialog &#123; ...&#125; 注释注释统一用’/ /‘（scss中也不要用’//‘），具体参照右边的写法； 缩进与下一行代码保持一致； 可位于一个代码行的末尾，与代码间隔一个空格。 12345678910111213141516171819/* Modal header */.modal-header &#123; ...&#125;/* * Modal header */.modal-header &#123; ...&#125;.modal-header &#123; /* 50px */ width: 50px; color: red; /* color red */&#125; 引号最外层统一使用双引号； url的内容要用引号； 属性选择器中的属性值需要引号。 123456789.element:after &#123; content: \"\"; background-image: url(\"logo.png\");&#125;li[data-type=\"single\"] &#123; ...&#125; 命名类名使用小写字母，以中划线分隔id采用驼峰式命名scss中的变量、函数、混合、placeholder采用驼峰式命名 123456789101112131415161718192021222324252627/* class */.element-content &#123; ...&#125;/* id */#myDialog &#123; ...&#125;/* 变量 */$colorBlack: #000;/* 函数 */@function pxToRem($px) &#123; ...&#125;/* 混合 */@mixin centerBlock &#123; ...&#125;/* placeholder */%myDialog &#123; ...&#125; 属性声明顺序相关的属性声明按右边的顺序做分组处理，组之间需要有一个空行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331.declaration-order &#123; display: block; float: right; position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; border: 1px solid #e5e5e5; border-radius: 3px; width: 100px; height: 100px; font: normal 13px \"Helvetica Neue\", sans-serif; line-height: 1.5; text-align: center; color: #333; background-color: #f5f5f5; opacity: 1;&#125;// 下面是推荐的属性的顺序[ [ \"display\", \"visibility\", \"float\", \"clear\", \"overflow\", \"overflow-x\", \"overflow-y\", \"clip\", \"zoom\" ], [ \"table-layout\", \"empty-cells\", \"caption-side\", \"border-spacing\", \"border-collapse\", \"list-style\", \"list-style-position\", \"list-style-type\", \"list-style-image\" ], [ \"-webkit-box-orient\", \"-webkit-box-direction\", \"-webkit-box-decoration-break\", \"-webkit-box-pack\", \"-webkit-box-align\", \"-webkit-box-flex\" ], [ \"position\", \"top\", \"right\", \"bottom\", \"left\", \"z-index\" ], [ \"margin\", \"margin-top\", \"margin-right\", \"margin-bottom\", \"margin-left\", \"-webkit-box-sizing\", \"-moz-box-sizing\", \"box-sizing\", \"border\", \"border-width\", \"border-style\", \"border-color\", \"border-top\", \"border-top-width\", \"border-top-style\", \"border-top-color\", \"border-right\", \"border-right-width\", \"border-right-style\", \"border-right-color\", \"border-bottom\", \"border-bottom-width\", \"border-bottom-style\", \"border-bottom-color\", \"border-left\", \"border-left-width\", \"border-left-style\", \"border-left-color\", \"-webkit-border-radius\", \"-moz-border-radius\", \"border-radius\", \"-webkit-border-top-left-radius\", \"-moz-border-radius-topleft\", \"border-top-left-radius\", \"-webkit-border-top-right-radius\", \"-moz-border-radius-topright\", \"border-top-right-radius\", \"-webkit-border-bottom-right-radius\", \"-moz-border-radius-bottomright\", \"border-bottom-right-radius\", \"-webkit-border-bottom-left-radius\", \"-moz-border-radius-bottomleft\", \"border-bottom-left-radius\", \"-webkit-border-image\", \"-moz-border-image\", \"-o-border-image\", \"border-image\", \"-webkit-border-image-source\", \"-moz-border-image-source\", \"-o-border-image-source\", \"border-image-source\", \"-webkit-border-image-slice\", \"-moz-border-image-slice\", \"-o-border-image-slice\", \"border-image-slice\", \"-webkit-border-image-width\", \"-moz-border-image-width\", \"-o-border-image-width\", \"border-image-width\", \"-webkit-border-image-outset\", \"-moz-border-image-outset\", \"-o-border-image-outset\", \"border-image-outset\", \"-webkit-border-image-repeat\", \"-moz-border-image-repeat\", \"-o-border-image-repeat\", \"border-image-repeat\", \"padding\", \"padding-top\", \"padding-right\", \"padding-bottom\", \"padding-left\", \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\" ], [ \"font\", \"font-family\", \"font-size\", \"font-weight\", \"font-style\", \"font-variant\", \"font-size-adjust\", \"font-stretch\", \"font-effect\", \"font-emphasize\", \"font-emphasize-position\", \"font-emphasize-style\", \"font-smooth\", \"line-height\", \"text-align\", \"-webkit-text-align-last\", \"-moz-text-align-last\", \"-ms-text-align-last\", \"text-align-last\", \"vertical-align\", \"white-space\", \"text-decoration\", \"text-emphasis\", \"text-emphasis-color\", \"text-emphasis-style\", \"text-emphasis-position\", \"text-indent\", \"-ms-text-justify\", \"text-justify\", \"letter-spacing\", \"word-spacing\", \"-ms-writing-mode\", \"text-outline\", \"text-transform\", \"text-wrap\", \"-ms-text-overflow\", \"text-overflow\", \"text-overflow-ellipsis\", \"text-overflow-mode\", \"-ms-word-wrap\", \"word-wrap\", \"-ms-word-break\", \"word-break\" ], [ \"color\", \"background\", \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader\", \"background-color\", \"background-image\", \"background-repeat\", \"background-attachment\", \"background-position\", \"-ms-background-position-x\", \"background-position-x\", \"-ms-background-position-y\", \"background-position-y\", \"-webkit-background-clip\", \"-moz-background-clip\", \"background-clip\", \"background-origin\", \"-webkit-background-size\", \"-moz-background-size\", \"-o-background-size\", \"background-size\" ], [ \"outline\", \"outline-width\", \"outline-style\", \"outline-color\", \"outline-offset\", \"opacity\", \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity\", \"-ms-filter:\\\\'progid:DXImageTransform.Microsoft.Alpha\", \"-ms-interpolation-mode\", \"-webkit-box-shadow\", \"-moz-box-shadow\", \"box-shadow\", \"filter:progid:DXImageTransform.Microsoft.gradient\", \"-ms-filter:\\\\'progid:DXImageTransform.Microsoft.gradient\", \"text-shadow\" ], [ \"-webkit-transition\", \"-moz-transition\", \"-ms-transition\", \"-o-transition\", \"transition\", \"-webkit-transition-delay\", \"-moz-transition-delay\", \"-ms-transition-delay\", \"-o-transition-delay\", \"transition-delay\", \"-webkit-transition-timing-function\", \"-moz-transition-timing-function\", \"-ms-transition-timing-function\", \"-o-transition-timing-function\", \"transition-timing-function\", \"-webkit-transition-duration\", \"-moz-transition-duration\", \"-ms-transition-duration\", \"-o-transition-duration\", \"transition-duration\", \"-webkit-transition-property\", \"-moz-transition-property\", \"-ms-transition-property\", \"-o-transition-property\", \"transition-property\", \"-webkit-transform\", \"-moz-transform\", \"-ms-transform\", \"-o-transform\", \"transform\", \"-webkit-transform-origin\", \"-moz-transform-origin\", \"-ms-transform-origin\", \"-o-transform-origin\", \"transform-origin\", \"-webkit-animation\", \"-moz-animation\", \"-ms-animation\", \"-o-animation\", \"animation\", \"-webkit-animation-name\", \"-moz-animation-name\", \"-ms-animation-name\", \"-o-animation-name\", \"animation-name\", \"-webkit-animation-duration\", \"-moz-animation-duration\", \"-ms-animation-duration\", \"-o-animation-duration\", \"animation-duration\", \"-webkit-animation-play-state\", \"-moz-animation-play-state\", \"-ms-animation-play-state\", \"-o-animation-play-state\", \"animation-play-state\", \"-webkit-animation-timing-function\", \"-moz-animation-timing-function\", \"-ms-animation-timing-function\", \"-o-animation-timing-function\", \"animation-timing-function\", \"-webkit-animation-delay\", \"-moz-animation-delay\", \"-ms-animation-delay\", \"-o-animation-delay\", \"animation-delay\", \"-webkit-animation-iteration-count\", \"-moz-animation-iteration-count\", \"-ms-animation-iteration-count\", \"-o-animation-iteration-count\", \"animation-iteration-count\", \"-webkit-animation-direction\", \"-moz-animation-direction\", \"-ms-animation-direction\", \"-o-animation-direction\", \"animation-direction\" ], [ \"content\", \"quotes\", \"counter-reset\", \"counter-increment\", \"resize\", \"cursor\", \"-webkit-user-select\", \"-moz-user-select\", \"-ms-user-select\", \"user-select\", \"nav-index\", \"nav-up\", \"nav-right\", \"nav-down\", \"nav-left\", \"-moz-tab-size\", \"-o-tab-size\", \"tab-size\", \"-webkit-hyphens\", \"-moz-hyphens\", \"hyphens\", \"pointer-events\" ]] 颜色颜色16进制用小写字母； 颜色16进制尽量用简写。 123456789101112/* not good */.element &#123; color: #ABCDEF; background-color: #001122;&#125;/* good */.element &#123; color: #abcdef; background-color: #012;&#125; 属性简写属性简写需要你非常清楚属性值的正确顺序，而且在大多数情况下并不需要设置属性简写中包含的所有值，所以建议尽量分开声明会更加清晰； margin 和 padding 相反，需要使用简写； 常见的属性简写包括： font background transition animation 媒体查询尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部，这样做只会让大家以后更容易忘记他们。 1234567891011121314151617.element &#123; ...&#125;.element-avatar&#123; ...&#125;@media (min-width: 480px) &#123; .element &#123; ... &#125; .element-avatar &#123; ... &#125;&#125; 杂项 不允许有空的规则； 元素选择器用小写字母； 去掉小数点前面的0； 去掉数字中不必要的小数点和末尾的0； 属性值’0’后面不要加单位； 同个属性不同前缀的写法需要在垂直方向保持对齐，具体参照右边的写法； 无前缀的标准属性应该写在有前缀的属性后面； 不要在同个规则里出现重复的属性，如果重复的属性是连续的则没关系； 不要在一个文件里出现两个相同的规则； 用 border: 0; 代替 border: none;； 选择器不要超过4层（在scss中如果超过4层应该考虑用嵌套的方式来写）； 发布的代码中不要有 @import； 尽量少用’*’选择器。 JavaScript缩进使用soft tab（4个空格）。 123456789var x = 1, y = 1;if (x &lt; y) &#123; x += 10;&#125; else &#123; x += 1;&#125; 分号以下几种情况后需加分号： 变量声明 表达式 return throw break continue do-while 12345678910/* var declaration */var x = 1;/* expression statement */x++;/* do-while */do &#123; x++;&#125; while (x &lt; 10); 空格以下几种情况不需要空格： 对象的属性名后 前缀一元运算符后 后缀一元运算符前 函数调用括号前 无论是函数声明还是函数表达式，’(‘前不要空格 数组的’[‘后和’]’前 对象的’{‘后和’}’前 运算符’(‘后和’)’前 以下几种情况需要空格： 二元运算符前后 三元运算符’?:’前后 代码块’{‘前 下列关键字前：else, while, catch, finally 下列关键字后：if, else, for, while, do, switch, case, try, catch, finally, with, return, typeof 单行注释’//‘后（若单行注释和代码同行，则’//‘前也需要），多行注释’*’后 对象的属性值前 for循环，分号后留有一个空格，前置条件如果有多个，逗号后留一个空格 无论是函数声明还是函数表达式，’{‘前一定要有空格 函数的参数之间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// not goodvar a = &#123; b :1&#125;;// goodvar a = &#123; b: 1&#125;;// not good++ x;y ++;z = x?1:2;// good++x;y++;z = x ? 1 : 2;// not goodvar a = [ 1, 2 ];// goodvar a = [1, 2];// not goodvar a = ( 1+2 )*3;// goodvar a = (1 + 2) * 3;// no space before '(', one space before '&#123;', one space between function parametersvar doSomething = function(a, b, c) &#123; // do something&#125;;// no space before '('doSomething(item);// not goodfor(i=0;i&lt;6;i++)&#123; x++;&#125;// goodfor (i = 0; i &lt; 6; i++) &#123; x++;&#125; 空行以下几种情况需要空行： 变量声明后（当变量声明在代码块的最后一行时，则无需空行） 注释前（当注释在代码块的第一行时，则无需空行） 代码块后（在函数调用、数组、对象中则无需空行） 文件最后保留一个空行 换行换行的地方，行末必须有’,’或者运算符； 以下几种情况不需要换行： 下列关键字后：else, catch, finally代码块’{‘前以下几种情况需要换行： 代码块’{‘后和’}’前变量赋值后 单行注释双斜线后，必须跟一个空格； 缩进与下一行代码保持一致； 可位于一个代码行的末尾，与代码间隔一个空格 多行注释最少三行, ‘*’后跟一个空格，具体参照右边的写法； 建议在以下情况下使用： 难于理解的代码段可能存在错误的代码段浏览器特殊的HACK代码业务逻辑强相关的代码 1234/* * one space after '*' */var x = 1; 引号最外层统一使用单引号。 123456// not goodvar x = \"test\";// goodvar y = 'foo', z = '&lt;div id=\"test\"&gt;&lt;/div&gt;'; 变量命名标准变量采用驼峰式命名（除了对象的属性外，主要是考虑到cgi返回的数据） ‘ID’在变量名中全大写 ‘URL’在变量名中全大写 ‘Android’在变量名中大写第一个字母 ‘iOS’在变量名中小写第一个，大写后两个字母 常量全大写，用下划线连接 构造函数，大写第一个字母 jquery对象必须以’$’开头命名 123456789101112131415161718192021var thisIsMyName;var goodID;var reportURL;var AndroidVersion;var iOSVersion;var MAX_COUNT = 10;function Person(name) &#123; this.name = name;&#125;// not goodvar body = $('body');// goodvar $body = $('body'); 变量声明一个函数作用域中所有的变量声明尽量提到函数首部，用一个var声明，不允许出现两个连续的var声明。 1234567891011function doSomethingWithItems(items) &#123; // use one var var value = 10, result = value + 10, i, len; for (i = 0, len = items.length; i &lt; len; i++) &#123; result += 10; &#125;&#125; 函数无论是函数声明还是函数表达式，’(‘前不要空格，但’{‘前一定要有空格； 函数调用括号前不需要空格； 立即执行函数外必须包一层括号； 不要给inline function命名； 参数之间用’, ‘分隔，注意逗号后有一个空格。 数组、对象对象属性名不需要加引号； 对象以缩进的形式书写，不要写在一行； 数组、对象最后不要有逗号。 1234567891011121314151617// not goodvar a = &#123; 'b': 1&#125;;var a = &#123;b: 1&#125;;var a = &#123; b: 1, c: 2,&#125;;// goodvar a = &#123; b: 1, c: 2&#125;; 括号下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。 null适用场景： 初始化一个将来可能被赋值为对象的变量 与已经初始化的变量做比较 作为一个参数为对象的函数的调用传参 作为一个返回对象的函数的返回值 不适用场景： 不要用null来判断函数调用时有无传参 不要与未初始化的变量做比较 undefined永远不要直接使用undefined进行变量判断； 使用typeof和字符串’undefined’对变量进行判断。 123456789// not goodif (person === undefined) &#123; ...&#125;// goodif (typeof person === 'undefined') &#123; ...&#125; jshint用’===’, ‘!==’代替’==’, ‘!=’； for-in里一定要有hasOwnProperty的判断； 不要在内置对象的原型上添加方法，如Array, Date； 不要在内层作用域的代码里声明了变量，之后却访问到了外层作用域的同名变量； 变量不要先使用后声明； 不要在一句代码中单单使用构造函数，记得将其赋值给某个变量； 不要在同个作用域下声明同名变量； 不要在一些不需要的地方加括号，例：delete(a.b)； 不要使用未声明的变量（全局变量需要加到.jshintrc文件的globals属性里面）； 不要声明了变量却不使用； 不要在应该做比较的地方做赋值； debugger不要出现在提交的代码里； 数组中不要存在空元素； 不要在循环内部声明函数； 不要像这样使用构造函数，例：new function () { … }, new Object； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// not goodif (a == 1) &#123; a++;&#125;// goodif (a === 1) &#123; a++;&#125;// goodfor (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // be sure that obj[key] belongs to the object and was not inherited console.log(obj[key]); &#125;&#125;// not goodArray.prototype.count = function(value) &#123; return 4;&#125;;// not goodvar x = 1;function test() &#123; if (true) &#123; var x = 0; &#125; x += 1;&#125;// not goodfunction test() &#123; console.log(x); var x = 1;&#125;// not goodnew Person();// goodvar person = new Person();// not gooddelete(obj.attr);// gooddelete obj.attr;// not goodif (a = 10) &#123; a++;&#125;// not goodvar a = [1, , , 2, 3];// not goodvar nums = [];for (var i = 0; i &lt; 10; i++) &#123; (function(i) &#123; nums[i] = function(j) &#123; return i + j; &#125;; &#125;(i));&#125;// not goodvar singleton = new function() &#123; var privateVar; this.publicMethod = function() &#123; privateVar = 1; &#125;; this.publicMethod2 = function() &#123; privateVar = 2; &#125;;&#125;; 杂项不要混用tab和space； 不要在一处使用多个tab或space； 换行符统一用’LF’； 对上下文this的引用只能使用’_this’, ‘that’, ‘self’其中一个来命名； 行尾不要有空白字符； switch的falling through和no default的情况一定要有注释特别说明； 不允许有空的代码块。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"编码规范","slug":"技术/编码规范","permalink":"https://www.kaige1220.top/categories/技术/编码规范/"}],"tags":[{"name":"编码规范","slug":"编码规范","permalink":"https://www.kaige1220.top/tags/编码规范/"}]},{"title":"javascript基础知识整理","slug":"js学习系列","date":"2018-06-28T05:18:11.903Z","updated":"2018-06-30T03:05:51.476Z","comments":true,"path":"2018/06/28/js学习系列/","link":"","permalink":"https://www.kaige1220.top/2018/06/28/js学习系列/","excerpt":"一、基础语法：变量标示符变量的命名var _name = null;var $name = null;var name0 = null; 关键字与保留字JavaScript 在语言定义中保留的字段，这些字段在语言使用中存在特殊意义或功能，在程序编写的过程中不可以当做变量或函数名称使用。无需记忆，报错修改即可。 字符敏感字符串的大小写是有所区分的，不同字符指代不同的变量。","text":"一、基础语法：变量标示符变量的命名var _name = null;var $name = null;var name0 = null; 关键字与保留字JavaScript 在语言定义中保留的字段，这些字段在语言使用中存在特殊意义或功能，在程序编写的过程中不可以当做变量或函数名称使用。无需记忆，报错修改即可。 字符敏感字符串的大小写是有所区分的，不同字符指代不同的变量。 严格模式使用方法1234567891011&lt;!-- 全局使用 严格 模式 --&gt;\"use strict\";(function()&#123; console.log('&gt;&gt;&gt; Hello, world!');&#125;)()&lt;!-- 或者在函数内部声明使用 严格 模式 --&gt;(function()&#123; \"use strict\"; console.log('&gt;&gt;&gt; Hello, world!');&#125;)() 类型系统javascript 类型系统可以分为标准类型和对象类型，进一步标准类型又可以分为原始类型和引用类型，而对象类型又可以分为内置对象类型、普通对象类型、自定义对象类型。 标准类型标准类型共包括了6个分别是： 原始类型（值类型）： Undefined undefined Null null Boolean true String ‘hello’ Number 123 引用类型（对象类型）：Object 123456var obj = &#123;&#125;;&lt;!-- 原始类型变量的包装类型如下 --&gt;var bool = new Boolean(true);var str = new String(\"hello\");var num = new Number(1);var obj0 = new Object(); 原始类型和引用类型的区别： 原始类型储存在栈（Stack）中储存变量的值，而引用类型在栈中保存的是所引用内容储存在堆（Heap）中的值。类似于指针的概念，引用类型并非储存变量真实数值而是地址，所以对已引用类型的复制其实只是复制了相同的地址而非实际的变量值。 Undefined 值：undefined 出现场景： 以声明为赋值的变量 var obj; 获取对象不存在的属性 var obj = {x: 0}; obj.y; 无返回值函数的执行结果 function f(){}; var obj = f(); 函数参数没有传入 function f(i){console.log(i)}; f(); void(expression) Null 值：null 出现场景： 获取不存在的对象 document.getElementById(‘not-exist-element’) Boolean 值：true, false 出现场景： 条件语句导致的系统执行的隐式类型转换 if(隐式转换){} 字面量或变量定义 var bool = true; String 值：字符串 出现场景： var str = ‘Hello, world!’; Number 值：整型直接量，八进制直接量（0-），十六进制直接量（0x-)，浮点型直接量 出现场景： 1026 3.14 1.2e5 0x10 Object 值：属性集合 出现场景： var obj = {name: ‘Xinyang’}; 类型识别 typeof Object.prototype.toString constructor instanceof typeof：可以是标准类型（Null 除外）不可识别具体的对象类型（Function 除外） Object.prototype.toString：可识别标准类型及内置对象类型（例如，Object, Date, Array）不能识别自定义对象类型 constructor：可以识别标准类型（Undefined/Null 除外）可识别内置对象类型可识别自定义对象类型 1234function getConstructiorName(obj) &#123; return obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor.toString().match(/function\\s*([^(]*)/)[1];&#125;getConstructiorName([]) === \"Array\"; // true instanceof：不可判别原始类型可判别内置对象类型可判别自定义对象类型 类型判断avaScript的数据类型可以分为：标准类型和对象类型。标准类型有：undefined Null Boolean Date Number Object对象类型（构造器类型）：Boolean Date Number Object Array Date Error Function RegExp 下面我们写一个HTML来检验一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&lt;html&gt;&lt;head&gt; &lt;title&gt;JavaScript类型判断&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style type=\"text/css\"&gt; .red&#123; background-color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; /* Standard Type */ var a; //undefined var b = document.getElementById(\"no_exist_element\"); //null var c = true; //Boolean var d = 1; //Number var e = \"str\"; //String var f = &#123;name : \"Tom\"&#125;; //Object /* Object Type */ var g = new Boolean(true); //Boolean Object var h = new Number(1); //Number Object var i = new String(\"str\"); //String Object var j = new Object(&#123;name : \"Tom\"&#125;); //Object Object var k = new Array([1, 2, 3, 4]); //Array Object var l = new Date(); //Date Object var m = new Error(); var n = new Function(); var o = new RegExp(\"\\\\d\"); /* Self-Defined Object Type */ function Point(x, y) &#123; this.x = x; this.y = y; &#125; Point.prototype.move = function(x, y) &#123; this.x += x; this.y += y; &#125; var p = new Point(1, 2); /* Use the Prototype.toString() to judge the type */ function type(obj)&#123; return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase(); &#125; &lt;/script&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;typeof&lt;/td&gt; &lt;td&gt;toString&lt;/td&gt; &lt;td&gt;constructor&lt;/td&gt; &lt;td&gt;instanceof&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;undefined&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof a)&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(a))&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(a.constructor)&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(a instanceof \"undefined\")&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Null&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof b);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(b));&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(b.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(b instanceof \"null\");&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Boolean&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof c);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(c));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(c.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(c instanceof \"boolean\");&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Number&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof d);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(d));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(d.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(d instanceof \"number\");&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;String&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof e);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(e));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(e.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(e instanceof \"string\");&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Object&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof f);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(f));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(f.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(f instanceof \"object\");&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td colspan=\"5\"&gt;-----------------------&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Boolean Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof g);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(g));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(g.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(g instanceof Boolean);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Number Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof h);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(h));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(h.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(h instanceof Number);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;String Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof i);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(i));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(i.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(i instanceof String);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Object Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof j);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(j));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(j.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(j instanceof Object);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Array Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof k);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(k));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(k.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(k instanceof Array);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Date Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof l);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(l));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(l.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(l instanceof Date);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Error Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof m);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(m));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(m.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(m instanceof Error);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Function Object&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof n);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(n));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(n.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(n instanceof Function);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;RegExp Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof o);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(o));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(o.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(o instanceof RegExp);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td colspan=\"5\"&gt;-----------------------&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Point Objct&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof p);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(p));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(p.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(p instanceof Point);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 执行的结果如下： 内置对象通常情况下只有对象才存在方法，但 JavaScript 不同它具有12种内置对象。内置对象又分为两类，普通对象（属性和方法）与构造器对象（可用于实例化普通对象，它还包含原型对象属性和方法，及实例对象属性和方法）。 JavaScript 对象原型链的简要说明 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.move = function(x, y) &#123; this.x += x; this.y += y;&#125;var p = new Point(1, 1);p.move(2,2); __proto__ 称之为原型链，有如下特点： __proto__为对象内部的隐藏属性 __proto__ 为实例化该对象的构造器的 prototype 对象的引用，因此可以直接方法 prototype 的所有属性和方法 除了 Object 每个对象都有一个 __proto__ 属性且逐级增长形成一个链，原型链顶端是一个 Object 对象。 在调用属性或方法时，引擎会查找自身的属性如果没有则会继续沿着原型链逐级向上查找，直到找到该方法并调用。 __proto__ 跟浏览器引擎实现相关，不同的引擎中名字和实现不尽相同(chrome、firefox中名称是 __proto__ ，并且可以被访问到，IE中无法访问)。基于代码兼容性、可读性等方面的考虑，不建议开发者显式访问 __proto__ 属性或通过 proto更改原型链上的属性和方法，可以通过更改构造器prototype 对象来更改对象的 __proto__ 属性。构造器对象与普通对象的区别 构造器对象与普通对象的区别 构造器对象原型链中的 proto 是一个 Function.prototype 对象的引用，因此可以调用 Function.prototype的属性及方 法 构造器对象本身有一个 prototype 属性，用该构造器实例化对象时该 prototype 会被实例对象的 proto 所引用 构造器对象本身是一个 function 对象，因此也会有自身属性 标准内置对象构造器对象 Object Boolean String Number Function Array RegExp Date Error 其他对象 Math JSON 全局对象 内置对象，其实也叫内置构造器，它们可以通过 new 的方式创建一个新的实例对象。内置对象所属的类型就叫内置对象类型。其声明方式如下： 12345678910var i = new String(\"str\"); // String Objectvar h = new Number(1); // Number Objectvar g = new Boolean(true); // Boolean Objectvar j = new Object(&#123;name : \"Tom\"&#125;); // Object Objectvar k = new Array([1, 2, 3, 4]); // Array Objectvar l = new Date(); // Date Objectvar m = new Error();var n = new Function();var o = new RegExp(\"\\\\d\"); 虽然标准类型中有Boolean String Number Object，内置对象类型中也有Boolean String Number Object，但它们其实是通过不同的声明方式来进行区别的。标准类型通过直接赋值，而对象类型则是通过构造器实现初始化 Object构造器的原型对象在对象实例化时将会被添加到实例对象的原型链当中。__proto__为原型链属性，编码时不可被显像调用。但是实例化对象可以调用原型链上的方法。用 String/Number 等构造器创建的对象原型链顶端对象始终是一个Object对象，因此这些对象可以调用Object的原型对象属性和方法。所以 String/Number 等构造器是 Object 的子类。 构造器说明：Object 是属性和方法的集合String/Number/Boolean/Array/Date/Error 构造器均为 Object 的子类并集成 Object 原型对象的属性及方法。 实例化方法123var obj0 = new Object(&#123;name: 'X', age: 13&#125;);// 常用方法var obj1 = &#123;name: 'Q', age: 14&#125;; 属性及方法 prototype create keys … **原型对象属性及其方法 constructor toString valueOf hasOwnProperty … Object.create功能：基于原型对象创造新对象 123// Object.create(prototype[, propertiesObject])var prototype = &#123;name: 'X', age: 13&#125;;var obj = Object.create(proto); Object.prototype.toString功能：获取方法调用者的标准类型 123// objectInstance.toString()var obj = &#123;&#125;;obj.toString(); // Object Object.prototype.hasOwnProperty功能：判断一个属性是否是一个对象的自身属性 12345// objectInstance.hasOwnProperty(\"propertyName\")var obj = Object.create(&#123;a: 1, b: 2&#125;);obj.c = 3;obj.hasOwnProperty('a'); // falseobj.hasOwnProperty('c'); // true String构造器说明：单双引号内的字符串实例化方法123'Hello, world!'var str0 = 'Xinyang';var str1 = new String('Xinyang'); 属性及方法 prototype fromCharCode（转换 ASCII 代码为字符） 原型对象属性及其方法 constructor indexOf replace slice split charCodeAt toLowerCase String.prototype.indexOf功能：获取子字符串在字符串中的索引12345// stringObject.indexOf(searchValue, fromIndex)var str = \"I am X. From China!\";var index = str.indexOf('a'); // 2str.indexOf('a', index + 1); // 16str.indexOf('Stupid'); // -1 字符串不存在 String.prototype.replace功能：查找字符串替换成目标文字123// stringObject.replace(regexp/substr, replacement)var str = \"apple is bad\";str = str.replace('bad', 'awesome'); String.prototype.split功能：按分隔符将分隔符分成字符串数组 12345// stringObject.split(separator, arrayLength)var str = '1 2 3 4';str.split(' '); // ['1', '2', '3', '4'];str.split(' ', 3); // ['1', '2', '3'];str.split(/\\d+/); // [\"\", \" \", \" \", \" \", \"\"] Number构造器说明：整型直接量，八进制直接量（0-），十六进制直接量（0x-)，浮点型直接量实例化方法 1234101.2e5var count = 0x10;var pi = new Number(3.1415); 属性及方法 prototype MAX_VALUE MIN_VALUE NaN NEGATIVE_INFINITY POSITIVE_INFINITY 原型对象属性及其方法 constructor toFixed toExponential … Number.prototype.toFixed功能：四舍五入至指定小数位 12345// numberObject.toFixed(num)var num0 = 3.14;num0.toFixed(1); // 3.1var num1 = 3.35;num1.toFixed(1); // 3.4 Array构造器说明：定义数组对象实例化方法 123var a0 = [1, 'abc', true, function()&#123;&#125;];var a1 = new Array();var a2 = new Array(1, 'abc', true); 属性及方法 prototype isArray 原型对象属性及其方法 constructor splice forEach find concat pop push reverse shift slice … Array.prototype.splice 功能：从数组中删除或添加元素，返回被删除的元素列表（作用域原有数组） 1234// arrayObject.splice(start, deleteCount[, item1[, item2[, ...]]])var arr = ['1', '2', 'a', 'b', '6'];var ret = arr.splice(2, 2, '3', '4', '5'); // ['a', 'b']arr; // ['1', '2', '3', '4', 5', '6'] Function…….. DOM编程节点操作获取节点父子关系 element.parentNode element.firstChild/ element.lastChild element.childNodes/ element.children 兄弟关系 element.previousSibling/ element.nextSibling element.previousElementSibling/ element.nextElementSibling 通过节点直接的关系获取节点会导致代码维护性大大降低（节点之间的关系变化会直接影响到获取节点），而通过接口则可以有效的解决此问题。 接口获取元素节点 getElementById getElementsByTagName getElementsByClassName querySelector querySelectorAll 创建节点创建节点 -&gt; 设置属性 -&gt; 插入节点1var element = document.createElement('tagName'); 修改节点textContent获取或设置节点以及其后代节点的文本内容（对于节点中的所有文本内容）。 12element.textContent; // 获取element.textContent = 'New Content'; innerText （不符合 W3C 规范）获取或设置节点以及节点后代的文本内容。其作用于 textContent 几乎一致。1element.innerText; 插入节点appendChild在指定的元素内追加一个元素节点。var aChild = element.appendChild(aChild); insertBefore在指定元素的指定节点前插入指定的元素。var aChild = element.insertBefore(aChild, referenceChild); 删除节点删除指定的节点的子元素节点。var child = element.removeChild(child); innerHTML获取或设置指定节点之中所有的 HTML 内容。替换之前内部所有的内容并创建全新的一批节点（去除之前添加的事件和样式）。innerHTML 不检查内容，直接运行并替换原先的内容。 只建议在创建全新的节点时使用。不可在用户可控的情况下使用。 var elementsHTML = element.innerHTML; 属性操作1234&lt;div&gt; &lt;label for=\"username\"&gt;User Name:&lt;/label&gt; &lt;input type=\"input\" name=\"username\" id=\"username\" class=\"text\" value=\"\"&gt;&lt;div&gt; 对应的属性 12345input.id; // &apos;username&apos;input.type; // &apos;text&apos;input.className; // &apos;text&apos;label.htmlFor; // &apos;username&apos; 属性操作方式 Property Accessor 通过属性方法符得到的属性为转换过的实例对象（并非全字符串）。 特点 X 通用行差（命名异常，使用不同的命名方式进行访问）X 扩展性差√ 实用对象（取出后可直接使用） 读取属性1234567&lt;div&gt; &lt;label for=\"username\"&gt;User Name: &lt;/label&gt; &lt;input type=\"input\" name=\"username\" id=\"username\" class=\"text\" value=\"\"&gt;&lt;/div&gt;input.className; // 'text'input[id]; // 'username' 写入属性 可增加新的属性或改写已有属性。12input.value = &apos;new value&apos;;input[id] = &apos;new-id&apos;; getAttribute / setAttribute 特点 X 仅可获取字符串（使用时需转换）√ 通用性强读取属性 获取到的均为属性的字符串。 var attribtue = element.getAttribute(‘attributeName’); 写入属性 可增加新的属性或改写已有属性。element.setAttribute(‘attributeName’, value); dataset自定义属性，其为 HTMLElement 上的属性也是 data-* 的属性集。主要用于在元素上保存数据。获取的均为属性字符串。数据通常使用 AJAX 获取并存储在节点之上。 123div.dataset.id; // &apos;1234&apos;div.dataset.username; // &apos;x&apos;div.dataset.email; // &apos;mail@gmail.com&apos; dataset 在低版本 IE 不可使用，但可通过 getAttribute 与 setAttribute 来做兼容。 样式操作更新样式123element.styleelement.style.color = 'red';element.style.background = 'black'; 增加样式后得到的结果1&lt;div style=\"color: red; background: black;\"&gt;&lt;/div&gt; 缺点 每个属性的更新都需要一个命令命名异常（以驼峰命名法命名属性） element.style.cssText一次同时设置多个行内样式，其结果同 element.style 单独设置相同。 1element.style.cssText = 'color: red; background: black'; 更新 class首先需要创建对应样式的 CSS 样式。 1234.angry &#123; color: red; background: black;&#125; 然后再在 JavaScript 中，在对应的事件中给元素添加需要的类即可。 element.className += ‘ angry’; 增加样式后得到的结果 统一更新多个元素样式以上方法均不适合同时更新多个样式，通过更换样式表的方式则可同时更改多个页面中的样式。将需要的大量样式也在一个皮肤样式表中，通过 JavaScript 来直接更换样式表来进行样式改变。（此方法也可用于批量删除样式） 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"base.css\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style1.css\"&gt; element.setAttribute(‘href’, ‘style2.css’); element.setAttribute(‘href’,’style2.css’) 获取样式element.style其对应的为元素的行内样式表而不是实际样式表。 element.style.color; // “” 事件DOM 事件何为 DOM 事件，HTML DOM 使JavaScript 有能力对 HTML 事件做出反应。（例如，点击 DOM 元素，键盘被按，输入框输入内容以及页面加载完毕等） 事件流一个 DOM 事件可以分为捕获过程、触发过程、冒泡过程。 DOM 事件流为 DOM 事件的处理及执行的过程。下面以一个&lt;a&gt;元素被点击为例。 事件注册事件注册，取消以及触发其作用对象均为一个 DOM 元素。 注册事件 eventTarget.addEventListener(type, listener[,useCapture]) evenTarget 表示要绑定事件的DOM元素 type 表示要绑定的事件，如：”click” listener 表示要绑定的函数 useCapture 可选参数，表示是否捕获过程 useCapture 为设定是否为捕获过程，默认事件均为冒泡过程，只有 useCapture 为 true 时才会启用捕获过程。 12345678910111213141516171819// 获取元素var elem = document.getElemenyById('id');// 事件处理函数var clickHandler = function(event) &#123; // statements&#125;;// 注册事件elem.addEventListener('click', clickHandler, false);// 第二种方式，不建议使用elem.onclick = clickHandler;// 或者来弥补只可触发一个处理函数的缺陷elem.onclick = function()&#123; clickHandler(); func(); // 其他处理函数&#125;; 取消事件eventTarget.removeEventListener(type, listener[,useCapture]); 12345678// 获取元素var elem = document.getElemenyById('id');// 取消事件elem.removeEventListener('click', clickHandler, false);// 第二种方式。不建议使用elem.onclick = null; 触发事件点击元素，按下按键均会触发 DOM 事件，当然也可以以通过代码来触发事件。 eventTarget.dispatchEvent(type); 12345// 获取元素var elem = document.getElemenyById('id');// 触发事件elem.dispatchEvent('click'); 事件对象调用事件处理函数时传入的信息对象，这个对象中含有关于这个事件的详细状态和信息，它就是事件对象 event。其中可能包含鼠标的位置，键盘信息等。 属性和方法通用属性和方法属性 type 事件类型 target(srcElement IE 低版本) 事件触发节点 currentTarget 处理事件的节点 方法 stopPropagation 阻止事件冒泡传播 preventDefault 阻止默认行为 stopImmediatePropagation 阻止冒泡传播 阻止事件传播event.stopPropagation()（W3C规范方法），如果在当前节点已经处理了事件，则可以阻止事件被冒泡传播至 DOM 树最顶端即 window 对象。event.stopImmediatePropagation() 此方法同上面的方法类似，除了阻止将事件冒泡传播值最高的 DOM 元素外，还会阻止在此事件后的事件的触发。 事件分类Event window load 页面全部加载完毕 unload 离开本页之前的卸载 error 页面异常 abort 取消加载 image load 图片加载完毕 error 图标加载错误 abort 取消图标加载在目标图标不能正常载入时，载入备份替代图来提供用户体验。 UIEvent MouseEventDOM 事件中最常见的事件之一 属性 clientX, clientX screenX, screenY ctrlKey, shiftKey, altKey, metaKey 如果被按下则为真（true） button(0, 1, 2) 鼠标的间位 MouseEvent 顺序鼠标的移动过程中会产生很多事件。事件的监察频率又浏览器决定。例子：从元素 A 上方移动过mousemove -&gt; mouseover(A) -&gt; mouseenter(A) -&gt; mousemove(A) -&gt; mouseout(A) -&gt; mouseleave(A)例子：点击元素mousedown -&gt; [mousemove] -&gt; mouseup -&gt; click 滚轮事件（Wheel） 属性 deltaMode 鼠标滚轮偏移量的单位 deltaX deltaY deltaZ FocusEvent其用于处理元素获得或失去焦点的事件。（例如输入框的可输入状态则为获得焦点，点击外部则失去焦点） blur 失去焦点时，focus 获得焦点时，focusin 即将获得焦点，focusout即将失去焦点。 KeyboardEvent其用于处理键盘事件 JavaScript 动画帧，为动画的最小单位，一个静态的图像。帧频，每秒播放的帧的数量。一个动画是由很多帧组成的，因为人眼的暂留特性，当图片交替的速度大于每秒 30 帧以上既有动画的感觉。 JavaScript 动画三要素 定时器 setInterval func 为执行改变属性的操作 delay 为出发时间间隔（毫秒为单位） para1 为执行时可传入改变属性函数的参数 12var intervalId = setInterval(func, delay[, param1, param2, ...]);clearInterval(intervalId); 使用 setInterval 可以调用一次定时器既可实现连贯的动画。使用 clearInterval 即可清除动画效果。 setTimeout func 为执行改变属性的操作 delay 为出发时间间隔（毫秒为单位）默认为 0 para1 为执行时可传入改变属性函数的参数 12var timeoutId = setTimeout(func[, delay, param1, param2, ...]);clearTimeout(timeoutId); 使用 setTimeout 实现动画，则需要在动画每一帧结束时再次调用定时器。但它无需清除定时器。 区别 setTimeout 在延时后只执行一次，setInterval 则会每隔一个延时期间后会再执行。 requestAnimationFrame 类似于 setTimeout 但是无需设定时间间隔。此定时器为 HTML5 中的新标准，其间隔时间不由用户控制，而是由显示器的刷新频率决定。（市面上的显示器刷新频率为每秒刷新60次） 常见动画 大多的复杂动画都是有下列的简单动画所组成的。 形变，改变元素的宽高 位移，改变元素相对位置 旋转 透明度 其他…","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"基础知识","slug":"技术/JavaScript/基础知识","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/基础知识/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.kaige1220.top/tags/JavaScript/"}]},{"title":"布局解决方案","slug":"布局解决方案","date":"2018-06-27T08:17:14.865Z","updated":"2018-06-27T12:00:22.083Z","comments":true,"path":"2018/06/27/布局解决方案/","link":"","permalink":"https://www.kaige1220.top/2018/06/27/布局解决方案/","excerpt":"居中布局水平居中子元素于父元素水平居中且其（子元素与父元素）宽度均可变。 inline-block + text-align 123456789101112&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: inline-block; &#125; .parent &#123; text-align: center; &#125;&lt;/style&gt; 兼容性佳（甚至可以兼容 IE 6 和 IE 7）","text":"居中布局水平居中子元素于父元素水平居中且其（子元素与父元素）宽度均可变。 inline-block + text-align 123456789101112&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: inline-block; &#125; .parent &#123; text-align: center; &#125;&lt;/style&gt; 兼容性佳（甚至可以兼容 IE 6 和 IE 7） table + margin 12345678910&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; display: table 在表现上类似 block 元素，但是宽度为内容宽。无需设置父元素样式 （支持 IE 8 及其以上版本） absolute + transform 1234567891011121314&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; position: relative; &#125; .child &#123; position: absolute; left: 50%; transform: translateX(-50%); &#125;&lt;/style&gt; 优点 绝对定位脱离文档流，不会对后续元素的布局造成影响。 缺点 transform 为 CSS3 属性，有兼容性问题 flex + justify-content 12345678910111213141516171819&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content: center; &#125; /* 或者下面的方法，可以达到一样的效果 */ .parent &#123; display: flex; &#125; .child &#123; margin: 0 auto; &#125;&lt;/style&gt; 优点 只需设置父节点属性，无需设置子元素 缺点 有兼容性问题 垂直居中子元素于父元素垂直居中且其（子元素与父元素）高度均可变。 table-cell + vertical-align 1234567891011&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt;` 兼容性好（支持 IE 8，以下版本需要调整页面结构至 table） absolute + transform 1234567891011121314&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; transform: translateY(-50%); &#125;&lt;/style&gt; 优点 绝对定位脱离文档流，不会对后续元素的布局造成影响。但如果绝对定位元素是唯一的元素则父元素也会失去高度。 缺点 -transform 为 CSS3 属性，有兼容性问题 flex + align-items 12345678910&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; align-items: center; &#125;&lt;/style&gt; 优点 只需设置父节点属性，无需设置子元素 缺点 有兼容性问题 水平与垂直居中子元素于父元素垂直及水平居中且其（子元素与父元素）高度宽度均可变。 inline-block + text-align + table-cell + vertical-align 1234567891011121314&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; text-align: center; display: table-cell; vertical-align: middle; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; absolute + transform 123456789101112131415&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; position: relative; &#125; .child &#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125;&lt;/style&gt; flex + justify-content + align-items 1234567891011&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content: center; align-items: center; &#125;&lt;/style&gt; 多列布局多列布局在网页中非常常见（例如两列布局），多列布局可以是两列定宽，一列自适应， 或者多列不定宽一列自适应还有等分布局等。 一列定宽，一列自适应 float + margin1234567891011121314151617181920&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left &#123; float: left; width: 100px; &#125; .right &#123; margin-left: 100px /*间距可再加入 margin-left */ &#125;&lt;/style&gt; float + overflow12345678910111213141516171819&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left &#123; float: left; width: 100px; &#125; .right &#123; overflow: hidden; &#125;&lt;/style&gt; 设置 overflow: hidden 会触发 BFC 模式（Block Formatting Context）块级格式化文本。 BFC 中的内容与外界的元素是隔离的。 table12345678910111213141516171819202122232425&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table; width: 100%; table-layout: fixed; &#125; .left &#123; display: table-cell; width: 100px; &#125; .right &#123; display: table-cell; /*宽度为剩余宽度*/ &#125;&lt;/style&gt; table 的显示特性为每列的单元格宽度合一定等与表格宽度。 table-layout: fixed; 可加速渲染，也是设定布局优先。 table-cell 中不可以设置 margin 但是可以通过 padding 来设置间距。 flex123456789101112131415161718192021222324&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .left &#123; width: 100px; margin-left: 20px; &#125; .right &#123; flex: 1; /*等价于*/ /*flex: 1 1 0;*/ &#125;&lt;/style&gt; flex-item 默认为内容宽度。 缺点 低版本浏览器兼容问题性能问题，只适合小范围布局。 两列定宽，一列自适应12345678910111213141516171819202122232425&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"center\"&gt; &lt;p&gt;center&lt;p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left, .center &#123; float: left; width: 100px; margin-right: 20px; &#125; .right &#123; overflow: hidden; /*等价于*/ /*flex: 1 1 0;*/ &#125;&lt;/style&gt; 一列不定宽加一列自适应不定宽的宽度为内容决定，下面为可以实现此效果的方法： float + overflow，此方法在 IE6 中有兼容性问题 table，此方法在 IE6 中有兼容性问题 flex，此方法在 IE9及其以下版本中有兼容性问题 多列等分布局float12345678910111213141516171819202122232425&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;3&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style media=\"screen\"&gt; .parent &#123; margin-left: -20px; &#125; .column &#123; float: left; width: 25%; padding-left: 20px; box-sizing: border-box; &#125;&lt;/style&gt; table1234567891011121314151617181920212223242526272829303132&lt;div class='parent-fix'&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;3&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;4&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style media=\"screen\"&gt; .parent-fix &#123; margin-left: -20px; &#125; .parent &#123; display: table; width: 100%; /*可以布局优先，也可以单元格宽度平分在没有设置的情况下*/ table-layout: fixed; &#125; .column &#123; display: table-cell; padding-left: 20px; &#125;&lt;/style&gt; flex12345678910111213141516171819202122232425262728&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;3&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style media=\"screen\"&gt; .parent &#123; display: flex; &#125; .column &#123; /*等价于 flex: 1 1 0;*/ flex: 1; &#125; .column+.column &#123; margin-left: 20px; &#125;&lt;/style&gt; 全屏布局例如管理系统，监控与统计平台均广泛的使用全屏布局。 实现方案 Position 常规方案 Flex CSS3 新实现 Position12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div class=\"parent\"&gt; &lt;div class=\"top\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt; /*辅助结构用于滚动*/ &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; html, body, .parent &#123; height: 100%; /*用于隐藏滚动条*/ overflo: hidden; &#125; .top &#123; /*相对于 body 定位*/ position: absolute; top: 0; left: 0; right: 0; height: 100px; &#125; .left &#123; position: absolute; left: 0; top: 100px; bottom: 50px; width: 200px; &#125; .right &#123; position: absolute; left: 200px; right: 0; top: 100px; bottom: 50px; overflow: auto; &#125; .right .inner &#123; /*此样式为演示所有*/ min-height: 1000px; &#125; .bottom &#123; position: absolute; left: 0; right: 0; bottom: 0; height: 50px; &#125;&lt;/style&gt; Flex1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class=\"parent\"&gt; &lt;div class=\"top\"&gt;&lt;/div&gt; &lt;div class=\"middle\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style media=\"screen\"&gt; html, body, parent &#123; height: 100%; overflow: hidden; &#125; .parent &#123; display: flex; flex-direction: column; &#125; .top &#123; height: 100px; &#125; .bottom &#123; height: 50px; &#125; .middle &#123; // 居中自适应 flex: 1; display: flex; /*flex-direction: row 为默认值*/ &#125; .left &#123; width: 200px; &#125; .right &#123; flex: 1; overflow: auto; &#125; .right .inner &#123; min-height: 1000px; &#125;&lt;/style&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"布局解决方案","slug":"技术/布局解决方案","permalink":"https://www.kaige1220.top/categories/技术/布局解决方案/"}],"tags":[{"name":"布局解决方案","slug":"布局解决方案","permalink":"https://www.kaige1220.top/tags/布局解决方案/"}]},{"title":"css学习系列","slug":"css学习系列","date":"2018-06-27T06:45:19.085Z","updated":"2018-06-27T12:02:14.567Z","comments":true,"path":"2018/06/27/css学习系列/","link":"","permalink":"https://www.kaige1220.top/2018/06/27/css学习系列/","excerpt":"语法语法1234567891011/* 选择器 */.m-userlist &#123; /* 属性声明 */ margin: 0 0 30px; /* 属性名:属性值; */&#125;.m-userlist .list &#123; position: relative; height: 100px; overflow: hidden;&#125;","text":"语法语法1234567891011/* 选择器 */.m-userlist &#123; /* 属性声明 */ margin: 0 0 30px; /* 属性名:属性值; */&#125;.m-userlist .list &#123; position: relative; height: 100px; overflow: hidden;&#125; 浏览器私有属性 Google Chrome, Safari (-webkit) Firefox (-moz-) IE (-ms-) Opera (-o-) 12345.pic &#123; -webkit-transform: rotate(-3deg); -ms-transform: rotate(-3deg); transform: rotate(-3deg);&#125; CSS 预处理器（Sass，Less，Stylus）或编辑器插件可自动添加浏览器厂商的私有属性前缀。 @规则 常用的规则: @media （用于响应式布局） @keyframes （CSS 动画的中间步骤） @font-face （引入外部字体） 其他规则（不常用） @import @charset @namespace @page @supports @document 选择器简单选择器标签选择器 类选择器 id 选择器 通配符选择器 * 属性选择器 [attr] 或 [attr=val] 来选择相应的元素。#nav{…} 既等同于 [id=nav]{…}。 [attr~=val] 可选用与选择包含 val 属性值的元素，像class=”title sports” 与 class=”sports”。.sports{…} 既等同于 [class~=sports]{…} [attr|=val] 可以选择val开头及开头紧接-的属性值 [attr^=val] 可选择以val开头的属性值对应的元素，如果值为符号或空格则需要使用引号 “”。 [attr$=val] 可选择以val结尾的属性值对应的元素。 [attr*=val] 可选择以包含val属性值对应的元素。 伪类选择器常用伪类选择器： :link IE6+ :visited IE7+ :hover IE6中仅可用于链接 :active IE6/7中仅可用于链接 :enabled IE9+ :disabled IE9+ :checked IE9+ :first-child IE8+ :last-child IE9+ :nth-child(even) 可为 odd even 或数字 IE9+ :nth-last-child(n) n从 0 开始计算 IE9+ :only-child 仅选择唯一的元素 IE9+ :only-of-type IE9+ :first-of-type IE9+ :last-of-type IE9+ :nth-of-type(even) IE9+ :nth-last-of-type(2n) IE9+ element:nth-of-type(n) 指父元素下第 n 个 element 元素，element:nth-child(n) 指父元素下第 n 个元素且元素为 element，若不是，选择失败 其他选择器伪元素选择器注意与伪类学则器的区分。 ::first-letter IE6+ ::first-line IE6+ ::before{content: “before”} 需与 content 一同使用 IE8+ ::after{content: “after”} 需与 content 一同使用 IE8+ ::selection 被用户选中的内容（鼠标选择高亮属性）IE9+ Firefox需用 -moz 前缀 组合选择器 后代选择器 .main h2 {…}，使用 表示 IE6+ 子选择器 .main&gt;h2 {…}，使用&gt;表示 IE7+ 兄弟选择器 h2+p {…}，使用+表示 IE7+h2~p {…}，使用~表示（此标签无需紧邻）IE7+ 选择器分组 1h1, h2, h3 &#123;color: red;&#125; 继承、优先、层级子元素继承父元素的样式，但并不是所有属性都是默认继承的。通过文档中的 inherited: yes 来判断属性是否可以自动继承。 自动继承属性： color font text-align list-style 非继承属性： background border position 文本字体改变字号 12345678div font-size 12px p#sample0 font-size 16px p#sample1 font-size 2em p#sample2 font-size 200% 以上两值在开发中并不常用。2em 与 200% 都为父元素默认大小的两倍（参照物为父元素的字体大小 12px）。 改变字体 font-family: arial, Verdana, sans-serif; 优先使用靠前的字体 加粗字体 font-weight: normal;font-weight: bold; 倾斜字体font-style: normal | italic | oblique | inherit 更改行距1234567/* length 类型 */line-height: 40px;line-height: 3em;/* percentage 类型 */line-height: 300%;/* number 类型 */line-height: 3; 当line-height为 number 类型时，子类直接继承其数值（不计算直接继承）。 而当为 percentage 类型时，子类则会先计算再显示（先计算后继承）。 字间距（字母间距） letter-spacing: normal | 其用于设置字间距或者字母间距，此属性适用于中文或西文中的字母。 如果需要设置西文中词与词的间距或标签直接的距离则需要使用 word-spacing。 改变文字颜色color: 123456789101112131415element &#123; color: red; &#125;element &#123; color: #f00; &#125;element &#123; color: #ff0000; &#125;element &#123; color: rgb(255,0,0); &#125;element &#123; color: rgb(100%, 0%, 0%); &#125;element &#123; color: hsl(0, 100%, 50%); &#125;/* 50% translucent */element &#123; color: rgba(255, 0, 0, 0.5); &#125;element &#123; color: hsla(0, 100%, 50%, 0.5); &#125;/* 全透明 */element &#123; color: transparent' &#125;element &#123; color: rgba(0, 0, 0, 0); &#125; 对齐方式: 文字居中text-align: start | end | left | right | center | justify | match-parent | start end 文本垂直对齐vertical-align: baseline | sub | super | text-top | text-bottom | middle | top | bottom 文本缩进text-indent: &lt;length&gt; | &lt;percentage&gt; &amp;&amp; [ hanging || each-line ] 缩进两个字可使用 text-indent: 2em; 格式处理保留空格格式white-space: normal | pre | nowrap | pre-wrap | pre-line 文字换行word-wrap: normal | break-word 文本装饰文字阴影 1234p &#123; text-shadow: 1px 1px 1px #000, 3px 3px 5px blue;&#125; value = The X-coordinate X 轴偏移像素 value = The Y-coordinate Y 轴偏移像素 value = The blur radius 阴影模糊半径 value = The color of the shadow 阴影颜色（默认为文字颜色） 文本装饰（下划线等）text-decoration: 123456789101112131415161718h1.under &#123; text-decoration: underline;&#125;h1.over &#123; text-decoration: overline;&#125;p.line &#123; text-decoration: line-through;&#125;p.blink &#123; text-decoration: blink;&#125;a.none &#123; text-decoration: none;&#125;p.underover &#123; text-decoration: underline overline;&#125; 高级设置省略字符text-overflow: [ clip | ellipsis | ]{1,2} 12345/* 常用配合 */text-overflow: ellipsis;overflow: hidden; /* 溢出截取 */white-space: nowrap; /* 禁止换行 */ 更换鼠标形状cursor: 常用属性 &lt;uri&gt; 图片资源地址代替鼠标默认形状 &lt;default&gt; 默认光标 &lt;none&gt; 隐藏光标 &lt;pointer&gt; 手型光标 &lt;zoom-in&gt; &lt;zoom-out&gt; &lt;move&gt; 强制继承inherit 会强制继承父元素的属性值。 1234567font-size: inherit;font-family: inherit;font-weight: inherit;...word-wrap: inherit;work-break: inherittext-showdow: inherit 盒模型盒子模型是网页布局的基石。它有边框、外边距、内边距、内容组成。 盒子由上到下依次分为五层，它们自上而下的顺序是。 border 边框 content + padding 内容与内边距 background-image 背景图片 background-color 背景颜色 margin 外边距 width内容盒子宽 height内容盒子高 border-radius overflow box-sizing box-shadow box-shadow: 4px 6px 3px 0px red; | | | | 水平偏移| | | 垂直偏移 | | 模糊半径 | 阴影大小 背景background-color background-image background-image: url(“../image/pic.png”); 当background-color 与 background-image 共存时，背景颜色永远在最底层（于背景图片之下）。 background-repeat background-repeat 需与背景图片数量一致。 space 平铺并在水平和垂直留有空隙，空隙的大小为图片均匀分布后完整覆盖显示区域的宽高 round 不留空隙平铺且覆盖显示区域，图标会被缩放以达到覆盖效果（缩放不一定等比） background-attachment 当页面内容超过显示区域时，使用 local 使背景图片同页面内容一同滚动。12background-attachment: `&lt;attachment&gt;`[, `&lt;attachment&gt;`]*`&lt;attachment&gt;` = scroll | fixed | local background-position 12345678910111213141516/* 默认位置为 */background-position: 0 0;/* percentage 是容器与图片的百分比重合之处*/background-position: 20% 50%;/* 等同效果 */background-position: 50% 50%;background-position: center center;background-position: 0 0;background-position: left top;background-position: 100% 100%;background-position: right bottom; 布局、变形、动画 单独有文章分析了 这里略过","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"css","slug":"技术/css","permalink":"https://www.kaige1220.top/categories/技术/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.kaige1220.top/tags/css/"}]},{"title":"html学习系列","slug":"html学习系列","date":"2018-06-27T02:58:04.598Z","updated":"2018-07-05T12:17:03.167Z","comments":true,"path":"2018/06/27/html学习系列/","link":"","permalink":"https://www.kaige1220.top/2018/06/27/html学习系列/","excerpt":"简介：一个html分三部分： 文档声明：&lt;!DOCTYPE html&gt; 必须首行定格 文档头部 1234567&lt;head&gt; &lt;title&gt; 为文档标题 &lt;meta charset=\"utf-8\"&gt; //文档解码格式 &lt;meta name=\"keywords\" content=\"...\"&gt; 和 &lt;meta name=\"description\" content=\"...\"&gt; //提供给搜索引擎使用 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; //移动端浏览器的宽高与缩放 &lt;link&gt; 标签可以引入 favicon 和样式表 CSS 文件&lt;/head&gt; 文档主体","text":"简介：一个html分三部分： 文档声明：&lt;!DOCTYPE html&gt; 必须首行定格 文档头部 1234567&lt;head&gt; &lt;title&gt; 为文档标题 &lt;meta charset=\"utf-8\"&gt; //文档解码格式 &lt;meta name=\"keywords\" content=\"...\"&gt; 和 &lt;meta name=\"description\" content=\"...\"&gt; //提供给搜索引擎使用 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; //移动端浏览器的宽高与缩放 &lt;link&gt; 标签可以引入 favicon 和样式表 CSS 文件&lt;/head&gt; 文档主体 HTML 语法书写规范： 小写标签和属性 属性值双引号 代码因嵌套缩进 全局属性 id, &lt;div id=&#39;unique-element&#39;&gt;&lt;/div&gt;，页面中唯一 class，&lt;button class=&#39;btn&#39;&gt;Click Me&lt;/button&gt;，页面中可重复出现 style，尽量避免 title，对于元素的描述类似于 Tooltip 的效果。 HTML 标签&lt;body&gt; 页面内容 &lt;header&gt; 文档头部 &lt;nav&gt; 导航 &lt;aside&gt; 侧边栏 &lt;article&gt; 定义外部内容（如外部引用的文章） &lt;section&gt; 一个独立的块 &lt;footer&gt; 尾部 页面通常结构 文本标签 1234567891011121314151617181920212223&lt;!-- 默认超链接 --&gt;&lt;a href=\"http://sample-link.com\" title=\"Sample Link\"&gt;Sample&lt;/a&gt;&lt;!-- 当前窗口显示 --&gt;&lt;a href=\"http://sample-link.com\" title=\"Sample Link\" target=\"_self\"&gt;Sample&lt;/a&gt;&lt;!-- 新窗口显示 --&gt;&lt;a href=\"http://sample-link.com\" title=\"Sample Link\" target=\"_blank\"&gt;Sample&lt;/a&gt;&lt;!-- iframe 中打开链接 --&gt;&lt;a href=\"http://sample-link.com\" title=\"Sample Link\" target=\"iframe-name\"&gt;Sample&lt;/a&gt;&lt;iframe name=\"iframe-name\" frameborder=\"0\"&gt;&lt;/iframe&gt;&lt;!-- 页面中的锚点 --&gt;&lt;a href=\"#achor\"&gt;Achor Point&lt;/a&gt;&lt;section id=\"achor\"&gt;Achor Content&lt;/section&gt;&lt;!-- 邮箱及电话需系统支持 --&gt;&lt;a href=\"mailto:sample-address@me.com\" title=\"Email\"&gt;Contact Us&lt;/a&gt;&lt;!-- 多个邮箱地址 --&gt;&lt;a href=\"mailto:sample-address@me.com, sample-address0@me.com\" title=\"Email\"&gt;Contact Us&lt;/a&gt;&lt;!-- 添加抄送，主题和内容 --&gt;&lt;a href=\"mailto:sample-address@me.com?cc=admin@me.com&amp;subject=Help&amp;body=sample-body-text\" title=\"Email\"&gt;Contact Us&lt;/a&gt;&lt;!-- 电话示例 --&gt;&lt;a href=\"tel:99999999\" title=\"Phone\"&gt;Ring Us&lt;/a&gt; 组合内容标签 &lt;div&gt; &lt;p&gt; &lt;ol&gt; &lt;ul&gt; &lt;dl&gt; &lt;pre&gt; &lt;blockquote&gt; 文档章节&lt;body&gt; 页面内容 &lt;header&gt; 文档头部 &lt;nav&gt; 导航 &lt;aside&gt; 侧边栏 &lt;article&gt;定义外部内容（如外部引用的文章） &lt;section&gt; 一个独立的块 &lt;footer&gt;尾部 引用&lt;cite&gt; 引用作品的名字、作者的名字等&lt;q&gt; 引用一小段文字（大段文字引用用&lt;blockquote&gt;）&lt;blockquote&gt; 引用大块文字&lt;pre&gt; 保存格式化的内容（其空格、换行等格式不会丢失） 12345678&lt;pre&gt; &lt;code&gt; int main(void) &#123; printf('Hello, world!'); return 0; &#125;&lt;/code&gt;&lt;/pre&gt; 代码&lt;code&gt; 引用代码 格式化&lt;b&gt; 加粗 &lt;i&gt;斜体 强调&lt;em&gt; 斜体。着重于强调内容，会改变语义的强调&lt;strong&gt;粗体。着重于强调内容的重要性 换行&lt;br&gt; 换行 列表无序列表1234&lt;ul&gt; &lt;li&gt;标题&lt;/li&gt; &lt;li&gt;结论&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;第一&lt;/li&gt; &lt;li&gt;第二&lt;/li&gt;&lt;/ol&gt; 自定义列表1234567&lt;dl&gt; &lt;dt&gt;作者&lt;/dt&gt; &lt;dd&gt;爱因斯坦&lt;/dd&gt; &lt;dt&gt;作品&lt;/dt&gt; &lt;dd&gt;《相对论》&lt;/dd&gt; &lt;dd&gt;《时间与空间》&lt;/dd&gt;&lt;/dl&gt; 一个&lt;dt&gt;可以对应多个&lt;dd&gt; &lt;dl&gt; 为自定义列表，其中包含一个或多个 &lt;dt&gt; 及 一个或多个 &lt;dd&gt;，并且dt 与 dl列表会有缩进的效果。&lt;pre&gt; 会保留换行和空格，通常与 &lt;code&gt; 一同使用。 &lt;blockquote&gt; 拥有 cite 属性，它包含引用文本的出处，示例如下所示： 123&lt;blockquote cite=\"http://example.com/facts\"&gt; &lt;p&gt;Sample Quote...&lt;/p&gt;&lt;/blockquote&gt; 嵌入123456789101112131415&lt;iframe src=\"\"&gt;&lt;/iframe&gt; 页面操作可以不影响到iframe的内容&lt;!--object embed通常用来嵌入外部资源 --&gt;&lt;object type=\"application/x-shockwave-player\"&gt; &lt;param name=\"movie\" value=\"book.pdf\"&gt;&lt;/object&gt;&lt;!--视频 track可以引入字幕 autoplay可以使视频加载后自动播放，loop可以使其循环播放 --&gt;&lt;video autoplay loop controls=\"controls\" poster=\"poster.jpg\"&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.webm\" type=\"video/webm\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt; &lt;track kind=\"subtitles\" src=\"video.vtt\" srclang=\"cn\" label=\"cn\"&gt;&lt;/video&gt; 资源标签图标签canvas 基于像素，性能要求比较高，可用于实时数据展示。svg 为矢量图形图像。 热点区域标签img中套用map以及area可以实现点击某部分图片触发一个链接，点击另一部分触发另一个链接 12345&lt;img src=\"mama.jpg\" width=100 height=100 usemap=\"#map\" /&gt;&lt;map name=\"map\"&gt; &lt;area shap=\"rect\" coords=\"0,0,50,50\" href=\"\" alt=\"\"&gt; &lt;area shap=\"circle\" coords=\"75,75,25\" href=\"\" alt=\"\"&gt;&lt;/map&gt; 表格表格代码示例 12345678910111213&lt;table&gt; &lt;caption&gt;table title and/or explanatory text&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;header&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;data&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 使用 colspan=val 进行跨列，使用 rowspan=val 进行跨行。 表单12345678910111213141516171819&lt;form action=\"WebCreation_submit\" method=\"get\" accept-charset=\"utf-8\"&gt; &lt;fieldset&gt; &lt;legend&gt;title or explanatory caption&lt;/legend&gt; &lt;!-- 第一种添加标签的方法 --&gt; &lt;label&gt;&lt;input type=\"text/submit/hidden/button/etc\" name=\"\" value=\"\"&gt;&lt;/label&gt; &lt;!-- 第二种添加标签的方法 --&gt; &lt;label for=\"input-id\"&gt;Sample Label&lt;/label&gt; &lt;input type=\"text\" id=\"input-id\"&gt; &lt;/fieldset&gt; &lt;fieldset&gt; &lt;legend&gt;title or explanatory caption&lt;/legend&gt; &lt;!-- 只读文本框 --&gt; &lt;input type=\"text\" readonly&gt; &lt;!-- 隐藏文本框，可提交影藏数据 --&gt; &lt;input type=\"text\" name=\"hidden-info\" value=\"hiden-info-value\" hidden&gt; &lt;/fieldset&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;button type=\"reset\"&gt;Reset&lt;/button&gt;&lt;/form&gt; 使用fieldset可用于对表单进行分区表单中的其他控件类型： textarea （文本框） select 与 option （下拉菜单可多选） 实体字符实体字符（ASCII Encoding Reference）是用来在代码中以实体代替与HTML语法相同的字符，避免浏览解析错误。它的两种表示方式，第一种为 &amp; 外加实体字符名称，例如 &amp;nbsp;，第二种为 &amp; 加实体字符序号，例如 &amp;#160;。 常用HTML字符实体（建议使用实体）： 常用特殊字符实体（不建议使用实体）： 浏览器兼容：主流浏览器都兼容 HTML5 的新标签，对于 IE8 及以下版本不认识 HTML5的新元素，可以使用 JavaScript 创建一个没用的元素来解决，例如： 123&lt;script&gt; document.createElement(\"header\");&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"html","slug":"技术/html","permalink":"https://www.kaige1220.top/categories/技术/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://www.kaige1220.top/tags/html/"}]},{"title":"HTTP笔记实录5","slug":"http笔记实录5","date":"2018-06-27T01:06:58.298Z","updated":"2018-06-27T12:02:46.307Z","comments":true,"path":"2018/06/27/http笔记实录5/","link":"","permalink":"https://www.kaige1220.top/2018/06/27/http笔记实录5/","excerpt":"第 5 章 与 HTTP 协作的 Web 服务器一台 Web 服务器可搭建多个独立域名的 Web 网站， 也可作为通信路径上的中转服务器提升传输效率 5.1 用单台虚拟主机实现多个域名HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。 比如， 提供 Web 托管服务（Web Hosting Service） 的供应商， 可以用一台服务器为多位客户服务， 也可以以每位客户持有的域名运行各自不同的网站。 这是因为利用了虚拟主机（Virtual Host， 又称虚拟服务器） 的功能。 即使物理层面只有一台服务器， 但只要使用虚拟主机的功能， 则可以假想已具有多台服务器。 在互联网上， 域名通过 DNS 服务映射到 IP 地址（域名解析） 之后访问目标网站。 可见， 当请求发送到服务器时， 已经是以 IP 地址形式访问了。 所以， 如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名， 当收到请求时就需要弄清楚究竟要访问哪个域名。 在相同的 IP 地址下， 由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站， 因此在发送 HTTP 请求时， 必须在 Host 首部内完整指定主机名或域名的 URI。","text":"第 5 章 与 HTTP 协作的 Web 服务器一台 Web 服务器可搭建多个独立域名的 Web 网站， 也可作为通信路径上的中转服务器提升传输效率 5.1 用单台虚拟主机实现多个域名HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。 比如， 提供 Web 托管服务（Web Hosting Service） 的供应商， 可以用一台服务器为多位客户服务， 也可以以每位客户持有的域名运行各自不同的网站。 这是因为利用了虚拟主机（Virtual Host， 又称虚拟服务器） 的功能。 即使物理层面只有一台服务器， 但只要使用虚拟主机的功能， 则可以假想已具有多台服务器。 在互联网上， 域名通过 DNS 服务映射到 IP 地址（域名解析） 之后访问目标网站。 可见， 当请求发送到服务器时， 已经是以 IP 地址形式访问了。 所以， 如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名， 当收到请求时就需要弄清楚究竟要访问哪个域名。 在相同的 IP 地址下， 由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站， 因此在发送 HTTP 请求时， 必须在 Host 首部内完整指定主机名或域名的 URI。 5.2 通信数据转发程序 ： 代理、 网关、 隧道HTTP 通信时， 除客户端和服务器以外， 还有一些用于通信数据转发的应用程序， 例如代理、 网关和隧道。 它们可以配合服务器工作。 这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器， 并且能接收从那台服务器发送的响应再转发给客户端。 代理代理是一种有转发功能的应用程序， 它扮演了位于服务器和客户端“中间人”的角色， 接收由客户端发送的请求并转发给服务器， 同时也接收服务器返回的响应并转发给客户端。代理不改变请求 URI， 会直接发送给前方持有资源的目标服务器使用代理服务器的理由有： 利用缓存技术（稍后讲解） 减少网络带宽的流量， 组织内部针对特定网站的访问控制， 以获取访问日志为主要目的， 等等。 网关网关是转发其他服务器通信数据的服务器， 接收从客户端发送来的请求时， 它就像自己拥有资源的源服务器一样对请求进行处理。 有时客户端可能都不会察觉， 自己的通信目标是一个网关。 利用网关能提高通信的安全性， 因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。 比如， 网关可以连接数据库， 使用SQL语句查询数据。 另外， 在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动 隧道隧道是在相隔甚远的客户端和服务器两者之间进行中转， 并保持双方通信连接的应用程序。 5.3 保存资源的缓存缓存是指代理服务器或客户端本地磁盘内保存的资源副本。 利用缓存可减少对源服务器的访问， 因此也就节省了通信流量和通信时间 5.3.1 缓存的有效期限当遇上源服务器上的资源更新时， 如果还是使用不变的缓存， 那就会演变成返回更新前的“旧”资源了。 即使存在缓存， 也会因为客户端的要求、 缓存的有效期等因素， 向源服务器确认资源的有效性。 若判断缓存失效， 缓存服务器将会再次从源服务器上获取“新”资源。 5.3.2 客户端的缓存缓存不仅可以存在于缓存服务器内， 还可以存在客户端浏览器中。 以Internet Explorer 程序为例， 把客户端缓存称为临时网络文件（Temporary Internet File） 。浏览器缓存如果有效， 就不必再向服务器请求相同的资源了， 可以直接从本地磁盘内读取","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"https://www.kaige1220.top/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.kaige1220.top/tags/HTTP/"}]},{"title":"HTTP笔记实录4","slug":"http笔记实录4","date":"2018-06-27T00:44:30.418Z","updated":"2018-06-27T12:01:14.436Z","comments":true,"path":"2018/06/27/http笔记实录4/","link":"","permalink":"https://www.kaige1220.top/2018/06/27/http笔记实录4/","excerpt":"第 4 章 返回结果的 HTTP 状态码4.1 状态码告知从服务器端返回的请求结果数字中的第一位指定了响应类别， 后两位无分类。 响应类别有以下 5 种。表 4-1： 状态码的类别 4.2 2XX 成功2XX 的响应结果表明请求被正常处理了。 4.2.1 200 OK","text":"第 4 章 返回结果的 HTTP 状态码4.1 状态码告知从服务器端返回的请求结果数字中的第一位指定了响应类别， 后两位无分类。 响应类别有以下 5 种。表 4-1： 状态码的类别 4.2 2XX 成功2XX 的响应结果表明请求被正常处理了。 4.2.1 200 OK 4.2.2 204 No Content该状态码代表服务器接收的请求已成功处理， 但在返回的响应报文中不含实体的主体部分。 另外， 也不允许返回任何实体的主体。 比如，当从浏览器发出请求处理后， 返回 204 响应， 那么浏览器显示的页面不发生更新 4.2.3 206 Partial Content该状态码表示客户端进行了范围请求， 而服务器成功执行了这部分的GET 请求。 响应报文中包含由 Content-Range 指定范围的实体内容。 4.3 3XX 重定向3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 4.3.1 301 Moved Permanently永久性重定向。 该状态码表示请求的资源已被分配了新的 URI， 以后应使用资源现在所指的 URI。 也就是说， 如果已经把资源对应的 URI保存为书签了， 这时应该按 Location 首部字段提示的 URI 重新保存。 4.3.2 302 Found临时性重定向。 该状态码表示请求的资源已被分配了新的 URI， 希望用户（本次） 能使用新的 URI 访问。 和 301 Moved Permanently 状态码相似， 但 302 状态码代表的资源不是被永久移动， 只是临时性质的。 换句话说， 已移动的资源对应的URI 将来还有可能发生改变。 比如， 用户把 URI 保存成书签， 但不会像 301 状态码出现时那样去更新书签， 而是仍旧保留返回 302 状态码的页面对应的 URI。 4.3.3 303 See Other该状态码表示由于请求对应的资源存在着另一个 URI， 应使用 GET方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相同的功能， 但 303 状态码明确表示客户端应当采用 GET 方法获取资源， 这点与 302 状态码有区别。 4.3.4 304 Not Modified该状态码表示客户端发送附带条件的请求 2 时， 服务器端允许请求访问资源， 但未满足条件的情况。 304 状态码返回时， 不包含任何响应的主体部分。 304 虽然被划分在 3XX 类别中， 但是和重定向没有关系 4.3.5 307 Temporary Redirect临时重定向。 该状态码与 302 Found 有着相同的含义。 尽管 302 标准禁止 POST 变换成 GET， 但实际使用时大家并不遵守 4.4 4XX 客户端错误4.4.1 400 Bad Request该状态码表示请求报文中存在语法错误。 当错误发生时， 需修改请求的内容后再次发送请求。 另外， 浏览器会像 200 OK 一样对待该状态码。 4.4.2 401 Unauthorized 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证） 的认证信息。 另外若之前已进行过 1 次请求， 则表示用户认证失败。 4.4.3 403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。 服务器端没有必要给出拒绝的详细理由， 但如果想作说明的话， 可以在实体的主体部分对原因进行描述， 这样就能让用户看到了。 未获得文件系统的访问授权， 访问权限出现某些问题（从未授权的发送源 IP 地址试图访问） 等列举的情况都可能是发生 403 的原因。 4.4.4 404 Not Found该状态码表明服务器上无法找到请求的资源。 除此之外， 也可以在服务器端拒绝请求且不想说明理由时使用 4.5 5XX 服务器错误5XX 的响应结果表明服务器本身发生错误。 4.5.1 500 Internal Server Error该状态码表明服务器端在执行请求时发生了错误。 也有可能是 Web应用存在的 bug 或某些临时的故障 4.5.2 503 Service Unavailable该状态码表明服务器暂时处于超负载或正在进行停机维护， 现在无法处理请求。 如果事先得知解除以上状况需要的时间， 最好写入RetryAfter 首部字段再返回给客户端","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"https://www.kaige1220.top/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.kaige1220.top/tags/HTTP/"}]},{"title":"HTTP笔记实录3","slug":"http笔记实录3","date":"2018-06-26T08:28:19.967Z","updated":"2018-06-26T13:30:41.092Z","comments":true,"path":"2018/06/26/http笔记实录3/","link":"","permalink":"https://www.kaige1220.top/2018/06/26/http笔记实录3/","excerpt":"第 3 章 HTTP 报文内的 HTTP信息HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。 本章就让我们来了解一下请求和响应是怎样运作的。 3.1 HTTP 报文用于 HTTP 协议交互的信息被称为 HTTP 报文。 请求端（客户端） 的HTTP 报文叫做请求报文， 响应端（服务器端） 的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符） 数据构成的字符串文本。 HTTP 报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF） 来划分。 通常， 并不一定要有报文主体。","text":"第 3 章 HTTP 报文内的 HTTP信息HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。 本章就让我们来了解一下请求和响应是怎样运作的。 3.1 HTTP 报文用于 HTTP 协议交互的信息被称为 HTTP 报文。 请求端（客户端） 的HTTP 报文叫做请求报文， 响应端（服务器端） 的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符） 数据构成的字符串文本。 HTTP 报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF） 来划分。 通常， 并不一定要有报文主体。 3.2 请求报文及响应报文的结构 请求行包含用于请求的方法， 请求 URI 和 HTTP 版本。状态行包含表明响应结果的状态码， 原因短语和 HTTP 版本。首部字段包含表示请求和响应的各种条件和属性的各类首部。 一般有 4 种首部， 分别是： 通用首部、 请求首部、 响应首部和实体首部 3.3 编码提升传输速率HTTP 在传输数据时可以按照数据原貌直接传输， 但也可以在传输过程中通过编码提升传输速率。 通过在传输时编码， 能有效地处理大量的访问请求。 但是， 编码的操作需要计算机来完成， 因此会消耗更多的 CPU 等资源。 3.3.1 报文主体和实体主体的差异 报文（ message）是 HTTP 通信中的基本单位， 由 8 位组字节流（octet sequence，其中 octet 为 8 个比特） 组成， 通过 HTTP 通信传输。 实体（entity） 作为请求或响应的有效载荷数据（补充项） 被传输， 其内容由实体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。 通常， 报文主体等于实体主体。 只有当传输中进行编码操作时， 实体主体的内容发生变化， 才导致它和报文主体产生差异 3.3.2 压缩传输的内容编码向待发送邮件内增加附件时， 为了使邮件容量变小， 我们会先用 ZIP压缩文件之后再添加附件发送。 HTTP 协议中有一种被称为内容编码的功能也能进行类似的操作。 3.3.3 分割发送的分块传输编码在 HTTP 通信过程中， 请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。 在传输大容量数据时， 通过把数据分割成多块， 能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding） 。 3.4 发送多种数据的多部分对象集合多部分对象集合包含的对象如下。 multipart/form-data 在 Web 表单文件上传时使用。 multipart/byteranges 状态码 206（Partial Content， 部分内容） 响应报文包含了多个范围的内容时使用。 在 HTTP 报文中使用多部分对象集合时， 需要在首部字段里加上Content-type。 有关这个首部字段， 我们稍后讲解。 3.5 获取部分内容的范围请求以前， 用户不能使用现在这种高速的带宽访问互联网， 当时， 下载一个尺寸稍大的图片或文件就已经很吃力了。 如果下载过程中遇到网络中断的情况， 那就必须重头开始。 为了解决上述问题， 需要一种可恢复的机制。 所谓恢复是指能从之前下载中断处恢复下载。 要实现该功能需要指定下载的实体范围。 像这样， 指定范围发送的请求叫做范围请求（ Range Request） 。 执行范围请求时， 会用到首部字段 Range 来指定资源的 byte 范围。 byte 范围的指定形式如下。 3.6 内容协商返回最合适的内容同一个 Web 网站有可能存在着多份相同内容的页面。 比如英语版和中文版的 Web 页面， 它们内容上虽相同， 但使用的语言却不同。 当浏览器的默认语言为英语或中文， 访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。 这样的机制称为内容协商（Content Negotiation） 。 包含在请求报文中的某些首部字段（如下） 就是判断的基准。 这些首部字段的详细说明请参考下一章。 AcceptAccept-CharsetAccept-EncodingAccept-LanguageContent-Languag 内容协商技术有以下 3 种类型： 服务器驱动协商（ Server-driven Negotiation） 服务器驱动协商（ Server-driven Negotiation） 透明协商（ Transparent Negotiation）","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"https://www.kaige1220.top/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.kaige1220.top/tags/HTTP/"}]},{"title":"HTTP笔记实录2","slug":"http笔记实录2","date":"2018-06-26T07:55:04.485Z","updated":"2018-06-26T13:30:55.737Z","comments":true,"path":"2018/06/26/http笔记实录2/","link":"","permalink":"https://www.kaige1220.top/2018/06/26/http笔记实录2/","excerpt":"第 2 章 简单的 HTTP 协议2.1 HTTP 协议用于客户端和服务器端之间的通信HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同， 用于客户端和服务器之间的通信。 请求访问文本或图像等资源的一端称为客户端， 而提供资源响应的一端称为服务器端。","text":"第 2 章 简单的 HTTP 协议2.1 HTTP 协议用于客户端和服务器端之间的通信HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同， 用于客户端和服务器之间的通信。 请求访问文本或图像等资源的一端称为客户端， 而提供资源响应的一端称为服务器端。 2.2 通过请求和响应的交换达成通信 起始行开头的GET表示请求访问服务器的类型， 称为方法（method） 。 随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI（request-URI） 。 最后的 HTTP/1.1， 即 HTTP 的版本号， 用来提示客户端使用的 HTTP 协议功能。 请求报文是由请求方法、 请求 URI、 协议版本、 可选的请求首部字段和内容实体构成的。 接收到请求的服务器， 会将请求内容的处理结果以响应的形式返回： 在起始行开头的 HTTP/1.1 表示服务器对应的 HTTP 版本。紧挨着的 200 OK 表示请求的处理结果的状态码（status code） 和原因短语（reason-phrase） 。 下一行显示了创建响应的日期时间， 是首部字段（header field） 内的一个属性。接着以一空行分隔， 之后的内容称为资源实体的主体（entitybody） 。响应报文基本上由协议版本、 状态码（表示请求成功或失败的数字代码） 、 用以解释状态码的原因短语、 可选的响应首部字段以及实体主体构成。 2.3 HTTP 是不保存状态的协议HTTP 是一种不保存状态， 即无状态（stateless） 协议。 HTTP 协议自身不对请求和响应之间的通信状态进行保存。 也就是说在 HTTP 这个级别， 协议对于发送过的请求或响应都不做持久化处理。 可是， 随着 Web 的不断发展， 因无状态而导致业务处理变得棘手的情况增多了。 比如， 用户登录到一家购物网站， 即使他跳转到该站的其他页面后， 也需要能继续保持登录状态。 针对这个实例， 网站为了能够掌握是谁送出的请求， 需要保存用户的状态。 HTTP/1.1 虽然是无状态协议， 但为了实现期望的保持状态功能， 于是引入了 Cookie 技术。 有了 Cookie 再用 HTTP 协议通信， 就可以管理状态了。 2.4 请求 URI 定位资源HTTP 协议使用 URI 定位互联网上的资源。 正是因为 URI 的特定功能， 在互联网上任意位置的资源都能访问到。 2.5 告知服务器意图的 HTTP 方法 GET ： 获取资源GET 方法用来请求访问已被 URI 识别的资源。 指定的资源经服务器端解析后返回响应内容。 也就是说， 如果请求的资源是文本， 那就保持原样返回； 如果是像 CGI（Common Gateway Interface， 通用网关接口） 那样的程序， 则返回经过执行后的输出结果。 POST： 传输实体主体POST 方法用来传输实体的主体。虽然用 GET 方法也可以传输实体的主体， 但一般不用 GET 方法进行传输， 而是用 POST 方法。 虽说 POST 的功能与 GET 很相似， 但POST 的主要目的并不是获取响应的主体内容。 PUT： 传输文件PUT 方法用来传输文件。 就像 FTP 协议的文件上传一样， 要求在请求报文的主体中包含文件内容， 然后保存到请求 URI 指定的位置。 但是， 鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制， 任何人都可以上传文件 , 存在安全性问题， 因此一般的 Web 网站不使用该方法。 若配合 Web 应用程序的验证机制， 或架构设计采用。 HEAD： 获得报文首部HEAD 方法和 GET 方法一样， 只是不返回报文主体部分。 用于确认URI 的有效性及资源更新的日期时间等。 DELETE： 删除文件DELETE 方法用来删除文件， 是与 PUT 相反的方法。 DELETE 方法按请求 URI 删除指定的资源。但是， HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制， 所以一般的 Web 网站也不使用 DELETE 方法。 当配合 Web 应用程序的验证机制， 或遵守 REST 标准时还是有可能会开放使用的。 OPTIONS： 询问支持的方法OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。 TRACE： 追踪路径TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。 不长用到，不做解释。 -CONNECT： 要求用隧道协议连接代理CONNECT 方法要求在与代理服务器通信时建立隧道， 实现用隧道协议进行 TCP 通信。 主要使用 SSL（Secure Sockets Layer， 安全套接层） 和 TLS（Transport Layer Security， 传输层安全） 协议把通信内容加 密后经网络隧道传输 2.6 使用方法下达命令向请求 URI 指定的资源发送请求报文时， 采用称为方法的命令。方法的作用在于， 可以指定请求的资源按期望产生某种行为。 方法中有 GET、 POST 和 HEAD 等 2.7 持久连接节省通信量HTTP 协议的初始版本中， 每进行一次 HTTP 通信就要断开一次 TCP连接。 每次的请求都会造成无谓的 TCP 连接建立和断开， 增加通信量的开销。 2.7.1 持久连接为解决上述 TCP 连接的问题， HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections， 也称为 HTTP keep-alive 或HTTP connection reuse） 的方法。 持久连接的特点是， 只要任意一端没有明确提出断开连接， 则保持 TCP 连接状态。 持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销， 减轻了服务器端的负载。 另外， 减少开销的那部分时间， 使HTTP 请求和响应能够更早地结束， 这样 Web 页面的显示速度也就相应提高了 2.7.2 管线化持久连接使得多数请求以管线化（pipelining） 方式发送成为可能。 从前发送请求后需等待并收到响应， 才能发送下一个请求。 管线化技术出现后， 不用等待响应亦可直接发送下一个请求。 这样就能够做到同时并行发送多个请求， 而不需要一个接一个地等待响应了 2.8 使用 Cookie 的状态管理假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态） ， 那么每次跳转新页面不是要再次登录， 就是要在每次请求报文中附加参数来管理登录状态。 不可否认， 无状态协议当然也有它的优点。 由于不必保存状态， 自然可减少服务器的 CPU 及内存资源的消耗。 从另一侧面来说， 也正是因为 HTTP 协议本身是非常简单的， 所以才会被应用在各种场景里 保留无状态协议这个特征的同时又要解决类似的矛盾问题， 于是引入了 Cookie 技术。 Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息， 通知客户端保存 Cookie。 当下次客户端再往该服务器发送请求时， 客户端会自动在请求报文中加入 Cookie 值后发送出去。 服务器端发现客户端发送过来的 Cookie 后， 会去检查究竟是从哪一个客户端发来的连接请求， 然后对比服务器上的记录， 最后得到之前的状态信息。 HTTP 请求报文和响应报文的内容如下：","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"https://www.kaige1220.top/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.kaige1220.top/tags/HTTP/"}]},{"title":"HTTP笔记实录","slug":"http笔记实录","date":"2018-06-26T06:47:55.140Z","updated":"2018-06-26T13:31:09.161Z","comments":true,"path":"2018/06/26/http笔记实录/","link":"","permalink":"https://www.kaige1220.top/2018/06/26/http笔记实录/","excerpt":"一、了解Web及网络基础1.1 使用 HTTP 协议访问 Web当我们在网页浏览器（Web browser） 的地址栏中输入 URL时， Web 页面是如何呈现的？ 根据 Web 浏览器地址栏中指定的URL， Web 浏览器从 Web 服务器端获取文件资源（resource）等信息， 从而显示出 Web 页面。像这种通过发送请求获取服务器资源的 Web 浏览器等， 都可称为客户端（client） 。 Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。可以说，Web是建立在 HTTP 协议上通信的。","text":"一、了解Web及网络基础1.1 使用 HTTP 协议访问 Web当我们在网页浏览器（Web browser） 的地址栏中输入 URL时， Web 页面是如何呈现的？ 根据 Web 浏览器地址栏中指定的URL， Web 浏览器从 Web 服务器端获取文件资源（resource）等信息， 从而显示出 Web 页面。像这种通过发送请求获取服务器资源的 Web 浏览器等， 都可称为客户端（client） 。 Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。可以说，Web是建立在 HTTP 协议上通信的。 提出了3项 WWW 构建技术： 分别是： 把 SGML（Standard Generalized Markup Language， 标准通用标记语言） 作为页面的文本标记语言的 HTML（HyperText Markup Language， 超文本标记语言） ； 作为文档传递协议的 HTTP ； 指定文档所在地址的 URL（Uniform Resource Locator， 统一资源定位符） 。 1.2 网络基础 TCP/IP通常使用的网络（包括互联网） 是在 TCP/IP 协议族的基础上运作的。 而 HTTP 属于它内部的一个子集。 1.2.1 TCP/IP 协议族 计算机与网络设备要相互通信， 双方就必须基于相同的方法。 协议中存在各式各样的内容。 从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、 双方建立通信的顺序， 以及 Web 页面显示需要处理的步骤， 等等。 像这样把与互联网相关联的协议集合起来总称为 TCP/IP。 1.2.2 TCP/IP 的分层管理TCP/IP 协议族里重要的一点就是分层。 TCP/IP 协议族按层次分别分为以下 4 层： 应用层 传输层 网络层 数据链路层 把 TCP/IP 层次化是有好处的。 比如， 如果互联网只由一个协议统筹， 某个地方需要改变设计时， 就必须把所有部分整体替换掉。 而分层之后只需把变动的层替换掉即可。 把各层之间的接口部分规划好之后， 每个层次内部的设计就能够自由改动了。 TCP/IP 协议族各层的作用如下。应用层: 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。 比如， FTP（FileTransfer Protocol， 文件传输协议） 和 DNS（Domain Name System， 域名系统） 服务就是其中两类。 HTTP 协议也处于该层。 传输层： 传输层对上层应用层， 提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议： TCP（Transmission Control Protocol， 传输控制协议）和 UDP（User Data Protocol， 用户数据报协议。 网络层（ 又名网络互连层）： 网络层用来处理在网络上流动的数据包。 数据包是网络传输的最小数据单位。 该层规定了通过怎样的路径（所谓的传输路线） 到达对方计算机， 并把数据包传送给对方。 与对方计算机之间通过多台计算机或网络设备进行传输时， 网络层所起的作用就是在众多的选项内选择一条传输路线。 链路层（ 又名数据链路层， 网络接口层）： 用来处理连接网络的硬件部分。 包括控制操作系统、 硬件的设备驱动、 NIC（Network Interface Card， 网络适配器， 即网卡） ， 及光纤等物理可见部分（还包括连接器等一切传输媒介） 。 硬件上的范畴均在链路层的作用范围之内。 1.2.3 TCP/IP 通信传输流 利用 TCP/IP 协议族进行网络通信时， 会通过分层顺序与对方进行通信。 发送端从应用层往下走，接收端则往应用层往上走。 我们用 HTTP 举例来说明， 首先作为发送端的客户端在应用层（HTTP 协议） 发出一个想看某个 Web 页面的 HTTP 请求。 接着， 为了传输方便， 在传输层（TCP 协议） 把从应用层处收到的数据（HTTP 请求报文） 进行分割， 并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP 协议） ， 增加作为通信目的地的 MAC 地址后转发给链路层。 这样一来， 发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据， 按序往上层发送， 一直到应用层。 当传输到应用层， 才能算真正接收到由客户端发送过来的 HTTP请求 1.3 与 HTTP 关系密切的协议 : IP、 TCP 和 DNS1.3.1 负责传输的 IP 协议按层次分， IP（Internet Protocol） 网际协议位于网络层。 可能有人会把“IP”和“IP 地址”搞混， “IP”其实是一种协议的名称。 IP 协议的作用是把各种数据包传送给对方。 而要保证确实传送到对方那里， 则需要满足各类条件。 其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address） 。 IP 地址指明了节点被分配到的地址， MAC 地址是指网卡所属的固定地址。 IP 地址可以和 MAC 地址进行配对。 IP 地址可变换， 但 MAC地址基本上不会更改。 IP 间的通信依赖 MAC 地址。 在网络上， 通信的双方在同一局域网（LAN） 内的情况是很少的， 通常是经过多台计算机和网络设备中转才能连接到对方。 而在进行中转时， 会利用下一站中转设备的 MAC地址来搜索下一个中转目标。 这时， 会采用 ARP 协议（AddressResolution Protocol） 。 ARP 是一种用以解析地址的协议， 根据通信方的 IP 地址就可以反查出对应的 MAC 地址。 在到达通信目标前的中转过程中， 那些计算机和路由器等网络设备只能获悉很粗略的传输路线。 这种机制称为路由选择（routing） ， 有点像快递公司的送货过程。 想要寄快递的人， 只要将自己的货物送到集散中心， 就可以知道快递公司是否肯收件发货， 该快递公司的集散中心检查货物的送达地址， 明确下站该送往哪个区域的集散中心。 接着， 那个区域的集散中心自会判断是否能送到对方的家中。 1.3.2 确保可靠性的 TCP 协议按层次分， TCP 位于传输层， 提供可靠的字节流服务。 所谓的字节流服务（Byte Stream Service） 是指， 为了方便传输， 将大块数据分割成以报文段（segment） 为单位的数据包进行管理。 而可靠的传输服务是指， 能够把数据准确可靠地传给对方。 一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割， 而且 TCP 协议能够确认数据最终是否送达到对方。 确保数据能到达目标 为了准确无误地将数据送达目标处， TCP 协议采用了三次握手（three-way handshaking） 策略。 用 TCP 协议把数据包送出去后， TCP不会对传送后的情况置之不理， 它一定会向对方确认是否成功送达。 握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。 发送端首先发送一个带 SYN 标志的数据包给对方。 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。 最后， 发送端再回传一个带 ACK 标志的数据包， 代表“握手”结束。 若在握手过程中某个阶段莫名中断， TCP 协议会再次以相同的顺序发送相同的数据包 1.4 负责域名解析的 DNS 服务DNS（Domain Name System） 服务是和 HTTP 协议一样位于应用层的协议。 它提供域名到 IP 地址之间的解析服务。 计算机既可以被赋予 IP 地址， 也可以被赋予主机名和域名。 比如 www.hackr.jp。 用户通常使用主机名或域名来访问对方的计算机， 而不是直接通过 IP地址访问。 因为与 IP 地址的一组纯数字相比， 用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。 但要让计算机去理解名称， 相对而言就变得困难了。 因为计算机更擅长处理一长串数字。为了解决上述的问题， DNS 服务应运而生。 DNS 协议提供通过域名查找 IP 地址， 或逆向从 IP 地址反查域名的服务。 1.5 各种协议与 HTTP 协议的关系学习了和 HTTP 协议密不可分的 TCP/IP 协议族中的各种协议后， 我们再通过这张图来了解下 IP 协议、 TCP 协议和 DNS 服务在使用HTTP 协议的通信过程中各自发挥了哪些作用 1.6 URI 和 URL与 URI（统一资源标识符） 相比， 我们更熟悉 URL（UniformResource Locator， 统一资源定位符） 。 URL正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。 比如， 下图的 http://hackr.jp/ 就是 URL。 1.6.1 统一资源标识符URI 是 Uniform Resource Identifier 的缩写。 RFC2396 分别对这 3 个单词进行了如下定义： Uniform 规定统一的格式可方便处理多种不同类型的资源， 而不用根据上下文环境来识别资源指定的访问方式。 另外， 加入新增的协议方案（如http: 或 ftp:） 也更容易。 Resource 资源的定义是“可标识的任何东西”。 除了文档文件、 图像或服务（例如当天的天气预报） 等能够区别于其他类型的， 全都可作为资源。 另外， 资源不仅可以是单一的， 也可以是多数的集合体。 Identifier 表示可标识的对象。 也称为标识符。 采用 HTTP 协议时， 协议方案就是 http。 除此之外， 还有 ftp、mailto、 telnet、 file 等。 URI 用字符串标识某一互联网资源， 而 URL表示资源的地点（互联网上所处的位置） 。 可见 URL是 URI 的子集。 1.6.2 URI 格式让我们先来了解一下绝对 URI 的格式 使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。 不区分字母大小写， 最后附一个冒号（:） 。 登录信息（ 认证）指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证） 。 此项是可选项。 服务器地址使用绝对 URI 必须指定待访问的服务器地址。 地址可以是类似hackr.jp 这种 DNS 可解析的名称， 或是 192.168.1.1 这类 IPv4 地址名， 还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。 服务器端口号指定服务器连接的网络端口号。 此项也是可选项， 若用户省略则自动使用默认端口号。 带层次的文件路径指定服务器上的文件路径来定位特指的资源。 这与 UNIX 系统的文件目录结构相似。 -查询字符串针对已指定的文件路径内的资源， 可以使用查询字符串传入任意参数。 此项可选。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"https://www.kaige1220.top/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.kaige1220.top/tags/HTTP/"}]},{"title":"理解Promise","slug":"理解promise","date":"2018-06-26T01:03:29.328Z","updated":"2018-06-26T06:43:41.986Z","comments":true,"path":"2018/06/26/理解promise/","link":"","permalink":"https://www.kaige1220.top/2018/06/26/理解promise/","excerpt":"","text":"Promise in js 回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。而 Promise 很好地解决了这一切。 另外解决回调地狱的问题。 所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。 Promise 对象有以下两个特点。（1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。 Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 12345678910111213var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(value) &#123; // failure&#125;); Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 方法和 reject 方法。 如果异步操作成功，则用 resolve 方法将 Promise 对象的状态，从「未完成」变为「成功」（即从 pending 变为 resolved）； 如果异步操作失败，则用 reject 方法将 Promise 对象的状态，从「未完成」变为「失败」（即从 pending 变为 rejected）。 基本的 api: Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() // 所有的完成 1var p = Promise.all([p1,p2,p3]); Promise.race() // 竞速，完成一个即可 进阶promises 的奇妙在于给予我们以前的 return 与 throw，每个 Promise 都会提供一个 then() 函数，和一个 catch()，实际上是 then(null, …) 函数， 123somePromise().then(functoin()&#123; // do something &#125;); 我们可以做三件事， return 另一个 promise return 一个同步的值 (或者 undefined) throw 一个同步异常 throw new Eror(‘’); 封装同步与异步代码 12 new Promise(function (resolve, reject) {resolve(someValue);});1写成 Promise.resolve(someValue);12","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"理解Promise","slug":"技术/理解Promise","permalink":"https://www.kaige1220.top/categories/技术/理解Promise/"}],"tags":[{"name":"理解Promise","slug":"理解Promise","permalink":"https://www.kaige1220.top/tags/理解Promise/"}]},{"title":"npm 再了解","slug":"NPM再了解","date":"2018-06-25T03:09:34.699Z","updated":"2018-06-25T03:21:01.236Z","comments":true,"path":"2018/06/25/NPM再了解/","link":"","permalink":"https://www.kaige1220.top/2018/06/25/NPM再了解/","excerpt":"虽然之前已经学习并使用过npm了，这篇文章主要为了总结并学习的。","text":"虽然之前已经学习并使用过npm了，这篇文章主要为了总结并学习的。 npm模块管理器npm的出现则是为了在CommonJS规范的基础上，实现解决包的安装卸载，依赖管理，版本管理等问题,npm不需要单独安装。在安装Node的时候，会连带一起安装npm 允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 npm包一个符合CommonJS规范的包应该是如下这种结构： 一个package.json文件应该存在于包顶级目录下 二进制文件应该包含在bin目录下。 JavaScript代码应该包含在lib目录下。 文档应该在doc目录下。 单元测试应该在test目录下 package.json name：包名，需要在NPM上是唯一的，小写字母和数字组成可包含_ - .但不能有空格 description：包简介。通常会显示在一些列表中 version：版本号。一个语义化的版本号（http://semver.org/ ），通常为x.y.z。该版本号十分重要，常常用于一些版本控制的场合 keywords：关键字数组。用于NPM中的分类搜索 maintainers：包维护者的数组。数组元素是一个包含name、email、web三个属性的JSON对象 contributors：包贡献者的数组。第一个就是包的作者本人。在开源社区，如果提交的patch被merge进master分支的话，就应当加上这 个贡献patch的人。格式包含name和email bugs：一个可以提交bug的URL地址。可以是邮件地址（mailto:mailxx@domain），也可以是网页地址 licenses：包所使用的许可证 repositories：托管源代码的地址数组 dependencies：当前包需要的依赖。这个属性十分重要，NPM会通过这个属性，帮你自动加载依赖的包 npm的使用查看各种信息 1234567891011# 查看 npm 命令列表$ npm help# 查看各个命令的简单用法$ npm -l# 查看 npm 的版本$ npm -v# 查看 npm 的配置$ npm config list -l npm 命令安装模块Node模块采用npm install命令安装。 每个模块可以“全局安装”，也可以“本地安装”。“全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块。“本地安装”指的是将一个模块下载到当前项目的node_modules子目录，然后只有在项目目录之中，才能调用这个模块。 本地安装$ npm install 全局安装$ sudo npm install -global $ sudo npm install -g 指定所安装的模块属于哪一种性质的依赖关系 –save：模块名将被添加到dependencies，可以简化为参数-S。 –save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。 $ npm install –save$ npm install –save-dev 卸载模块我们可以使用以下命令来卸载 Node.js 模块 $ npm uninstall 更新模块我们可以使用以下命令来卸载 Node.js 模块 $ npm update 创建模块我们可以使用以下命令来创建 Node.js 模块 $ npm init npm init创建模块会在交互命令行帮我们生产package.json文件12345678910111213141516171819202122232425262728293031$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt; --save` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.name: (node_modules) test # 模块名version: (1.0.0) description: Node.js 测试模块 # 描述entry point: (index.js) test command: make testgit repository: https://github.com/test/test.git # Github 地址keywords: author: license: (ISC) About to write to ……/node_modules/package.json: # 生成地址&#123; &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Node.js 测试模块&quot;, ……&#125;Is this ok? (yes) yes 模块发布发布模块前首先要在npm注册用户 $ npm adduserUsername: liuxingPassword:Email: (this IS public) ogilhinn@gmail.com 然后 $ npm publish现在我们的npm包就成功发布了。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"npm","slug":"技术/npm","permalink":"https://www.kaige1220.top/categories/技术/npm/"}],"tags":[{"name":"Rnpm","slug":"Rnpm","permalink":"https://www.kaige1220.top/tags/Rnpm/"}]},{"title":"JS事件循环","slug":"JS关于事件循环","date":"2018-06-25T02:11:34.216Z","updated":"2018-06-25T02:33:18.949Z","comments":true,"path":"2018/06/25/JS关于事件循环/","link":"","permalink":"https://www.kaige1220.top/2018/06/25/JS关于事件循环/","excerpt":"","text":"一、为什么JavaScript是单线程？JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 二、任务队列单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待 状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 下图就是主线程和任务队列的示意图。 三、事件和回调函数“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"JS事件循环","slug":"技术/JavaScript/JS事件循环","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/JS事件循环/"}],"tags":[{"name":"JS事件循环","slug":"JS事件循环","permalink":"https://www.kaige1220.top/tags/JS事件循环/"}]},{"title":"meta标签常用属性整理","slug":"meta标签常用属性整理","date":"2018-06-24T12:05:43.335Z","updated":"2018-06-24T12:45:31.383Z","comments":true,"path":"2018/06/24/meta标签常用属性整理/","link":"","permalink":"https://www.kaige1220.top/2018/06/24/meta标签常用属性整理/","excerpt":"概要： 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。","text":"概要： 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 SEO优化 页面关键词，每个网页应具有描述该网页内容的一组唯一的关键字。使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过 874 个字符。 1&lt;meta name=\"keywords\" content=\"your tags\" /&gt; 页面描述，每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。 1&lt;meta name=\"description\"content=\"150 words\" /&gt; 搜索引擎索引方式，robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。 123456789&lt;meta name=\"robots\" content=\"index,follow\" /&gt; &lt;!-- all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。 --&gt; 页面重定向和刷新：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。 1&lt;meta http-equiv=\"refresh\" content=\"0;url=\" /&gt; 其他 1234&lt;meta name=\"author\" content=\"author name\" /&gt; &lt;!-- 定义网页作者 --&gt; &lt;meta name=\"google\" content=\"index,follow\" /&gt; &lt;meta name=\"googlebot\" content=\"index,follow\" /&gt; &lt;meta name=\"verify\" content=\"index,follow\" /&gt; 移动设备 viewport：能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。 大部分4.7-5寸设备的viewport宽设为360px；5.5寸设备设为400px；iphone6设为375px；ipone6 plus设为414px。 12&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no\"/&gt; &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 --&gt; width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素） height：高度（数值 / device-height）（范围从223 到10,000） initial-scale：初始的缩放比例 （范围从&gt;0 到10） minimum-scale：允许用户缩放到的最小比例 maximum-scale：允许用户缩放到的最大比例 user-scalable：用户是否可以手动缩 (no,yes) minimal-ui：可以在页面加载时最小化上下状态栏。（已弃用） WebApp全屏模式：伪装app，离线应用。 1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; &lt;!-- 启用 WebApp 全屏模式 --&gt; 隐藏状态栏/设置状态栏颜色：只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。 &lt;meta name=”apple-mobile-web-app-status-bar-style”content=”black-translucent” /&gt; 添加到主屏后的标题 &lt;meta name=”apple-mobile-web-app-title”content=”标题”&gt; 网页相关 申明编码 优先使用 IE 最新版本和 Chrome 12345&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; &lt;!-- 关于X-UA-Compatible --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=6\" &gt;&lt;!-- 使用IE6 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\" &gt;&lt;!-- 使用IE7 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\" &gt;&lt;!-- 使用IE8 --&gt; 浏览器内核控制：国内浏览器很多都是双内核（webkit和Trident），webkit内核高速浏览，IE内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。 禁止浏览器从本地计算机的缓存中访问页面内容：这样设定，访问者将无法脱机浏览。 -站点适配：主要用于PC-手机页的对应关系。12345&lt;meta name=\"mobile-agent\"content=\"format=[wml|xhtml|html5];url=url\"&gt; &lt;!-- [wml|xhtml|html5]根据手机页的协议语言，选择其中一种； url=\"url\" 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。 --&gt; &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"html meta","slug":"技术/html-meta","permalink":"https://www.kaige1220.top/categories/技术/html-meta/"}],"tags":[{"name":"html","slug":"html","permalink":"https://www.kaige1220.top/tags/html/"},{"name":"meta属性","slug":"meta属性","permalink":"https://www.kaige1220.top/tags/meta属性/"}]},{"title":"JS需要了解的一些知识","slug":"JS你需要了解的知识","date":"2018-06-24T10:19:14.314Z","updated":"2018-06-24T10:32:57.020Z","comments":true,"path":"2018/06/24/JS你需要了解的知识/","link":"","permalink":"https://www.kaige1220.top/2018/06/24/JS你需要了解的知识/","excerpt":"","text":"1、JS非常重要的两种变成范例：JavaScript是一种多范式语言，支持与OOP（面向对象编程）和函数式编程一起的命令式/过程式编程。JavaScript支持原型继承的 OOP 。 2、函数式编程与面向对象编程有什么优缺点面向对象的优点：很容易理解对象的基本概念，并易于解释方法调用的含义。面向对象程序员倾向于使用命令式的风格，而不是声明式的风格，这种风格读起来就像是一套简单易懂的计算机指令。 OOP缺点： OOP通常取决于共享状态。对象和行为通常在同一个实体上加在一起，这可以通过任意数量的具有非确定性顺序的函数随机访问，这可能会导致不良行为，例如竞争条件。 FP优点：使用功能范例，程序员可以避免任何共享状态或副作用，从而消除由于多个功能竞争相同资源而导致的错误。由于具有诸如可用的无点式（又名默认编程）等功能，与OOP相比，功能倾向于从根本上简化并且容易为更一般的可重用代码重新组合。 FP也趋向于支持声明和指称的风格，不拼出来的操作一步一步的指示，而是专注于怎样做，让底层的功能采取的护理如何。这为重构和性能优化留下了巨大的自由度，甚至允许用很少的代码更改替换具有更高效率的整个算法。（例如，记忆或使用懒惰的评估来取代急切的评估。） 使用纯函数的计算也很容易跨多个处理器或分布式计算集群扩展，而不用担心线程资源冲突，竞争条件等等。 FP缺点：过度利用FP功能（如无点式和大型组合）可能会降低可读性，因为生成的代码通常更抽象地指定，更简洁且不太具体。 越来越多的人熟悉面向对象和命令式编程，而不是函数式编程，所以即使在函数式编程中常见的习惯用法也会让新的团队成员感到困惑。 与OOP相比，FP的学习曲线更加陡峭，因为OOP的广泛流行使得OOP的语言和学习材料变得更加对话，而FP的语言更趋于学术化和形式化。FP概念经常被写成关于使用lambda微积分，代数和类别理论中的习语和符号，所有这些都需要在这些领域中有先验知识基础来加以理解。 3、什么是双向数据绑定和单向数据流，它们有什么不同？双向数据绑定意味着UI字段会动态绑定到模型数据，以便在UI字段更改时，模型数据随之更改，反之亦然。 数据流的一种方式意味着该模型是真相的唯一来源。用户界面触发消息中的变化，将用户意图指示给模型（或React中的“存储”）。只有模型有权更改应用程序的状态。其效果是数据总是以单一方向流动，这使得它更易于理解。 数据流的一种方式是确定性的，而双向绑定会导致难以遵循和理解的副作用。 React是单向数据流的新规范示例，因此提及React是一个很好的信号。Cycle.js是另一种单向数据流的流行实现。Angular是一个使用双向绑定的流行框架。","categories":[{"name":"前段知识","slug":"前段知识","permalink":"https://www.kaige1220.top/categories/前段知识/"},{"name":"基础知识","slug":"前段知识/基础知识","permalink":"https://www.kaige1220.top/categories/前段知识/基础知识/"}],"tags":[{"name":"JS基础知识","slug":"JS基础知识","permalink":"https://www.kaige1220.top/tags/JS基础知识/"}]},{"title":"JavaScript设计模式","slug":"设计模式","date":"2018-06-24T09:27:32.254Z","updated":"2018-06-24T10:16:30.266Z","comments":true,"path":"2018/06/24/设计模式/","link":"","permalink":"https://www.kaige1220.top/2018/06/24/设计模式/","excerpt":"构造函数模式12345678910111213/** * 构造一个动物的函数 */function Animal(name, color) &#123; this.name = name; this.color = color; this.getName = function() &#123; return this.name; &#125;;&#125;// 实例一个对象var cat = new Animal('猫', '白色');console.log(cat.getName());","text":"构造函数模式12345678910111213/** * 构造一个动物的函数 */function Animal(name, color) &#123; this.name = name; this.color = color; this.getName = function() &#123; return this.name; &#125;;&#125;// 实例一个对象var cat = new Animal('猫', '白色');console.log(cat.getName()); 工厂模式工厂模式的定义：提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象）。创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。工厂就是把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合(也就是相互影响) 1234567891011121314/** * 工厂模式 */function Animal(opts) &#123; var obj = new Object(); obj.name = opts.name; obj.color = opts.color; obj.getInfo = function() &#123; return '名称：' + obj.name + '， 颜色：' + obj.color; &#125;; return obj;&#125;var cat = Animal(&#123; name: '波斯猫', color: '白色' &#125;);cat.getInfo(); 模块模式123456789101112131415161718/** * 模块模式 = 封装大部分代码，只暴露必需接口 */var Car = (function() &#123; var name = '法拉利'; function sayName() &#123; console.log(name); &#125; function getColor(name) &#123; console.log(name); &#125; return &#123; name: sayName, color: getColor, &#125;;&#125;)();Car.name();Car.color('红色'); 混合模式12345678910111213141516171819202122232425262728293031/** * 混合模式 = 原型模式 + 构造函数模式 */function Animal(name, color) &#123; this.name = name; this.color = color; console.log(this.name + this.color);&#125;Animal.prototype.getInfo = function() &#123; console.log('名称：' + this.name);&#125;;function largeCat(name, color) &#123; Animal.call(null, name, color); this.color = color;&#125;largeCat.prototype = create(Animal.prototype);function create(parentObj) &#123; function F() &#123;&#125; F.prototype = parentObj; return new F();&#125;largeCat.prototype.getColor = function() &#123; return this.color;&#125;;var cat = new largeCat('Persian', '白色');console.log(cat); 单例模式单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点。也可以说单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 12345678910111213141516171819202122232425262728/** * 在执行当前 Single 只获得唯一一个对象 */var Single = (function() &#123; var instance; function init() &#123; //define private methods and properties //do something return &#123; //define public methods and properties &#125;; &#125; return &#123; // 获取实例 getInstance: function() &#123; if (!instance) &#123; instance = init(); &#125; return instance; &#125;, &#125;;&#125;)();var obj1 = Single.getInstance();var obj2 = Single.getInstance();console.log(obj1 === obj2); 发布订阅模式定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。它需要一种高级的抽象策略，以便订阅者能够彼此独立地发生改变，而发行方能够接受任何有消费意向的订阅者。 发布订阅模式的流程如下： 确定谁是发布者(比如我的博客)。 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者。 发布消息，发布者需要遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 退订（比如不想再接收到这些订阅的信息了，就可以取消掉） 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 发布订阅模式 */var EventCenter = (function() &#123; var events = &#123;&#125;; /* &#123; my_event: [&#123;handler: function(data)&#123;xxx&#125;&#125;, &#123;handler: function(data)&#123;yyy&#125;&#125;] &#125; */ // 绑定事件 添加回调 function on(evt, handler) &#123; events[evt] = events[evt] || []; events[evt].push(&#123; handler: handler, &#125;); &#125; function fire(evt, arg) &#123; if (!events[evt]) &#123; return; &#125; for (var i = 0; i &lt; events[evt].length; i++) &#123; events[evt][i].handler(arg); &#125; &#125; function off(evt) &#123; delete events[evt]; &#125; return &#123; on: on, fire: fire, off: off, &#125;;&#125;)();var number = 1;EventCenter.on('click', function(data) &#123; console.log('click 事件' + data + number++ + '次');&#125;);EventCenter.off('click'); // 只绑定一次EventCenter.on('click', function(data) &#123; console.log('click 事件' + data + number++ + '次');&#125;);EventCenter.fire('click', '绑定');","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript设计模式","slug":"技术/JavaScript设计模式","permalink":"https://www.kaige1220.top/categories/技术/JavaScript设计模式/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://www.kaige1220.top/tags/JS/"},{"name":"JavaScript设计模式","slug":"JavaScript设计模式","permalink":"https://www.kaige1220.top/tags/JavaScript设计模式/"}]},{"title":"JS作用域的理解","slug":"js作用域的理解","date":"2018-06-24T04:17:58.590Z","updated":"2018-06-24T10:17:09.803Z","comments":true,"path":"2018/06/24/js作用域的理解/","link":"","permalink":"https://www.kaige1220.top/2018/06/24/js作用域的理解/","excerpt":"1.执行环境（execution context）执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有与之对应的变量对象（variable object），保存着该环境中定义的所有变量和函数。我们无法通过代码来访问变量对象，但是解析器在处理数据时会在后台使用到它。 执行环境有全局执行环境（也称全局环境）和函数执行环境之分。执行环境如其名是在运行和执行代码的时候才存在的，所以我们运行浏览器的时候会创建全局的执行环境，在调用函数时，会创建函数执行环境。","text":"1.执行环境（execution context）执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有与之对应的变量对象（variable object），保存着该环境中定义的所有变量和函数。我们无法通过代码来访问变量对象，但是解析器在处理数据时会在后台使用到它。 执行环境有全局执行环境（也称全局环境）和函数执行环境之分。执行环境如其名是在运行和执行代码的时候才存在的，所以我们运行浏览器的时候会创建全局的执行环境，在调用函数时，会创建函数执行环境。 1.1 全局执行环境 全局执行环境是最外围的一个执行环境，在web浏览器中，我们可以认为他是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。代码载入浏览器时，全局环境被创建，关闭网页或者关闭浏览时全局环境被销毁。 1.2 函数执行环境 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中，当函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境。 2 作用域、作用域链2.1 全局作用域（globe scope）和局部作用域（local scope） 全局作用域可以在代码中的任何地方都能被访问，例如： 1234567891 var name1=\"haha\";2 function changName()&#123;3 var name2=\"xixi\";4 console.log(name1); // haha5 console.log(name2);// xixi6 &#125; 7 changName();8 console.log(name1);//haha9 console.log(name2);//Uncaught ReferenceError: name2 is not defined 局部作用域一般只在固定的代码片段内可以访问得到，例如上述代码中的name2，只有在函数内部可以访问得到。 2.2 作用域链（scope chain）全局作用域和局部作用域中变量的访问权限，其实是由作用域链决定的。 每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。作用域链是函数被创建的作用域中对象的集合。作用域链可以保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链的最前端始终是当前执行的代码所在环境的变量对象（如果该环境是函数，则将其活动对象作为变量对象），下一个变量对象来自包含环境（包含当前还运行环境的环境），下一个变量对象来自包含环境的包含环境，依次往上，直到全局执行环境的变量对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。 标识符解析是沿着作用域一级一级的向上搜索标识符的过程。搜索过程始终是从作用域的前端逐地向后回溯，直到找到标识符（找不到，就会导致错误发生）。 例如： 12345678910111213141516171819202122var name1 = \"haha\";function changeName()&#123; var name2=\"xixi\"; function swapName()&#123; console.log(name1);//haha console.log(name2);//xixi var tempName=name2; name2=name1; name1=tempName; console.log(name1);//xixi console.log(name2);//haha console.log(tempName);//xixi &#125; swapName(); console.log(name1);//haha console.log(name2);//xixi //console.log(tempName);抛出错误：Uncaught ReferenceError: tempName is not defined&#125;changName();console.log(name1);//console.log(name2); 抛出错误：Uncaught ReferenceError: name2 is not defined//console.log(tempName);抛出错误：Uncaught ReferenceError: tempName is not defined 上述代码中，一共有三个执行环境：全局环境、changeName()的局部环境和 swapName() 的局部环境。所以， 1.函数 swapName()的作用域链包含三个对象：自己的变量对象—–&gt;changeName()局部环境的变量对象 —–&gt;全局环境的变量对象。 2.函数changeName()的作用域包含两个对象：自己的变量对象—–&gt;全局环境的变量对象。 函数的局部环境可以访问函数作用域中的变量，也可以访问和操作父环境（包含环境）乃至全局环境中的变量。 父环境只能访问其包含环境和自己环境中的变量和函数，不能访问其子环境中的变量和函数。 全局环境只能访问全局环境中的变量和函数，不能直接访问局部环境中的任何数据。 3.提升（hoisting）变量提升： 把变量放在最前面，单线程执行，不提升，可能读取不到！","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"js作用域","slug":"技术/js作用域","permalink":"https://www.kaige1220.top/categories/技术/js作用域/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"js作用域","slug":"js作用域","permalink":"https://www.kaige1220.top/tags/js作用域/"}]},{"title":"React-Router","slug":"React.Router","date":"2018-06-24T03:45:45.140Z","updated":"2018-06-25T14:03:41.488Z","comments":true,"path":"2018/06/24/React.Router/","link":"","permalink":"https://www.kaige1220.top/2018/06/24/React.Router/","excerpt":"主要用来管理页面跳转 首先是安装Router：直接npm 安装即可。 1、代码的逻辑结构： 首页 详情页、主题部分共享于首页 列表页面 其他平级页面 2、控制页面的层级结构","text":"主要用来管理页面跳转 首先是安装Router：直接npm 安装即可。 1、代码的逻辑结构： 首页 详情页、主题部分共享于首页 列表页面 其他平级页面 2、控制页面的层级结构 3、单页面构建Root控制12345678910111213141516171819202122232425262728import React from 'react';import ReactDom from 'react-dom';import Index from './index';import ComponentList from './components/list';import &#123;Router,Route,hashHistory&#125; from 'react-router';export default class Root extends React.Component&#123; render()&#123; return( //这里替换了之前的Index,变成了程序的入口 &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route component=&#123;Index&#125; path=\"/\"&gt;&lt;/Route&gt; &lt;Route component=&#123;ComponentList&#125; path=\"list\"&gt;&lt;/Route&gt; &lt;/Router&gt; ); &#125;;&#125;//入口文件 ReactDOM.render(&lt;Root/&gt;, document.getElementById('example')); 在package.json里面改下配置 “main”:”root.js”在webpack.config.js 里面改下配置 entry: “./src/js/root.js” 另外root可以在不同的入口进行嵌套：比如在Index里面嵌套一个详情页可以着用写： 在Index页面里写入： {this.props.children} 4、页面间的跳转：首先导入必要的包： import {Link} from ‘react-router’ 加链接: 在Header 页 导航加入： &lt;Link to = {‘/‘}&gt;首页 &lt;Link to = {‘/details’}&gt;详情页 &lt;Link to = {‘/list’}&gt;列表页 5、Router 参数传递首先在router加入Id path=”list/:id” 然后在相对应的页面来接收： Id:{this.props.params.id}","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"Router","slug":"技术/Router","permalink":"https://www.kaige1220.top/categories/技术/Router/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"Router","slug":"Router","permalink":"https://www.kaige1220.top/tags/Router/"}]},{"title":"React-样式","slug":"React样式","date":"2018-06-24T02:20:32.413Z","updated":"2018-06-24T03:46:25.545Z","comments":true,"path":"2018/06/24/React样式/","link":"","permalink":"https://www.kaige1220.top/2018/06/24/React样式/","excerpt":"1、内联样式：1.1内部书写：a、首先在render里面定义变量：变量的形式： 12345678const styleComponentHeader = &#123; header: &#123; backgroundColor: '#333333', color: '#FFFFFF', 'padding-top': '15px', paddingBottom: '15px', &#125;,&#125;;","text":"1、内联样式：1.1内部书写：a、首先在render里面定义变量：变量的形式： 12345678const styleComponentHeader = &#123; header: &#123; backgroundColor: '#333333', color: '#FFFFFF', 'padding-top': '15px', paddingBottom: '15px', &#125;,&#125;; 注意上面的命名规范： 驼峰命名 paddingBottom: ‘15px’ 引号写法 ‘padding-top’: ‘15px’ 另外是属性值用引号括起来 b、然后在元素上进行引用：style={styleComponentHeader.header} 1.2 外部引用：在外部引用css文件： 在index.html里面全局应用：和正常的引用一样。 注意 class 需要更改成 className 上面两种方法的缺点： 动画、伪类 (hover) 等不能使用 1.3 内联样式的表达式首先在元素上绑定一个点击事件：onClick={this.switchHeader.bind(this)} 绑定一个函数 switchHeader 这个函数在render外面来定义： 12345678910111213//先初始化constrcutor()&#123; super(); this.state = &#123; miniHeader: false &#125;&#125;switchHeader()&#123; this.setState(&#123; miniHeader: !this.state.miniHeader; &#125;)&#125; 那我们怎么定义miniHeader的样式状态呢：可以吧他绑在我们刚才定义的样式里面 paddingBottom: (this.state.miniHeader) ? “3px” : “15px” 这里用到了三元表达式的写法 2、CSS模块化：首先安装三个模块，在配置文件先定义好，然后用npm安装即可。 这个三个模块分别是： babel-plugin-react-html-attrs 解决在react写类class不必非得用calssName style-loader css-loader 下面是配置webpack.config.js 具体配置可以看看相关的文档或者看我之前写的webpack教程。 下面是把你写的css文件导入到你制定的js文件页， 比如你写好了footer.css的样式文件，你可以把他引入到footer.js页面 引入方式： var footerCss = require(“../../css/footer.css”); 在footer.js使用它： 在你的元素上加上 这是footer页面 这里footerCSS是我们上面定义的 miniFooter是我们在footer.css里面写的。 2、jsx样式和css样式互转：css to react 在线转换","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"样式","slug":"技术/样式","permalink":"https://www.kaige1220.top/categories/技术/样式/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"样式","slug":"样式","permalink":"https://www.kaige1220.top/tags/样式/"}]},{"title":"React-组件的Refs","slug":"React组件的refs","date":"2018-06-23T14:20:39.474Z","updated":"2018-06-23T14:34:34.342Z","comments":true,"path":"2018/06/23/React组件的refs/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/React组件的refs/","excerpt":"","text":"操作DOM两种方法： 1、JS的原生写法： var myDiv =document.getElementById(‘myDiv’); ReactDOM.findDOMNode(myDiv).style.color =’green’; // 这里用到了ReactDOM 在头部先引入 import ReactDOM from ‘react-dom’ 2、在元素上定义ref=”submitButton” 然后直接可以调用了： this.refs.submitButton.style.color=”red”; Refs 是访问到组件内部 DOM 节点唯一可靠的方法 Refs 会自动销毁对子组件的引用 不要在 render 或 render 之前对 Refs 进行调用 //在事件内调用 或者render后面调用。 不要滥用 Refs","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"组件的Refs","slug":"技术/组件的Refs","permalink":"https://www.kaige1220.top/categories/技术/组件的Refs/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"组件的Refs","slug":"组件的Refs","permalink":"https://www.kaige1220.top/tags/组件的Refs/"}]},{"title":"React-可复用组件","slug":"React可复用组件","date":"2018-06-23T13:36:37.057Z","updated":"2018-06-23T14:37:23.624Z","comments":true,"path":"2018/06/23/React可复用组件/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/React可复用组件/","excerpt":"","text":"Prop 验证比如我们需要传入的是一种数字数据，我们可以用着用方法：123BodyIndex.propTypes = &#123; userid: React.PropTypes.number.isRequired&#125;; 其中我们看到用到了react里面的PropTypes 这个属性 后面跟了isRequired (这个数据类型是必须的) 默认 Prop 值const defaultProps = { text:’Hello World’ }; 使用方法：BodyIndex.defaultProps = defaultProps; 传递所有参数的快捷方式子页面代码： Component：代表的是子页面的子页面即孙页面的组件名。 {…this.props} 这个是我们从父页面传递过来的， 后面的more=”values” 就是我们新加的属性 然后在孙页面输出 {this.props.userid} {this.props.username} {this.props.id}","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"可复用组件","slug":"技术/可复用组件","permalink":"https://www.kaige1220.top/categories/技术/可复用组件/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"可复用组件","slug":"可复用组件","permalink":"https://www.kaige1220.top/tags/可复用组件/"}]},{"title":"git学习","slug":"Gitlearn1","date":"2018-06-23T12:41:05.514Z","updated":"2018-07-08T11:44:40.063Z","comments":true,"path":"2018/06/23/Gitlearn1/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/Gitlearn1/","excerpt":"1.初始化一个Git仓库，使用git init命令。 2.添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 3.要随时掌握工作区的状态，使用git status命令。 4.如果git status告诉你有文件被修改过，用git diff可以查看修改内容。","text":"1.初始化一个Git仓库，使用git init命令。 2.添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 3.要随时掌握工作区的状态，使用git status命令。 4.如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 5.版本回退： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hardcommit_id 或者用 –hard HEAD^ 这种形式回到上一个版本 上上个版本用 –hard HEAD^^ 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 6.工作区和暂存区 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 6.撤销修改命令 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 加入你已经add 了，但是还没有commit 你可以用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区： git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 接下来就是用git checkout – readme.txt 撤回工作区的修改了。 7.删除命令 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout – test.txtgit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程仓库&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 首先在github 上建立我们的远程仓库，执行git init ,然后执行命令git remote add origin git@github.com:用户名/learngit.git 建立本地和远程的链接，首先在github 上建立我们的远程仓库，然后执行命令 git remote add origin git@github.com:用户名/learngit.git 建立本地和远程的链接， 7abca23f80048498700397fdeb9cbaadcc899233 下面注意： 如果你的远程仓库里面含有README.md 而你本地的仓库没有这个文件，你需要执行 git pull –rebase origin master 先合并， 然后再执行推送本地的内容，git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 远程仓库进行克隆：git clone git@github.com:你的用户名字/gitskills.git 再本地那个文件执行就会放在哪个文件下。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 下面看看具体是怎么做的呢首先，我们创建dev分支，然后切换到dev分支：12$ git checkout -b devSwitched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：123$ git branch dev$ git checkout devSwitched to branch &apos;dev&apos; 查看所处的分支： 123$ git branch* dev master 切换回master分支： 1$ git checkout master 合并分支： 1git merge dev git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： 1$ git branch -d dev 总结： Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突准备新的feature1分支，继续我们的新分支开发： $ git checkout -b feature1 进行修改文件 在这个分支上提交 $ git add readme.txt $ git commit -m “AND simple” 切换到master分支： $ git checkout master Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行进行修改 好了，提交： $ git add readme.txt$ git commit -m “&amp; simple” 现在，master分支和feature1分支各自都分别有新的提交， 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突， 来，执行下看看： $ git merge feature1 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： 我们可以直接查看我们修改的文件的内容： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 把冲突的内容修改好，再提交 $ git add readme.txt$ git commit -m “conflict fixed” 最后，删除feature1分支： $ git branch -d feature1 总结： 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log –graph命令可以看到分支合并图。 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下–no-ff方式的git merge： 首先，仍然创建并切换dev分支： $ git checkout -b dev 修改文件并提交 $ git add readme.txt$ git commit -m “add merge” 现在，我们切换回master： $ git checkout master 准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward： $ git merge –no-ff -m “merge with no-ff” dev 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： $ git status 看到还有没提交啊 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： $ git stashSaved working directory and index state WIP on dev: f52c633 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： $ git checkout master $ git checkout -b issue-101 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： $ git add readme.txt$ git commit -m “fix bug 101” 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： $ git checkout master$ git merge –no-ff -m “merged bug fix 101” issue-101 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！ $ git checkout dev 查看下：$ git status 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： $ git stash liststash@{0}: WIP on dev: f52c633 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： $ git stash pop 再用git stash list查看，就看不到任何stash内容了 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 问题修改完bug，master的内容已经和dev上的原始内容不一样了，在完成dev和master合并的时候，就会报有内容冲突。如果bug修改量很大，冲突的内容就会很多，如果高效的解决这种冲突？ 答：把bug分支修改后再跟dev分支合并这样master和dev分支就都搞定了 为什么要用stash？一开始，我也觉得没必要，直接切换分支，再回来是一样的啊。然后测试了一把，就知道原因了。情景如下：1、在dev分支，创建一个新文件test6.txt。并add它，让它stage。2、这时切回master分支，你会看到这个test6.txt居然也在master分支里。但它实际上是属于dev分支的。怎么办？3、git stash就有作用了。切回dev分支，执行git stach。这时git bash会告诉你“Saved working directory and index state WIP on newF2: b63fbcb add test6.txtHEAD is now at b63fbcb add test6.txt”。它已经把test6.txt的现场保存好了。4、这时你在切回master分支，test6.txt就消失了。现在懂了吧。。。。为什么要用git stash。 feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： $ git checkout -b feature-vulcan 5分钟后，开发完毕： $ git add vulcan.py$ git status$ git commit -m “add feature vulcan” 切回dev，准备合并： $ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是！ 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： $ git branch -d feature-vulcanerror: The branch ‘feature-vulcan’ is not fully merged.If you are sure you want to delete it, run ‘git branch -D feature-vulcan’. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。 现在我们强行删除： $ git branch -D feature-vulcanDeleted branch feature-vulcan (was 287773e). 小结开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： $ git remote 或者，用git remote -v显示更详细的信息： 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin master如果要推送其他分支，比如dev，就改成： $ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： $ git clone git@github.com:michaelliao/learngit.git 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： $ git branch master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： $ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： $ git add env.txt $ git commit -m “add env” $ git push origin dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch –set-upstream-to=origin/dev dev 再pull： $ git pull 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： $ git commit -m “fix env conflict” $ git push origin dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to origin/。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 标签管理在Git中打标签非常简单，首先，切换到需要打标签的分支上： $ git branch devmaster$ git checkout masterSwitched to branch ‘master’ 然后，敲命令git tag 就可以打一个新标签： $ git tag v1.0 可以用命令git tag查看所有标签： $ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了：$ git log –pretty=oneline –abbrev-commit 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： $ git tag v0.9 f52c633 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show 查看标签信息： $ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)Author: Michael Liao &#x61;&#x73;&#x6b;&#120;&#x75;&#x65;&#102;&#x65;&#x6e;&#103;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;Date: Fri May 18 21:56:54 2018 +0800 add merge diff –git a/readme.txt b/readme.txt… 小结 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m “blablabla…”可以指定标签信息； 命令git tag可以查看所有标签。 操作标签如果标签打错了，也可以删除： $ git tag -d v0.1Deleted tag ‘v0.1’ (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin ： 或者，一次性推送全部尚未推送到远程的本地标签： $ git push origin –tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v0.9Deleted tag ‘v0.9’ (was f52c633)然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git [deleted] v0.9 小结 命令git push origin 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 问答：最好加上有标签了，怎么根据标签回溯版本的内容，否则只是加标签没意义呀！ 先用 git show v1.0 就能知道tag标记的这次commit的节点的id 号码；如果是 590cf6b63d1039a17869defb6b70e4fa977c073a那么就用git checkout 590cf6b（数字长度六七位就可以）就能返回这个版本。在版本之间切换的内容。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"Git学习","slug":"技术/Git学习","permalink":"https://www.kaige1220.top/categories/技术/Git学习/"}],"tags":[{"name":"Git学习","slug":"Git学习","permalink":"https://www.kaige1220.top/tags/Git学习/"}]},{"title":"JavaScript-高级函数","slug":"高阶函数","date":"2018-06-23T09:31:50.208Z","updated":"2018-06-12T13:15:03.173Z","comments":true,"path":"2018/06/23/高阶函数/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/高阶函数/","excerpt":"一、什么是JavaScript的高级函数通俗一点讲就是：函数作为参数的行为 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 123function add(x, y, f) &#123; return f(x) + f(y);&#125; 当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为： x = -5;y = 6;f = Math.abs;f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;return 11;","text":"一、什么是JavaScript的高级函数通俗一点讲就是：函数作为参数的行为 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 123function add(x, y, f) &#123; return f(x) + f(y);&#125; 当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为： x = -5;y = 6;f = Math.abs;f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;return 11; map举例说明，比如我们有一个函数$$ f(x)=x^2 $$要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下： 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果： 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results); map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串： 12var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)比方说对一个Array求和，就可以用reduce实现：1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25 filter filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] 把一个Array中的空字符串删掉，可以这么写： 12345var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);r; // ['A', 'B', 'C'] 可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。 注：trim()方法返回调用字符串对象的一个副本,但是所有起始和结尾的空格都被删除了 利用filter，可以巧妙地去除Array的重复元素： 123456789'use strict';var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;);console.log(r.toString()); // 把数组转化为字符串； sort:排序算法: 排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。 JavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊： 看上去正常的结果:1[&apos;Google&apos;, &apos;Apple&apos;, &apos;Microsoft&apos;].sort(); // [&apos;Apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;]; apple排在了最后:1[&apos;Google&apos;, &apos;apple&apos;, &apos;Microsoft&apos;].sort(); // [&apos;Google&apos;, &apos;Microsoft&quot;, &apos;apple&apos;] 无法理解的结果:1[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。 第三个排序结果是什么鬼？简单的数字排序都能错？ 这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果’10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小。 幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 要按数字大小排序，我们可以这么写： 12345678910111213'use strict';var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20] 如果要倒序排序，我们可以把大的数放前面： 12345678910var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return 1; &#125; if (x &gt; y) &#123; return -1; &#125; return 0;&#125;); // [20, 10, 2, 1] 默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：123456789101112var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) &#123; x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) &#123; return -1; &#125; if (x1 &gt; x2) &#123; return 1; &#125; return 0;&#125;); // ['apple', 'Google', 'Microsoft'] &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"高级函数","slug":"技术/JavaScript/高级函数","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/高级函数/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.kaige1220.top/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"https://www.kaige1220.top/tags/函数/"}]},{"title":"闭包","slug":"闭包","date":"2018-06-23T09:31:50.193Z","updated":"2018-06-19T02:54:00.058Z","comments":true,"path":"2018/06/23/闭包/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/闭包/","excerpt":"核心理解就两点： 1、函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 2、把私有变量封装起来，类似于java里面class的私有变量。由于JavaScript里面没有私有变量定义，所以采用闭包来封装起来。","text":"核心理解就两点： 1、函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 2、把私有变量封装起来，类似于java里面class的私有变量。由于JavaScript里面没有私有变量定义，所以采用闭包来封装起来。 我们来实现一个对Array的求和。通常情况下，求和的函数是这样定义的：1234567function sum(arr) &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;);&#125;sum([1, 2, 3, 4, 5]); // 15 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！12345678function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125; 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数： var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()调用函数f时，才真正计算求和的结果： f(); // 15 在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。 请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数： var f1 = lazy_sum([1, 2, 3, 4, 5]);var f2 = lazy_sum([1, 2, 3, 4, 5]);f1 === f2; // falsef1()和f2()的调用结果互不影响。 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 1234567891011121314151617181920function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123(function (x) &#123; return x * x;&#125;)(3); // 9 理论上讲，创建一个匿名函数并立刻执行可以这么写： function (x) { return x * x } (3); 但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来： (function (x) { return x * x }) (3); 通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写： (function (x) { return x * x;})(3); 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。 我们用JavaScript创建一个计数器： 1234567891011'use strict';function create_counter(initial) &#123; var x = initial || 0; return &#123; inc: function () &#123; x += 1; return x; &#125; &#125;&#125; 它用起来像这样： 123456789var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13 在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 闭包还可以把多参数的函数变成单参数的函数。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"闭包","slug":"技术/闭包","permalink":"https://www.kaige1220.top/categories/技术/闭包/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"https://www.kaige1220.top/tags/闭包/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2018-06-23T09:31:50.181Z","updated":"2018-06-20T00:06:57.950Z","comments":true,"path":"2018/06/23/箭头函数/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/箭头函数/","excerpt":"x =&gt; x * x 上面的箭头函数相当于： 123function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125;","text":"x =&gt; x * x 上面的箭头函数相当于： 123function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 如果参数不是一个，就需要用括号()括起来：(x, y) =&gt; x x + y y 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： 因为和函数体的{ … }有语法冲突，所以要改为： x =&gt; ({ foo: x }) 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域 12345678910var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window或undefined &#125;; return fn(); &#125;&#125;; 现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：123456789var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25 如果使用箭头函数，以前的那种hack写法： var that = this;就不再需要了。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"箭头函数","slug":"技术/箭头函数","permalink":"https://www.kaige1220.top/categories/技术/箭头函数/"}],"tags":[{"name":"箭头函数","slug":"箭头函数","permalink":"https://www.kaige1220.top/tags/箭头函数/"}]},{"title":"深入理解JS函数","slug":"深入理解JS函数","date":"2018-06-23T09:31:50.174Z","updated":"2018-06-22T09:39:55.582Z","comments":true,"path":"2018/06/23/深入理解JS函数/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/深入理解JS函数/","excerpt":"一、函数的三种角色 首先要先了解在函数本身会有一些自己的属性，比如： length：形参的个数； name：函数名； prototype：类的原型，在原型上定义的方法都是当前这个类的实例的公有方法； __proto__：把函数当做一个普通对象，指向Function这个类的原型","text":"一、函数的三种角色 首先要先了解在函数本身会有一些自己的属性，比如： length：形参的个数； name：函数名； prototype：类的原型，在原型上定义的方法都是当前这个类的实例的公有方法； __proto__：把函数当做一个普通对象，指向Function这个类的原型 函数在整个JavaScript中是最复杂也是最重要的知识，对于一个函数来说，会存在多种角色： 1234567891011121314function Fn() &#123; var num = 500; this.x = 100;&#125;Fn.prototype.getX = function () &#123; console.log(this.x);&#125;Fn.aaa = 1000;var f = new Fn;f.num // undefinedf.aaa // undefinedvar res = Fn(); // res是undefined Fn中的this是window 角色一：普通函数，对于Fn而言，它本身是一个普通的函数，执行的时候会形成私有的作用域，然后进行形参赋值、预解析、代码执行、执行完成后内存销毁； 角色二：类，它有自己的实例，f就是Fn作为类而产生的一个实例，也有一个叫做prototype的属性是自己的原型，它的实例都可以指向自己的原型； 角色三：普通对象，Fn和 var obj = {} 中的obj一样，就是一个普通的对象（所有的函数都是Function的实例），它作为对象可以有一些自己的私有属性，也可以通过proto找到Function.prototype； 二、call深入12var ary = [12, 23, 34];ary.slice(); 以上两行简单的代码的执行过程为：ary这个实例通过原型链的查找机制找到Array.prototype上的slice方法，让找到的slice方法执行，在执行slice方法的过程中才把ary数组进行了截取。 slice方法执行之前有一个在原型上查找的过程（当前实例中没有找到，再根据原型链查找）。 当知道了一个对象调用方法会有一个查找过程之后，我们再看： 12345678var obj = &#123;name:'iceman'&#125;;function fn() &#123; console.log(this); console.log(this.name);&#125;fn(); // this --&gt; window// obj.fn(); // Uncaught TypeError: obj.fn is not a functionfn.call(obj); call方法的作用：首先寻找call方法，最后通过原型链在Function的原型中找到call方法，然后让call方法执行，在执行call方法的时候，让fn方法中的this变为第一个参数值obj，最后再把fn这个函数执行。 2.2、call方法原理123456 function fn1() &#123; console.log(1);&#125;function fn2() &#123; console.log(2);&#125; 输出 fn1.call(fn2); // 1 首先fn1通过原型链查找机制找到Function.prototype上的call方法，并且让call方法执行，此时call这个方法中的this就是要操作的fn1。在call方法代码执行的过程过程中，首先让fn1中的“this关键字”变为fn2，然后再让fn1这个方法执行。 注意：在执行call方法的时候，fn1中的this的确会变为fn2，但是在fn1的方法体中输出的内容中并没有涉及到任何和this相关的内容，所以还是输出1。 apply方法、bind方法和call方法apply方法和call方法的作用是一模一样的，都是用来改变方法的this关键字，并且把方法执行，而且在严格模式下和非严格模式下，对于第一个参数是null/undefined这种情况规律也是一样的，只是传递函数的的参数的时候有区别。123456function fn(num1, num2) &#123; console.log(num1 + num2); console.log(this);&#125;fn.call(obj , 100 , 200);fn.apply(obj , [100, 200]); bind方法和apply、call稍有不同，bind方法是事先把fn的this改变为我们要想要的结果，并且把对应的参数值准备好，以后要用到了，直接的执行即可，也就是说bind同样可以改变this的指向，但和apply、call不同就是不会马上的执行。 12var tempFn = fn.bind(obj, 1, 2);tempFn(); 第一行代码只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，但是此时并没有把fn这个函数给执行，执行bind会有一个返回值，这个返回值tempFn就是把fn的this改变后的那个结果。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"深入理解JS函数","slug":"技术/深入理解JS函数","permalink":"https://www.kaige1220.top/categories/技术/深入理解JS函数/"}],"tags":[{"name":"深入理解JS函数","slug":"深入理解JS函数","permalink":"https://www.kaige1220.top/tags/深入理解JS函数/"}]},{"title":"JS方法","slug":"方法","date":"2018-06-23T09:31:50.164Z","updated":"2018-06-15T01:33:42.488Z","comments":true,"path":"2018/06/23/方法/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/方法/","excerpt":"在一个对象中绑定函数，称为这个对象的方法。 在JavaScript中，对象的定义是这样的： 1234var xiaoming = &#123; name: '小明', birth: 1990&#125;;","text":"在一个对象中绑定函数，称为这个对象的方法。 在JavaScript中，对象的定义是这样的： 1234var xiaoming = &#123; name: '小明', birth: 1990&#125;; 但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄： 1234567891011var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？ 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 12345678910111213141516'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"方法","slug":"技术/JavaScript/方法","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/方法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.kaige1220.top/tags/JavaScript/"},{"name":"方法","slug":"方法","permalink":"https://www.kaige1220.top/tags/方法/"}]},{"title":"谷歌浏览器开发工具综述","slug":"开发者工具","date":"2018-06-23T09:31:50.157Z","updated":"2018-06-14T14:17:40.549Z","comments":true,"path":"2018/06/23/开发者工具/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/开发者工具/","excerpt":"总体而言，有八个主要的工具可供查看开发工具： 元素 资源 网络 源 时间表 简介 审核 控制台","text":"总体而言，有八个主要的工具可供查看开发工具： 元素 资源 网络 源 时间表 简介 审核 控制台 你可以使用 Ctrl + [ 和 Ctrl + ] 快捷键在面板之间移动。 查阅 DOM 和格式1、实时编辑 DOM 节点 要实时编辑 DOM 节点，只需双击选定元素，然后进行更改： 2、实时编辑样式 在 Styles 窗格中实时编辑样式属性名称和值。所有样式均可修改，除了灰色部分（与 User Agent 样式表一样）。 要编辑名称或值，请点击它，进行更改，然后按 Tab 或 Enter 保存更改。 3、检查和编辑框模型参数 利用控制台进行工作JavaScript 控制台为开发者提供了测试 Web 页面和应用程序两个主要功能,其中包括： 在开发过程中记录诊断信息。 一个可与文档和工具交互的 shell 提示符。 您可以使用控制台编程接口提供的方法来记录诊断信息。如 console.log() 或 console.profile()。 您可以直接在控制台中评估表达式，并使用命令行提供的方法。这些包括使用 $() 命令选择元素或通过 profile() 方法启动 CPU 分析器命令。 JavaScript 的调试1、断点调试代码行断点在 DevTools 中设置一行代码断点： 点击 Sources 选项卡。 打开包含您想要打破的代码行的文件。 去代码的行。 行号的左边是行号列。点击它。一个蓝色图标显示在行号列的顶部。 条件行代码断点当您知道需要调查的确切代码区域时，请使用有条件的代码行断点，但只有在其他条件成立时才想暂停。 要设置条件的代码行断点： 点击 Sources 选项卡。 打开包含您想要打破的代码行的文件。 去代码的行。 行号的左边是行号列。用鼠标右键单击它。 选择添加条件断点。代码行下面会显示一个对话框。 在对话框中输入你的条件。 按 Enter 激活断点。行号列上出现橙色图标。 DOM 更改断点当您想要更改 DOM 节点或其子节点的代码时，使用 DOM 更改断点。 要设置 DOM 更改断点： 点击元素标签。 转到您想设置断点的元素。 右键单击该元素。 将鼠标悬停在 Break 上，然后选择 Subtree 修改，属性修改或节点删除。 事件监听器断点当想要暂停事件侦听器代码时，使用事件侦听器断点。您可以选择特定的事件，例如事件 click 类别，例如所有的鼠标事件。 点击 Sources 选项卡。 展开“ 事件侦听器断点”窗格。DevTools 显示事件类别的列表，例如动画。 选中这些类别中的一个可以暂停该类别的任何事件，或者展开类别并检查特定事件。 异常断点当您想暂停引发捕获或未捕获异常的代码行时，使用异常断点。 点击 Sources 选项卡。 点击暂停例外 暂停例外。启用后变成蓝色。 （可选）如果除了未捕获的异常外，还想暂停捕获的异常，请选中“ 捕获异常时暂停”复选框。 测量资源加载时间使用 Network 面板测量您的网站网络性能。 Network 面板记录页面上每个网络操作的相关信息，包括详细的耗时数据、HTTP 请求与响应标头和 Cookie，等等。 待更新","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"开发者工具","slug":"技术/开发者工具","permalink":"https://www.kaige1220.top/categories/技术/开发者工具/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://www.kaige1220.top/tags/调试/"}]},{"title":"如何优化你的网站","slug":"如何优化你的网站","date":"2018-06-23T09:31:50.131Z","updated":"2018-06-14T14:15:14.145Z","comments":true,"path":"2018/06/23/如何优化你的网站/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/如何优化你的网站/","excerpt":"1、利用浏览器缓存你的 js 和 CSS 文件： 在网站根目录 .htaccess 中加入以下代码 123 ExpiresActive on ExpiresDefault “access plus 1 year” 这段代码的意思是对 jpg|gif|png|css|js 发送 header 缓存头，进行一年的缓存、在浏览器不使用 ctrl+F5 强制刷新时，会一直缓存到时间时间结束，唯一遗憾的是如果你更改了js或者css文件必须把以前的路径或者文件名更改，可以这样 base.js?ver=(x) 这种方式下次浏览器就会自动读取并缓存。","text":"1、利用浏览器缓存你的 js 和 CSS 文件： 在网站根目录 .htaccess 中加入以下代码 123 ExpiresActive on ExpiresDefault “access plus 1 year” 这段代码的意思是对 jpg|gif|png|css|js 发送 header 缓存头，进行一年的缓存、在浏览器不使用 ctrl+F5 强制刷新时，会一直缓存到时间时间结束，唯一遗憾的是如果你更改了js或者css文件必须把以前的路径或者文件名更改，可以这样 base.js?ver=(x) 这种方式下次浏览器就会自动读取并缓存。 2、把你的 .js 库文件地址替换成 Google CDN的地址： 随着 jquery 和 mootools 等js库的使用需要加载的.js文件越来越多也越来越大，通常传统的网站是上传到网站本身的目录。但对于一个接近70多KB的jquery.js体积确实不利于网站响应速度的提升，此时就应该使用Google API 。 例如：把你的 http://www.***.cn/jquery.x.x.js 替换为 http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js，其意义在于当一个用户访问过使用 google api 的网站之后，再次访问其他调用了该api地址的网站就不需要再次加载该文件了。从而达到提速的目的。 不单是jquery库，其他诸如mootools yui 也可以使用这种方式。 3、精简和优化你的 js 和 CSS： 虽然有了缓存和gzip保驾护航，但是对于 js 和 css 的优化却也是必须的。我们写的javascript脚本和 css 代码都是经过缩进和换行的，适合人类阅读，但是浏览器执行这些脚本不并需要这些无意义的空格和换行。所以我们应该去除这一些空格换行，甚至缩短 javascript 和 css 里面的变量。诸如此类的优化工具有 YUI Compressor 和 Closure Compiler 。这两个工具都是基于 java 的，使用应该安装jdk并且设置 JAVA_HOME 。(对于非程序员的网站管理员而言确实有点困难) 此工具可以不用在本地安装jdk，直接上传 js 和 css 文件进行压缩，可选择是采用 YUI Compressor 或 Closure Compiler 。 4、GZIP 压缩你的 JS 和 CSS 文件： 压缩js和css可以通过服务器动态脚本进行也可以更简单的使用apache服务器可以在网站根目录 .htaccess 中加入以下代码 AddOutputFilterByType DEFLATE text/html text/css text/plain text/xml application/x-javascript application/json Header append Vary Accept-Encoding 这段代码的意思是调用服务器的压缩模块对以上文件输出之前进行GZIP压缩，gzip的压缩之后所有文件都应该能减少30%以上的体积。特别是对于大量使用js的博客有了gzip保驾护航之后速度能提高不少。 5、使用css sprites合并图片 一个网站经常使用小图标和小图片进行美化，但是很遗憾这些小图片占用了大量的HTTP请求，因此可以采用sprites的方式把所有的图片合并成一张图片 ，可以通过相关工具在线合并，也可以在ps中合并。 6、优化你网站图片： 大量使用的图片和图标虽然可以给网站带来美轮美奂的效果，图文混编更是一种非常绚丽的博文展现方法。可图片的体积确实不是很给力，jpg是一种有损压缩格式，而png虽然是无损的，但缺憾是体积颇大。为了减少图片体积达到最快的下载速度，每一张图片上传前应该优化一下体积。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"网站优化","slug":"技术/网站优化","permalink":"https://www.kaige1220.top/categories/技术/网站优化/"}],"tags":[{"name":"网站优化","slug":"网站优化","permalink":"https://www.kaige1220.top/tags/网站优化/"}]},{"title":"网页响应式开发3","slug":"响应式开发3","date":"2018-06-23T09:31:50.119Z","updated":"2018-06-13T11:24:51.049Z","comments":true,"path":"2018/06/23/响应式开发3/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/响应式开发3/","excerpt":"1、不使用绝对宽度由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。 具体说，CSS代码不能指定像素宽度： 1width: xx%; 或者1width:auto;","text":"1、不使用绝对宽度由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。 具体说，CSS代码不能指定像素宽度： 1width: xx%; 或者1width:auto; 2、相对大小的字体3、设置 box-sizing: border-box字体也不能使用绝对大小（px），而只能使用相对大小（em）。123body &#123; font: normal 100% Helvetica, Arial, sans-serif; &#125; 123h1 &#123; font-size: 1.5em; &#125; 4、流动布局（fluid grid）“流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。 12345678910.main &#123; float: right; width: 70%; &#125; .leftBar &#123; float: left; width: 25%; &#125; float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。 另外，绝对定位（position: absolute）的使用，也要非常小心。 5、选择加载CSS“自适应网页设计”的核心，就是CSS3引入的Media Query模块。 它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 123&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-device-width: 400px)\" href=\"tinyScreen.css\" /&gt; 上面的代码意思是，如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。 6、CSS的@media规则同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 123456789101112@media screen and (max-device-width: 400px) &#123; .column &#123; float: none; width:auto; &#125; #sidebar &#123; display:none; &#125; &#125; 上面的代码意思是，如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）。 7、图片的自适应（fluid image）除了布局和文本，”自适应网页设计”还必须实现图片的自动缩放。 这只要一行CSS代码： 1img &#123; max-width: 100%;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"https://www.kaige1220.top/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"https://www.kaige1220.top/tags/响应式开发/"}]},{"title":"网页响应式开发2","slug":"响应式开发2","date":"2018-06-23T09:31:50.103Z","updated":"2018-06-13T11:25:15.986Z","comments":true,"path":"2018/06/23/响应式开发2/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/响应式开发2/","excerpt":"遵循的一些准则和基础1、在 Viewport 里加 Meta 标签在你 HTML 的&lt;head&gt; 代码里添加 Meta 标签。它可以使 media queries 在不同设备上起作用 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;","text":"遵循的一些准则和基础1、在 Viewport 里加 Meta 标签在你 HTML 的&lt;head&gt; 代码里添加 Meta 标签。它可以使 media queries 在不同设备上起作用 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 2、理解CSS盒模型 3、设置 box-sizing: border-box在 CSS 文件最顶端设置 box-sizing。运用 * 通用选择器使其应用到页面的每个元素上。12345*, *:before, *:after &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;&#125; 4、创建容器一个容器将包含页面所有标签，并控制页面最大宽度. 运用容器，让我们的响应式设计更进了一步！ 5、创建列在移动优先里，列默认均是 block 级别的（可以占满整行的宽度）。不需要额外的样式！ 12345&lt;div class=\"container\"&gt; &lt;div class=\"column\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt;&lt;/div&gt; 6、创建列宽在大屏中，用 float: left 将列水平排列。然后运用 padding 设置相邻两列之间的间隙，忘掉传统的margin吧。 7、创建行列应该包裹在行内，以避免其他元素堆放在其旁边造成布局混乱。否则就会出现广为人知的 clearing 问题。出现之后可以使用由 Nicolas Gallagher 发明的 clearfix 解决。 12345678910111213141516171819&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213.clearfix:before,.clearfix:after &#123; content: \" \"; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 8、相对流（ Flow Opposite ）给你想让它在移动端优先显示，而在大屏幕中右侧显示的列，添加 .flow-opposite 类。 12345678910&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half flow-opposite\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123@media (min-width: 40rem) &#123; .column.flow-opposite &#123; float: right; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"https://www.kaige1220.top/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"https://www.kaige1220.top/tags/响应式开发/"}]},{"title":"网页响应式开发","slug":"响应式开发","date":"2018-06-23T09:31:50.079Z","updated":"2018-06-14T01:07:01.689Z","comments":true,"path":"2018/06/23/响应式开发/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/响应式开发/","excerpt":"一、原理定义最小宽度： // Extra small devices (portrait phones, less than 576px)// No media query since this is the default in Bootstrap // Small devices (landscape phones, 576px and up)@media (min-width: 576px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … }","text":"一、原理定义最小宽度： // Extra small devices (portrait phones, less than 576px)// No media query since this is the default in Bootstrap // Small devices (landscape phones, 576px and up)@media (min-width: 576px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … } 定义最大宽度：// Extra small devices (portrait phones, less than 576px)@media (max-width: 575.98px) { … } // Small devices (landscape phones, less than 768px)@media (max-width: 767.98px) { … } // Medium devices (tablets, less than 992px)@media (max-width: 991.98px) { … } // Large devices (desktops, less than 1200px)@media (max-width: 1199.98px) { … } // Extra large devices (large desktops)// No media query since the extra-large breakpoint has no upper bound on its width 使用逻辑混用：// Extra small devices (portrait phones, less than 576px)@media (max-width: 575.98px) { … } // Small devices (landscape phones, 576px and up)@media (min-width: 576px) and (max-width: 767.98px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) and (max-width: 991.98px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) and (max-width: 1199.98px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … } 提取模板：(用的 bootstrap)12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css\" integrity=\"sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Hello, world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.2.1.slim.min.js\" integrity=\"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js\" integrity=\"sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js\" integrity=\"sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 响应式框架介绍1、bootstrap如何安装？ 建议使用npm来安装：命令如下：12npm install bootstrap 也可以用CDN安装： CSS only 1&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\" integrity=\"sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB\" crossorigin=\"anonymous\"&gt; JS, Popper.js, and jQuery 123&lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js\" integrity=\"sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; 2、Foundation模板快速开发具体的模板，可以看bootstrap,不做详细介绍了。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"https://www.kaige1220.top/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"https://www.kaige1220.top/tags/响应式开发/"}]},{"title":"CSS 网格布局知识2","slug":"前端基础知识整理4","date":"2018-06-23T09:31:50.034Z","updated":"2018-06-11T12:57:59.131Z","comments":true,"path":"2018/06/23/前端基础知识整理4/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/前端基础知识整理4/","excerpt":"定义一个网格：Grid(网格) 模块为 display 属性提供了一个新的值：grid。当你将任何元素的 display 属性设置为 grid 时，那么这个元素就是一个 网格容器(grid container)，它的所有直接子元素就成了 网格项(grid items)。 让我们创建创建一个 3×3 的布局，做一个 Tic-Tac-Toe (井字游戏) 棋盘。 首先，我们将写一些 HTML： 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;","text":"定义一个网格：Grid(网格) 模块为 display 属性提供了一个新的值：grid。当你将任何元素的 display 属性设置为 grid 时，那么这个元素就是一个 网格容器(grid container)，它的所有直接子元素就成了 网格项(grid items)。 让我们创建创建一个 3×3 的布局，做一个 Tic-Tac-Toe (井字游戏) 棋盘。 首先，我们将写一些 HTML： 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt; .game-board div 是网格容器，而 .box div 是网格项。现在我们将通过 Grid 布局来实现 3×3 布局。 123456.game-board &#123; display: grid; grid-template-rows: 200px 200px 200px; grid-template-columns: 200px 200px 200px; &#125; grid-template-rows 属性允许我们指定网格中的行数及行的高度。那么你应该猜到另一个属性是干什么的了。 grid-template-columns 属性允许我们指定网格中的列数及列的宽度。 fr 单位(等分)fr 是为网格布局定义的一个新单位。它可以帮助你摆脱计算百分比，并将可用空间等分。 例如，如果在网格容器中设置这个规则：grid-template-rows: 2fr 3fr，那么你的网格容器将首先被分成 2 行。然后将数字部分加在一起，这里总和为 5， 即 5 等分。 就是说，我们将有 2 行：第一排占据垂直空间的 2/5 。 第二排占垂直空间的 3/5 。 回到我们的 Tic-Tac-Toe 例子，我们使用 fr 代替 px。我们想要的是，应该有3行3列。所以，我们只需要用 3 个 1fr 替换 3 个 200px 即可： 123456.game-board &#123; display: grid; grid-template-rows: 1fr 1fr 1fr; grid-template-columns: 1fr 1fr 1fr; &#125; 这里特别需要注意的是： fr 单位是等分可用空间，或者说剩余空间。看个例子: 123456789.game-board &#123; grid-gap:2px; display: grid; width:300px; height:200px; grid-template-rows: 100px 1fr 1fr; grid-template-columns: 1fr 50px 1fr; &#125; 你会看到 fr 单位是将 总的尺寸 减去 单元格明确尺寸后，在等分剩余空间。 grid-gap 是间隔。 repeat() 函数在某些情况下，我们可能有很多的列和行。在 grid-template 属性中指定每一个值可能会很乏味。幸运的是，有一个 repeat 函数，就像任何一个循环重复多少次输出某个给定值。它有两个参数。第一个是迭代次数，第二个是要重复的值。我们用 repeat 函数重写上面的例子。 123456.game-board &#123; display: grid; grid-template-rows: repeat(3, 1fr); grid-template-columns: repeat(3, 1fr); &#125; grid-template 属性grid-template 属性是 grid-template-rows 和 grid-template-columns 的简写语法。 这是它的语法： grid-template: ro ws / co lu mns; 我们上面的例子使用这个简写语法后，看起来非常整齐。 12345.game-board &#123; display: grid; grid-template: repeat(3, 1fr) / repeat(3, 1fr); &#125; 下面是具体创建的例子了：HTML 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt;&lt;/div&gt; CSS 12345678910111213141516171819202122232425.game-board&#123; width: 600px; height: 600px; margin: 0 auto; background-color: #34495e; color: #fff; border: 6px solid #2c3e50; border-radius: 10px; display: grid; grid-template: repeat(3, 1fr) / repeat(3, 1fr);&#125;.box&#123; border: 6px solid #2c3e50; border-radius: 2px; font-family: Helvetica; font-weight: bold; font-size: 4em; display: flex; justify-content: center; align-items: center;&#125; 网格线编号,网格单元格，网格轨道网格线是存在于列和行每一侧的线。一组垂直线将空间垂直划分成列，而另一组水平线将空间水平划分成行。这意味着在我们之前的例子中，有四条垂直线和四条水平线包含它们之间的行和列。 在将网格项从一个位置跨越到另一个位置时，网格线变得非常有用。 网格轨道是两条线之间的空间。 网格轨道可以是一行或一列。 网格单元格很像表格单元，是两条相邻垂直线和两条相邻水平线之间的空间。 这是网格中最小的单位。 定位网格项采取了前面的例子的网格，并用数字从1到9标记每个单元格，而不是X或O，下面是它的样子： 假设我想将第 6 个框移到第 2 个框的位置。 我们使用网格模块，改变网格中网格项的位置是一件轻而易举的事情。 要将第6个框移到第2个框的位置，我们必须确切知道第2个框在哪里。通过网格线编号的帮助，我们可以很容易地找到这个位置。第二个方框位于第2条列网格线之后，第3条列网格线之前，第1条行网格线之下，第2条行网格线之上。现在我们可以使用以下属性将这些网格线编号分配到第6个框中： grid-column-start grid-column-end grid-row-start grid-row-end 前两个属性对应于垂直网格线，也就是列网格线的开始和结束。 最后两个属性是指水平网格线，也就是行网格线的开始和结束。 让我们分配正确的网格线编号来移动第 6 个框。 1234567.box:nth-child(6) &#123; grid-row-start: 1; grid-row-end: 2; grid-column-start: 2; grid-column-end: 3; &#125; 还有两个简写属性用于将行和列的开始网格线和结束网格线设置在一起。 12345.box:nth-child(6) &#123; grid-row: 1 / 2; grid-column: 2 / 3; &#125; 此外，还有一个grid-area属性是所有四个上述属性的简写属性。 它按以下顺序取值： grid-area: / / / ; 现在我们的例子可以写成这样: 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / 3; &#125; 如果我们想要第6个框跨越两个框的区域呢？ 这很容易通过将 column-end 值加 1 的办法来完成。 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / 4; &#125; 您也可以使用 span 关键字和占据的 轨道数量，来代替指定 grid-row-end 和 grid-column-end 的结束网格线编号。 在这种情况下，第6个框是跨越 2 列和 1 行。 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / span 2; &#125; 网格区域命名grid-area 属性也可以用来命名网格的某一个部分，然后我们可以用 grid-template-areas 属性来定位。让我们创建一个简单的 bread-and-butter 布局，顶部有一个 top, nav，中间有 main 和 aside，下面是 footer。这是所需的HTML： 1234567&lt;div class=\"container\"&gt; &lt;header&gt;&lt;/header&gt; &lt;nav&gt;&lt;/nav&gt; &lt;main&gt;&lt;/main&gt; &lt;aside&gt;&lt;/aside&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/div&gt; 我们需要使用 grid-area 属性来命名每个区域： 1234567891011121314151617181920212223242526272829header &#123; grid-area: header; background-color: #9b59b6; &#125; nav &#123; grid-area: nav; background-color: #3498db; &#125; main &#123; grid-area: main; background-color: #2ecc71; &#125; aside &#123; grid-area: aside; background-color: #f1c40f; &#125; footer &#123; grid-area: footer; background-color: #1abc9c; &#125; 现在我们将使用 grid-template-areas 属性来指定每个网格区域所占据的行和列。 以下是我们如何做到的： 1234567891011.container &#123; display: grid; grid-template-rows: 1fr 5fr 1fr; grid-template-columns: 2fr 5fr 3fr; grid-template-areas: \"header header header\" \"nav main aside\" \"footer footer footer\"; grid-gap: .75em; &#125; 请注意，header 和 footer 单词重复三次。 这表明，header 和 footer 横跨 3 列的宽度。 你可以把它全部写在一行中，但是把每一行写在一个单独的行上很好，很干净。 你可以看到我在这里使用了一个新的属性 grid-gap。 它所做的只是在两个网格区域之间添加一个间距。 你也可以使用 grid-row-gap 和 grid-column-gap 来为行和列指定不同的间距值。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/"},{"name":"网格布局","slug":"技术/前端基础知识/网格布局","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/网格布局/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.kaige1220.top/tags/CSS/"},{"name":"网格布局","slug":"网格布局","permalink":"https://www.kaige1220.top/tags/网格布局/"}]},{"title":"CSS 网格布局知识1","slug":"前端基础知识整理3","date":"2018-06-23T09:31:50.016Z","updated":"2018-06-11T12:33:13.612Z","comments":true,"path":"2018/06/23/前端基础知识整理3/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/前端基础知识整理3/","excerpt":"2.1 网格布局知识 CSS Grid(网格) 布局使我们能够比以往任何时候都可以更灵活构建和控制自定义网格。 Grid(网格) 布局使我们能够将网页分成具有简单属性的行和列。它还能使我们在不改变任何HTML的情况下，使用 CSS 来定位和调整网格内的每个元素。它允许 HTML 纯粹作为内容的容器。HTML 结构不再受限于样式表现，比如不要为了实现某种布局而多次嵌套，现在这些都可以让 CSS 来完成。 浏览器兼容性 对于大多数布局，我们会使用下面的query特性来让老的浏览器对他们理解的特性也能工作： 12345@supports (display: grid) &#123; .grid &#123; display: grid; &#125;&#125; 不支持浏览器@supports或网格的浏览器将不会生效。","text":"2.1 网格布局知识 CSS Grid(网格) 布局使我们能够比以往任何时候都可以更灵活构建和控制自定义网格。 Grid(网格) 布局使我们能够将网页分成具有简单属性的行和列。它还能使我们在不改变任何HTML的情况下，使用 CSS 来定位和调整网格内的每个元素。它允许 HTML 纯粹作为内容的容器。HTML 结构不再受限于样式表现，比如不要为了实现某种布局而多次嵌套，现在这些都可以让 CSS 来完成。 浏览器兼容性 对于大多数布局，我们会使用下面的query特性来让老的浏览器对他们理解的特性也能工作： 12345@supports (display: grid) &#123; .grid &#123; display: grid; &#125;&#125; 不支持浏览器@supports或网格的浏览器将不会生效。 创建带有间距（gutter）的两列（column）网格 [使用grid-template-columns 和 grid-gap创建带间距的两列布局] 为了创建上述网格布局，我们需要使用grid-template-columns和grid-gap。grid-template-columns表示网格中的列是如何布局的，它的值是一连串以空格分割的的值，这些值标识每列的大小，值的个数表示列的数目。 例如，四列250px宽度的网格布局可以这样表示： 1grid-template-columns: 250px 250px 250px 250px; 也可以使用repeat关键字表示：1grid-template-columns: repeat(4, 250px); 定义间距grid-gap定义了网格布局的间距大小，接收一个或两个值，如果定义两个值则表示列（column）和行（row）的间距大小。 在两列布局示例中，我们可以如下使用： 12345.grid &#123; display: grid; grid-template-columns: 50vw 50vw; grid-gap: 1rem;&#125; 不幸的是，这个间距将会占用容器元素的整体宽度，计算出来就是100vw + 1rem，最终这个布局会导致出现水平滚动条。 为了解决这个空间溢出问题，我们需要些不同的方法来处理，需要用分数单位或者说是FR。 分数单位标识占用可用空间的份额，如果900px是可用空间，其中的一个元素占有1份，另外的元素占有2份——那么第一个元素的宽度会是900px的1/3，另外的元素是900px的2/3。修改后用分数代替view-port单位的新代码如下： 12345.grid &#123; display: grid; grid-template-columns: 1fr 1fr; grid-gap: 1rem;&#125; 内容对齐为了对齐示例中的内容，我们在子元素上使用grid布局，并加上对齐属性来定位他们到指定轨道(track)，轨道就是一个网格的列或行的某个位置的常见的名称。网格跟Flex布局一样，有一系列对齐的属性——共有四种值——start, center, end, 和stretch，分别对应其子元素所在的轨道。stretch跟其他不太一样，它会将元素从所在轨道的头拉伸到尾。 [align-items 和 justify-content] 例子中我们要将内容水平和垂直居中，可以通过在容器上设置下面这些属性：12345.center-content &#123; display: grid; align-items: center; justify-content: center;&#125; 通过CSS网格实现内边距（Negative Space）网格布局允许你通过grid-column-start属性指定列开始的位置，所以就有了可以在网格内创建内边距的可能性。[使用grid-template-columns和grid-column-start创建内边距] 在上面的内边距示例中，html结构中用一个div包裹另外一个div：123&lt;div class=\"grid\"&gt; &lt;div class=\"child\"&gt;&lt;!-- 内容 --&gt;&lt;/div&gt;&lt;/div 网格像这样设置： 123.child &#123; grid-column-start: 2;&#125; 创建行如果我们想分割布局为四份，我们目前所了解的关于列的布局方式对行同样有效： 12345.grid &#123; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 250px 250px;&#125; 理想情况下这个示例是没问题的。因为此时每个网格项的内容足够少而不会撑开每行。但随着内容的变化，一切都不一样了。当示例中的内容超出指定行的大小后，看下会发生什么： [内容超出声明的行高] 我们创建了250px高的两行，如果内容超过每行的高度，将会打破布局并和后面的行的内容重叠。并不是一个我们想要的结果。 灵活的设置最小值我们在该场景下需要的是设置最小尺寸的能力，但又要允许尺寸可以根据内容弹性变化。这里我们通过上面旧浏览器示例中的minmax关键字实现。 123.grid &#123; grid-template-rows: minmax(250px, auto) minmax(250px, auto);&#125; 现在我们已经了解了创建带有内容的行的基础方法，我们开始来创建水平和垂直交错的更复杂网格布局。 [使用grid-column-start和span关键字创建复杂网格布局Unsplash] 123.span-column-3 &#123; grid-column-start: span 3;&#125; 不需要媒体查询（media queries）的弹性网格虽然上面说到的例子能在可用空间内适应变化，但是没有一个是专门为空间变化设计的。网格有两个非常有用的特性来适应可用空间的变化。这两个属性叫‘auto-fit’和‘auto-fill’，像下面这样结合repeat function和minmax function使用： 1grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); auto-fill的表现跟auto-fit类似，但是任何的空白空间都会自动收缩，同时这一行的元素也会被拉升——类似flexbox的效果，列会随着可用空间变小发生折叠。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/"},{"name":"网格布局","slug":"技术/前端基础知识/网格布局","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/网格布局/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.kaige1220.top/tags/CSS/"},{"name":"网格布局","slug":"网格布局","permalink":"https://www.kaige1220.top/tags/网格布局/"}]},{"title":"CSS 基础知识整理","slug":"前端基础知识整理2","date":"2018-06-23T09:31:49.997Z","updated":"2018-06-11T08:17:38.481Z","comments":true,"path":"2018/06/23/前端基础知识整理2/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/前端基础知识整理2/","excerpt":"1、CSS基础知识亲自做的思维导图：方便学习查看","text":"1、CSS基础知识亲自做的思维导图：方便学习查看 2、CSS 布局知识亲自做的思维导图：方便学习查看","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.kaige1220.top/tags/CSS/"}]},{"title":"HTML 基础知识整理","slug":"前端基础知识整理1","date":"2018-06-23T09:31:49.978Z","updated":"2018-06-11T06:43:26.675Z","comments":true,"path":"2018/06/23/前端基础知识整理1/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/前端基础知识整理1/","excerpt":"把很久之前学习的基础知识整理一遍：1、HTML基础元素亲自做的思维导图：方便学习查看","text":"把很久之前学习的基础知识整理一遍：1、HTML基础元素亲自做的思维导图：方便学习查看 1.2 HTML表单元素亲自做的思维导图：方便学习查看 2、DOM文档对象模型 根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 亲自做的思维导图：方便学习查看 上面两个图标明了其属性，下面看看具体的方法： 1、创建 HTML 内容1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=\"p1\"&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById(\"p1\").innerHTML=\"New text!\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、改变 HTML 样式1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=\"p2\"&gt;Hello world!&lt;/p&gt;&lt;script&gt;document.getElementById(\"p2\").style.color=\"blue\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、创建新的 HTML 元素 将新元素作为父元素的最后一个子元素进行添加。 12345678910111213&lt;&lt;div id=\"d1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var element=document.getElementById(\"d1\");element.appendChild(para);&lt;/script&gt; 插在前面1234567891011121314&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var element=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");element.insertBefore(para,child);&lt;/script&gt; 4、删除已有的 HTML 元素 如需删除 HTML 元素，您必须清楚该元素的父元素： 12345678910&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var parent=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");parent.removeChild(child);&lt;/script&gt;&lt;/html&gt; 6、替换 HTML 元素 如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法： 1234567891011121314&lt;&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var parent=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");parent.replaceChild(para,child);&lt;/script&gt; 7、使用事件：123456789101112131415&lt;html&gt;&lt;body&gt;&lt;script&gt;function ChangeBackground()&#123;document.body.style.backgroundColor=\"lavender\";&#125;&lt;/script&gt;&lt;input type=\"button\" onclick=\"ChangeBackground()\"value=\"Change background color\" /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/"}],"tags":[{"name":"Html","slug":"Html","permalink":"https://www.kaige1220.top/tags/Html/"}]},{"title":"JS函数","slug":"函数","date":"2018-06-23T09:31:49.964Z","updated":"2018-06-14T14:19:35.053Z","comments":true,"path":"2018/06/23/函数/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/函数/","excerpt":"一、小心你的return语句我们JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑： 1234function foo() &#123; return &#123; name: 'foo' &#125;;&#125;foo(); // &#123; name: 'foo' &#125;","text":"一、小心你的return语句我们JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑： 1234function foo() &#123; return &#123; name: 'foo' &#125;;&#125;foo(); // &#123; name: 'foo' &#125; 如果把return语句拆成两行： 123456function foo() &#123; return &#123; name: 'foo' &#125;;&#125;foo(); // undefined 要小心了，由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了： 1234function foo() &#123; return; // 自动添加了分号，相当于return undefined; &#123; name: 'foo' &#125;; // 这行语句已经没法执行到了&#125; 所以正确的多行写法是：12345function foo() &#123; return &#123; // 这里不会自动加分号，因为&#123;表示语句尚未结束 name: 'foo' &#125;;&#125; 二、变量和作用域：在JavaScript中，用var申明的变量实际上是有作用域的。 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量： 123456'use strict';function foo() &#123; var x = 1; x = x + 1;&#125; x = x + 2; // ReferenceError! 无法在函数体外引用变量x 如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：123456'use strict';function foo() &#123; var x = 1; x = x + 1;&#125; 1234function bar() &#123; var x = 'A'; x = x + 'B';&#125; 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：123456789'use strict';function foo() &#123; var x = 1; function bar() &#123; var y = x + 1; // bar可以访问foo的变量x! &#125; var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!&#125; JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：123456789'use strict';function foo() &#123; var x = 'Hello, ' + y; console.log(x); var y = 'Bob';&#125;foo(); 虽然是strict模式，但语句var x = ‘Hello, ‘ + y;并不报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 对于上述foo()函数，JavaScript引擎看到的代码相当于：123456function foo() &#123; var y; // 提升变量y的申明，此时y为undefined var x = 'Hello, ' + y; console.log(x); y = 'Bob';&#125; 由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：12345678910function foo() &#123; var x = 1, // x初始化为1 y = x + 1, // y初始化为2 z, i; // z和i为undefined // 其他语句: for (i=0; i&lt;100; i++) &#123; ... &#125;&#125; 三、名字空间 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如： 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。 许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。 四、局部作用域由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的： 12345678'use strict';function foo() &#123; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125; 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量： 12345678910'use strict';function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; // SyntaxError: i += 1;&#125; 五、常量由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”： var PI = 3.14;ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域： 12345'use strict';const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 六、解构赋值从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。 什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量：1234var array = ['hello', 'JavaScript', 'ES6'];var x = array[0];var y = array[1];var z = array[2]; 现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值： 1234'use strict';// 如果浏览器支持解构赋值就不会报错:var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的：12345678910111213141516171819var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: &#123; city: 'Beijing', street: 'No.1 Road', zipcode: '100001' &#125;&#125;;var &#123;name, address: &#123;city, zip&#125;&#125; = person;name; // '小明'city; // 'Beijing'zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：1234567891011121314var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'&#125;;// 把passport属性赋值给变量id:let &#123;name, passport:id&#125; = person;name; // '小明'id; // 'G-12345678'// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题：123456789101112131415161718192021var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678'&#125;;// 如果person对象没有single属性，默认赋值为true:var &#123;name, single=true&#125; = person;name; // '小明'single; // true``````javascript有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：// 声明变量:var x, y;// 解构赋值:&#123;x, y&#125; = &#123; name: '小明', x: 100, y: 200&#125;;// 语法错误: Uncaught SyntaxError: Unexpected token = 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：1(&#123;x, y&#125; = &#123; name: '小明', x: 100, y: 200&#125;); 使用场景解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量： 12var x=1, y=2;[x, y] = [y, x] 快速获取当前页面的域名和路径： 1var &#123;hostname:domain, pathname:path&#125; = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象： 1234function buildDate(&#123;year, month, day, hour=0, minute=0, second=0&#125;) &#123; return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);&#125; 它的方便之处在于传入的对象只需要year、month和day这三个属性： 123456buildDate(&#123; year: 2017, month: 1, day: 1 &#125;);// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)也可以传入hour、minute和second属性：buildDate(&#123; year: 2017, month: 1, day: 1, hour: 20, minute: 15 &#125;);// Sun Jan 01 2017 20:15:00 GMT+0800 (CST) &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"函数","slug":"技术/函数","permalink":"https://www.kaige1220.top/categories/技术/函数/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.kaige1220.top/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"https://www.kaige1220.top/tags/函数/"}]},{"title":"JS原型继承","slug":"关于JS继承","date":"2018-06-23T09:31:49.935Z","updated":"2018-06-22T09:39:26.995Z","comments":true,"path":"2018/06/23/关于JS继承/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/关于JS继承/","excerpt":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。 由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。","text":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。 由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。 首先看一个构造函数： 1234567function Student(props) &#123; this.name = props.name || 'Unnamed';&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125; 构造Student函数， 然后给他一个hello方法 其原型链 我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：12345function PrimaryStudent(props) &#123; // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1;&#125; 但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是： new PrimaryStudent() —-&gt; PrimaryStudent.prototype —-&gt; Object.prototype —-&gt; null 必须想办法把原型链修改为： new PrimaryStudent() —-&gt; PrimaryStudent.prototype —-&gt; Student.prototype —-&gt; Object.prototype —-&gt; null 这样，原型链对了，继承关系就对了。新的基于PrimaryStudent创建的对象不但能调用PrimaryStudent.prototype定义的方法，也可以调用Student.prototype定义的方法。 如果你想用最简单粗暴的方法这么干： PrimaryStudent.prototype = Student.prototype; 是不行的！如果这样的话，PrimaryStudent和Student共享一个原型对象，那还要定义PrimaryStudent干啥？ 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： 123456789101112131415161718192021222324252627282930313233343536373839// PrimaryStudent构造函数:function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 空函数F:function F() &#123;&#125;// 把F的原型指向Student.prototype:F.prototype = Student.prototype;// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:PrimaryStudent.prototype = new F();// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:PrimaryStudent.prototype.constructor = PrimaryStudent;// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;;// 创建xiaoming:var xiaoming = new PrimaryStudent(&#123; name: '小明', grade: 2&#125;);xiaoming.name; // '小明'xiaoming.grade; // 2// 验证原型:xiaoming.__proto__ === PrimaryStudent.prototype; // truexiaoming.__proto__.__proto__ === Student.prototype; // true// 验证继承关系:xiaoming instanceof PrimaryStudent; // truexiaoming instanceof Student; // true 注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。 如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码： 1234567function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125; 这个inherits()函数可以复用： 123456789101112131415161718192021function Student(props) &#123; this.name = props.name || 'Unnamed';&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125;function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 实现原型继承链:inherits(PrimaryStudent, Student);// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;; JavaScript的原型继承实现方式就是： 定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this； 借助中间函数F实现原型链继承，最好通过封装的inherits函数完成； 继续在新的构造函数的原型上定义新方法。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JS原型继承","slug":"技术/JS原型继承","permalink":"https://www.kaige1220.top/categories/技术/JS原型继承/"}],"tags":[{"name":"JS原型继承","slug":"JS原型继承","permalink":"https://www.kaige1220.top/tags/JS原型继承/"}]},{"title":"HTML 中的data_","slug":"关于data_","date":"2018-06-23T09:31:49.919Z","updated":"2018-06-14T14:16:39.043Z","comments":true,"path":"2018/06/23/关于data_/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/关于data_/","excerpt":"‘data-‘属性的作用是什么?下面我们通过一个例子来看看 我们写一个html页面，自定义一个data-chb=”header”的属性，希望具备这个属性的div区域背景颜色为黑色，文字为白色，居中显示；不具备data-chb自定义属性的div按照默认方式显示，html代码如下： 123456789&lt;body&gt; &lt;div data-chb=\"header\"&gt; &lt;h1&gt;我是使用了data-chb自定义属性的div&lt;/h1&gt; &lt;/div&gt; &lt;br/&gt; &lt;div&gt; 我没有使用data-chb自定义属性，该怎么展现就怎么展现； &lt;/div&gt; &lt;/body&gt;","text":"‘data-‘属性的作用是什么?下面我们通过一个例子来看看 我们写一个html页面，自定义一个data-chb=”header”的属性，希望具备这个属性的div区域背景颜色为黑色，文字为白色，居中显示；不具备data-chb自定义属性的div按照默认方式显示，html代码如下： 123456789&lt;body&gt; &lt;div data-chb=\"header\"&gt; &lt;h1&gt;我是使用了data-chb自定义属性的div&lt;/h1&gt; &lt;/div&gt; &lt;br/&gt; &lt;div&gt; 我没有使用data-chb自定义属性，该怎么展现就怎么展现； &lt;/div&gt; &lt;/body&gt; 要想实现”背景颜色为黑色，文字为白色，居中显示”的显示效果，我们定义如下的css： 12345678&lt;style&gt; .ui_header &#123; background-color: black; text-align: center; color:white; border:1px solid #000; &#125; &lt;/style&gt; 然后我们通过如下js方法实现在页面加载时，动态添加css定义，改变具备data-chb属性的div的显示样式： 123456789101112131415161718192021&lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var elems = document.getElementsByTagName(\"div\"); if(elems!=null&amp;&amp;elems.length&gt;0)&#123; var length = elems.length; //遍历所有DIV控件 for(var i=0;i&lt;length;i++)&#123; var elem = elems[i]; //获取该控件的自定义属性 var customAttr = elem.dataset.chb; //也可以通过如下方式获得自定义属性 //var customAttr = elem.dataset[\"chb\"]; //如果是我们预先定义好的header值，表示需要处理 if(customAttr==\"header\")&#123; //添加样式 elem.setAttribute(\"class\",\"ui_header\"); &#125; &#125; &#125; &#125; &lt;/script&gt; 这样我们就能动态的改变需要控制的div了。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"html","slug":"技术/html","permalink":"https://www.kaige1220.top/categories/技术/html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"https://www.kaige1220.top/tags/Html/"},{"name":"data_","slug":"data","permalink":"https://www.kaige1220.top/tags/data/"}]},{"title":"前端问题集合及思考","slug":"一些问题集合及理解","date":"2018-06-23T09:31:49.909Z","updated":"2018-06-15T07:36:52.517Z","comments":true,"path":"2018/06/23/一些问题集合及理解/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/一些问题集合及理解/","excerpt":"1、前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标","text":"1、前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 2、的title和alt有什么区别 title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。alt是的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 3、HTML全局属性(global attribute)有哪些 accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素 class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素 contenteditable: 指定元素内容是否可编辑 contextmenu: 自定义鼠标右键弹出菜单内容 data-*: 为元素增加自定义属性 dir: 设置元素文本方向 draggable: 设置元素是否可拖拽 dropzone: 设置元素拖放类型： copy, move, link hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果 id: 元素id，文档内唯一 lang: 元素内容的的语言 spellcheck: 是否启动拼写和语法检查 style: 行内css样式 tabindex: 设置元素可以获得焦点，通过tab可以导航 title: 元素相关的建议信息 translate: 元素和子孙节点内容是否需要本地化 4、HTTP method 一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可 GET是最常用的方法，通常用于请求服务器发送某个资源。 HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分 PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它 POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将- 其发送到要去的地方。 TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。 OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。 DELETE请求服务器删除请求URL指定的资源 5、如何进行网站性能优化 1、content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下- 载和DNS查询 避免重定向：多余的中间访问 使Ajax可缓存 非必须组件延迟加载 未来所需组件预加载 减少DOM元素数量 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 减少iframe数量 不要404 2、Server方面 使用CDN 添加Expires或者Cache-Control响应头 对组件使用Gzip压缩 配置ETag Flush Buffer Early Ajax使用GET进行请求 避免空src的img标签 3、Cookie方面 减小cookie大小 引入资源的域名不要包含cookie 4、css方面 将样式表放到页面顶部 不使用CSS表达式 使用不使用@import 不使用IE的Filter 5 Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 合理设计事件监听器 6 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 保证favicon.ico小并且可缓存 7 HTTP状态码及其含义 1XX：信息状态码 2XX：成功状态码 3XX：重定向 4XX：客户端错误 5XX: 服务器错误 7、CSS选择器有哪些 *通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+ #X id选择器：选择id值为X的元素，兼容性：IE6+ .X 类选择器： 选择class包含X的元素，兼容性：IE6+ X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+ X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+ :link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+ X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+ X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+ X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+ [attr]：选择所有设置了attr属性的元素，兼容性IE7+ [attr=value]：选择属性值刚好为value的元素 [attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素 [attr|=value]：选择属性值刚好为value或者value-开头的元素 [attr^=value]：选择属性值以value开头的元素 [attr$=value]：选择属性值以value结尾的元素 [attr=value]*：选择属性值中包含value的元素 [:checked]：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+ X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，- ::after为IE9+ :hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+ :not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+ ::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+ ::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+ :nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n &gt;= 0， 兼容性IE9+ :nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素 其中n &gt;= 0，兼容性IE9+ X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+ X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+ X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+ X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+ X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+ X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+ X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素 是此此类型元素的第一个兄弟。选中它。兼容性IE9+ 8、css hack原理及常用hack 原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。常见的hack有1）属性hack。2）选择器hack。3）IE条件注释 9、link与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC link可以通过rel=”alternate stylesheet”指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import 10、PNG,GIF,JPG的区别及如何选 GIF: 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG： 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG： 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 11、容器包含若干浮动元素时如何清理(包含)浮动 容器元素闭合标签前添加额外元素并设置clear: both 父元素触发块级格式化上下文(见块级可视化上下文部分) 设置容器元素伪元素进行清理推荐的清理浮动方法示例： 1234567891011121314151617181920212223242526/*** 在标准浏览器下使用* 1 content内容为空格用于修复opera下文档中出现* contenteditable属性时在清理浮动元素上下的空白* 2 使用display使用table而不是block：可以防止容器和* 子元素top-margin折叠,这样能使清理效果与BFC，IE6/7* zoom: 1;一致**/.clearfix:before,.clearfix:after &#123; content: \" \"; /* 1 */ display: table; /* 2 */&#125;.clearfix:after &#123; clear: both;&#125;/*** IE 6/7下使用* 通过触发hasLayout实现包含浮动**/.clearfix &#123; *zoom: 1;&#125; 12、外边距折叠(collapsing margins) 毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下： 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 元素自身的margin-bottom和margin-top相邻时也会折叠 13、如何水平居中一个元素 如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现 如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。3）IE6下需在父元素上设置text-align: center;,再给子元素恢复需要的值 12345678910111213141516171819&lt;body&gt; &lt;div class=\"content\"&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; text-align: center; /* 3 */ &#125; .content &#123; width: 500px; /* 1 */ text-align: left; /* 3 */ margin: 0 auto; /* 2 */ background: purple; &#125;&lt;/style&gt; 如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=\"content\"&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; &#125; .content &#123; width: 500px; /* 1 */ float: left; position: relative; /* 2 */ left: 50%; /* 3 */ margin-left: -250px; /* 4 */ background-color: purple; &#125;&lt;/style&gt; 如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=\"content\"&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; position: relative; &#125; .content &#123; width: 800px; position: absolute; left: 50%; margin-left: -400px; background-color: purple; &#125;&lt;/style&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"前端问题集合及思考","slug":"技术/前端问题集合及思考","permalink":"https://www.kaige1220.top/categories/技术/前端问题集合及思考/"}],"tags":[{"name":"问题集合","slug":"问题集合","permalink":"https://www.kaige1220.top/tags/问题集合/"}]},{"title":"webpack使用技术详情","slug":"webpack系列文章7","date":"2018-06-23T09:31:49.891Z","updated":"2018-06-10T12:13:50.341Z","comments":true,"path":"2018/06/23/webpack系列文章7/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/webpack系列文章7/","excerpt":"本文主要步骤：1、创建文件 mkdir mywebpack2、npm init -y // 用来创建webpack的配置文件3、安装webpack npm install webpack –save-dev4、安装组件 npm install html-webpack-plugin –save-dev //具体的index等文件自己创建就好了5、webpack.config.js 的使用 //这个之前基础都学习过了","text":"本文主要步骤：1、创建文件 mkdir mywebpack2、npm init -y // 用来创建webpack的配置文件3、安装webpack npm install webpack –save-dev4、安装组件 npm install html-webpack-plugin –save-dev //具体的index等文件自己创建就好了5、webpack.config.js 的使用 //这个之前基础都学习过了 5、处理js文件需要用的依赖包： 12npm install --save-dev babel-loader babel-core npm install --save-dev babel-preset-env //转义ES6 为防止浏览器不支持 Promise/Object.assign/Array.from等还有性能问题,我们引入两个包: babel-polyfill babel-plugin-transform-runtime 1npm install --save-dev babel-polyfill babel-plugin-transform-runtime 引入生产版本依赖 npm install –save babel-runtime 通过 .babelrc 添加配置: 12345678&#123; \"presets\": [ \"env\" ], \"plugins\": [ \"transform-runtime\" ]&#125; 将 babel-polyfill 加到你的 entry 数组中使用，配置js文件要经过babel转义： 12345678910111213141516171819202122232425const path = require('path');module.exports = &#123; //entry为入口,webpack从这里开始编译 entry: [ \"babel-polyfill\", path.join(__dirname, './src/index.js') ], //output为输出 path代表路径 filename代表文件名称 output: &#123; path: path.join(__dirname, './bundle'), filename: 'bundle.js' &#125;, //module是配置所有模块要经过什么处理 //test:处理什么类型的文件,use:用什么,include:处理这里的,exclude:不处理这里的 module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], include: path.join(__dirname , 'src'), exclude: /node_modules/ &#125; ] &#125;,&#125;; 6、打包： 直接执行命令webpack7、看看日志说明：8、使用快捷方式进行编译： 可以在项目package.json里面来配置 ： 123456789101112131415161718192021&#123; \"name\": \"05-01\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" \"build\":\"webpack\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"babel-preset-es2015\": \"^6.14.0\", \"babel-preset-react\": \"^6.11.1\", \"babelify\": \"^7.3.0\", \"react\": \"^15.3.2\", \"react-dom\": \"^15.3.2\", \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.1\" &#125;&#125; 下面你可以使用命令： 1npm run build 9、怎样自动加载： 首先安装webpack-dev-server 执行命令：1npm install webpack-dev-serve --save-dev 下面就可以执行如下命令了1webpack-dev-server --contentbase -src --inline 注意： 这里版本很重要，要匹配。 如果安装其他版本，可以在名称后面加@跟上版本号就可以了。 10、配置端口号 webpakc.config.js 里面配置 12345 devServer: &#123; contentBase: path.join(__dirname, \"dist\"), compress: true, port: 9000&#125; 接下来以管理员身份执行命令 1npm run start 11、配置ESLint 实现代码规范化自动化测试 安装： npm install eslint --save-dev 配置： package.json 里面的配置： { \"name\": \"05-01\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" \"build\":\"webpack\" \"lintjs\":\"eslint app/ webpack.*.js --cache\" //这是我们需要配置的 }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"babel-preset-es2015\": \"^6.14.0\", \"babel-preset-react\": \"^6.11.1\", \"babelify\": \"^7.3.0\", \"react\": \"^15.3.2\", \"react-dom\": \"^15.3.2\", \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.1\" } } eslintrc.js 里面的配置： 具体的规则可以去官网查看。 执行如下命令即可： npm run lintjs 如果有错误：会相应的提示。 怎样修复呢：执行命令： npm run lintjs -- --fix 如何自动测试 在webpack 中集成： 首先进行安装： npm install eslint-loader –save-dev 然后在webpack.config.js 里面进行配置： 具体配置可以查看官方文档。 12、webpack中加载CSS的相关配置 需要安装两个插件： npm insatall css-loader style-loader --save-dev webpack.config.js进行配置： const ExtractTextPlugin = require('extract-text-webpack-plugin'); ... module: { rules: [ ... { test: /\\.less$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: ['css-loader', 'style-loader','postcss-loader', 'less-loader'] //进行配置 }) } ] }, plugins: [ ... new ExtractTextPlugin({ filename: 'index.css' }), ], 13、webpack中加载图片 在 webpack 里，负责图片翻译的是 file-loader： npm install file-loader --save-dev 在webpack.config.js里面进行配置： }, { test: /\\.(png|jpg|gif)$/, use: [ { loader: 'file-loader', options: {} } ] } ] 至于我们怎样在js文件里配置： 我们需要一张图片，我从 unsplash 找来了一张玫瑰，放到 src/img/rose.jpg 位置。 我们在 src/index.js 中 import 它： import ReactDOM from 'react-dom' import Rose from './img/rose.jpg' class App extends React.Component { render () { return ( &lt;div&gt;&lt;img src={Rose} alt='玫瑰' /&gt;&lt;/div&gt; ) } } ReactDOM.render(&lt;App /&gt;, document.body) 14、打包： 在完成项目开发后，我们需要输出文件给生产环境部署，只要执行： npx webpack --mode production 14、部署： 部署时，拷贝 dist 目录即可。 15、清理 dist 随着某些文件的增删，我们的 dist 目录下会产生一些不再使用的文件，我们不想这些文件也部署到生产环境上占用空间，所以 webpack 在打包前最好能删除 dist 目录。 我们来试试 clean-webpack-plugin。 首先是安装： npm i -D clean-webpack-plugin 然后在 webpack.config.js 中调用： const path = require('path') const CleanWebpackPlugin = require('clean-webpack-plugin') module.exports = { mode: 'development', devServer: { contentBase: path.resolve(__dirname, 'dist') }, plugins: [ new CleanWebpackPlugin(['dist']) //需要实例化 ], module: { 再执行 npx webpack –mode production，webpack 确实会在打包前清空 dist 目录，但我们的 index.html 也一起被清空了。 下面我们使用 html-webpack-plugin 来自动生成 index.html： 首先是安装： npm i --save-dev html-webpack-plugin 调整 webpack.config.js： const CleanWebpackPlugin = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', devServer: { contentBase: path.resolve(__dirname, 'dist') }, plugins: [ new CleanWebpackPlugin(['dist']) new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin() ], 再运行 npx webpack –mode production，dist 下已经自动生成 index.html，再 title 却是 Webpack App，我们需要再调整一下 webpack.config.js： plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin() new HtmlWebpackPlugin({ title: 'webpack 教程' }) ], 至此，我们大致的教程算是完结了，但是这样比较麻烦，如果开发一个特定类型的项目，我们可以采用脚手架的方式直接生成： 比较有名的有： create-react-app react 官方出品的一套，只适用开发 react.js 项目； neutrino.js 这是 Mozilla 出品的一套解决方案，Web、React、Node.js 等方案均有；","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"https://www.kaige1220.top/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.kaige1220.top/tags/webpack/"}]},{"title":"webpack基础知识学习-配置","slug":"webpack系列文章6","date":"2018-06-23T09:31:49.883Z","updated":"2018-06-10T05:36:38.888Z","comments":true,"path":"2018/06/23/webpack系列文章6/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/webpack系列文章6/","excerpt":"12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ &#125;,","text":"12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ &#125;, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157 module: &#123; // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: &#123; test, include, exclude &#125;, // issuer 条件（导入源） enforce: \"pre\", enforce: \"post\", // 标识应用这些规则，即使规则覆盖（高级选项） loader: \"babel-loader\", // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: &#123; presets: [\"es2015\"] &#125;, // loader 的可选项 &#125;, &#123; test: /\\.html$/, test: \"\\.html$\" use: [ // 应用多个 loader 和选项 \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // 只使用这些嵌套规则之一 &#123; rules: [ /* rules */ ] &#125;, // 使用所有这些嵌套规则（合并可用条件） &#123; resource: &#123; and: [ /* 条件 */ ] &#125; &#125;, // 仅当所有条件都匹配时才匹配 &#123; resource: &#123; or: [ /* 条件 */ ] &#125; &#125;, &#123; resource: [ /* 条件 */ ] &#125;, // 任意条件匹配时匹配（默认为数组） &#123; resource: &#123; not: /* 条件 */ &#125; &#125; // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ &#125;, resolve: &#123; // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ \"node_modules\", path.resolve(__dirname, \"app\") ], // 用于查找模块的目录 extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 使用的扩展名 alias: &#123; // 模块别名列表 \"module\": \"new-module\", // 起别名：\"module\" -&gt; \"new-module\" 和 \"module/path/file\" -&gt; \"new-module/path/file\" \"only-module$\": \"new-module\", // 起别名 \"only-module\" -&gt; \"new-module\"，但不匹配 \"only-module/path/file\" -&gt; \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // 起别名 \"module\" -&gt; \"./app/third/module.js\" 和 \"module/file\" 会导致错误 // 模块别名相对于当前上下文导入 &#125;, /* 可供选择的别名语法（点击展示） */ /* 高级解析选项（点击展示） */ &#125;, performance: &#123; hints: \"warning\", // 枚举 maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // enum // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map' 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: \"web\", // 枚举 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: [\"react\", /^@angular\\//], // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: \"errors-only\", // 精确控制要显示的 bundle 信息 devServer: &#123; proxy: &#123; // proxy URLs to backend development server '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... &#125;, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"https://www.kaige1220.top/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.kaige1220.top/tags/webpack/"}]},{"title":"webpack基础知识学习-插件","slug":"webpack系列文章5","date":"2018-06-23T09:31:49.877Z","updated":"2018-06-10T05:32:59.393Z","comments":true,"path":"2018/06/23/webpack系列文章5/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/webpack系列文章5/","excerpt":"插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。","text":"插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。 用法由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。 根据你的 webpack 用法，这里有多种方式使用插件： 12345678910111213141516171819202122232425const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, use: 'babel-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"https://www.kaige1220.top/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.kaige1220.top/tags/webpack/"}]},{"title":"webpack基础知识学习-loader","slug":"webpack系列文章4","date":"2018-06-23T09:31:49.867Z","updated":"2018-06-10T05:26:58.187Z","comments":true,"path":"2018/06/23/webpack系列文章4/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/webpack系列文章4/","excerpt":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;;","text":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;; loader的使用方式 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 //不推荐就不作介绍了 CLI：在 shell 命令中指定它们。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"https://www.kaige1220.top/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.kaige1220.top/tags/webpack/"}]},{"title":"webpack基础知识学习-出口","slug":"webpack系列文章3","date":"2018-06-23T09:31:49.850Z","updated":"2018-06-10T05:17:33.215Z","comments":true,"path":"2018/06/23/webpack系列文章3/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/webpack系列文章3/","excerpt":"配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 单个出口用法在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config;","text":"配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 单个出口用法在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config; 多个出口如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 123456789101112&#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' &#125;&#125;// 写入到硬盘：./dist/app.js, ./dist/search.js","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"https://www.kaige1220.top/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.kaige1220.top/tags/webpack/"}]},{"title":"webpack基础知识学习-入口起点","slug":"webpack系列文章2","date":"2018-06-23T09:31:49.845Z","updated":"2018-06-10T05:08:39.152Z","comments":true,"path":"2018/06/23/webpack系列文章2/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/webpack系列文章2/","excerpt":"单个入口单个入口在上一章其实已经看到了，下面，我们主要学习下多个入口怎样创建。","text":"单个入口单个入口在上一章其实已经看到了，下面，我们主要学习下多个入口怎样创建。 多个入口1、分离 应用程序(app) 和 第三方库(vendor) 入口123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 从表面上看，这告诉我们 webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。 2、多页面应用程序1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; webpack 需要 3 个独立分离的依赖图（如上面的示例）。在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事： 使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"https://www.kaige1220.top/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.kaige1220.top/tags/webpack/"}]},{"title":"webpack基础知识学习","slug":"webpack系列文章1","date":"2018-06-23T09:31:49.836Z","updated":"2018-06-10T04:51:28.443Z","comments":true,"path":"2018/06/23/webpack系列文章1/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/webpack系列文章1/","excerpt":"简介webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 核心概念的理解1.入口(entry)2.输出(output)3.loader4.插件(plugins)","text":"简介webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 核心概念的理解1.入口(entry)2.输出(output)3.loader4.插件(plugins) 1、入口入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中.可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。接下来我们看一个 entry 配置的最简单例子： 123456789module.exports = &#123; context: path.join(dirname), devtool: debug ? “inline-sourcemap” : null, entry: “./src/js/index.js”, output: &#123; path: dirname, filename: “./src/bundle.js” &#125;,&#125;; 2、出口output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： 1234567891011121314 var debug = process.env.NODE_ENV !== “production”; var webpack = require(‘webpack’); var path = require(‘path’);module.exports = &#123; context: path.join(dirname), devtool: debug ? “inline-sourcemap” : null, entry: “./src/js/index.js”, output: &#123; path: dirname, filename: “./src/bundle.js” &#125;,&#125;; 3、loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在更高层面，在 webpack 的配置中 loader 有两个目标：1、test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。2、use 属性，表示进行转换时，应该使用哪个 loader。 123456789101112131415const path = require(‘path’);const config = &#123; output: &#123; filename: ‘my-first-webpack.bundle.js’ &#125;, module: &#123; rules: [ &#123; test: /.txt$/, use: ‘raw-loader’ &#125; // 也可以改成.js?$/ ] &#125;&#125;;module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。” 4、插件loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 1234567891011121314151617const HtmlWebpackPlugin = require(‘html-webpack-plugin’); // 通过 npm 安装const webpack = require(‘webpack’); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /.txt$/, use: ‘raw-loader’ &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: ‘./src/index.html’&#125;) ]&#125;;module.exports = config; 5、模式通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 123module.exports = &#123; mode: ‘production’&#125;; 以上是对webpack 作了一个简短的介绍，后面详细学习之！","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"https://www.kaige1220.top/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.kaige1220.top/tags/webpack/"}]},{"title":"Sass学习","slug":"Sass","date":"2018-06-23T09:31:49.803Z","updated":"2018-06-14T14:16:23.953Z","comments":true,"path":"2018/06/23/Sass/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/Sass/","excerpt":"一、安装由于Sass是基于ruby的，所以先安装ruby。 Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板：Start Command Prompt with Ruby 1、通过命令安装 Sass 1gem install sass 使用国内淘宝镜像gem。第一步：gem sources –remove https://rubygems.org/ 删除自带gem第二步：gem sources -a https://ruby.taobao.org/ 添加国内淘宝镜像gem第三步：gem sources 显示下载的gem信息 查看版本sass -v 更新：gem update sass 删除gem uninstall sass","text":"一、安装由于Sass是基于ruby的，所以先安装ruby。 Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板：Start Command Prompt with Ruby 1、通过命令安装 Sass 1gem install sass 使用国内淘宝镜像gem。第一步：gem sources –remove https://rubygems.org/ 删除自带gem第二步：gem sources -a https://ruby.taobao.org/ 添加国内淘宝镜像gem第三步：gem sources 显示下载的gem信息 查看版本sass -v 更新：gem update sass 删除gem uninstall sass 后缀sass 和scss 的区别： sass 不用{} 包裹， 而scss可以包裹。建议使用scss。 示例： 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 二、Sass编译 命令编译 GUI工具编译 自动化编译 1、命令编译单文件编译： sass &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css 多文件编译： sass sass/:css/ 上面的命令表示将项目中“sass”文件夹中所有“.scss”(“.sass”)文件编译成“.css”文件，并且将这些 CSS 文件都放在项目中“css”文件夹中。 2、GUI 界面工具编译就推荐Koala 其他就不介绍了。 3、自动化编译 Grunt Gulp 具体配置自行查看文档 三、常见错误： 最为常见的一个错误就是字符编译引起的。在Sass的编译的过程中，是不是支持“GBK”编码的。所以在创建 Sass 文件时，就需要将文件编码设置为“utf-8”。 另外一个错误就是路径中的中文字符引起的。建议在项目中文件命名或者文件目录命名不要使用中文字符。而至于人为失误造成的编译失败，在编译过程中都会有具体的说明，大家可以根据编译器提供的错误信息进行对应的修改。 四、不同样式风格的输出方法 嵌套输出方式 nested 展开输出方式 expanded 紧凑输出方式 compact 压缩输出方式 compressed 4.1嵌套输出方式 nested语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style nested”:sass –watch test.scss:test.css –style nested 编译出来的 CSS 样式风格：12345678910nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; 4.2 展开输出方式 expanded语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style expanded”: sass –watch test.scss:test.css –style expanded 这个输出的 CSS 样式风格和 nested 类似，只是大括号在另起一行，同样上面的代码，编译出来：12345678910111213nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 4.3 紧凑输出方式 compact语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style compact”: sass –watch test.scss:test.css –style compact 该方式适合那些喜欢单行 CSS 样式格式的朋友，编译后的代码如下： 123nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; 4.4 压缩输出方式 compressed在编译的时候带上参数“ –style compressed”: sass –watch test.scss:test.css –style compressed 压缩输出方式会去掉标准的 Sass 和 CSS 注释及空格。也就是压缩好的 CSS 代码样式风格：","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"Sass","slug":"技术/Sass","permalink":"https://www.kaige1220.top/categories/技术/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"https://www.kaige1220.top/tags/Sass/"}]},{"title":"Sass学习2","slug":"Sass.1","date":"2018-06-23T09:31:49.788Z","updated":"2018-06-13T07:07:34.096Z","comments":true,"path":"2018/06/23/Sass.1/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/Sass.1/","excerpt":"一、Sass的基本特性 上图非常清楚告诉了大家，Sass 的变量包括三个部分： 1.声明变量的符号“$”2.变量名称3.赋予变量的值","text":"一、Sass的基本特性 上图非常清楚告诉了大家，Sass 的变量包括三个部分： 1.声明变量的符号“$”2.变量名称3.赋予变量的值 1.1普通变量和默认变量：1、普通变量定义之后可以在全局范围内使用。 2、默认变量sass 的默认变量仅需要在值后面加上 !default 即可。 sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。12345$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight; &#125; 1.2变量的调用1.3 全局比那里和局部变量1234567891011121314//SCSS$color: orange !default;//定义全局变量(在选择器、函数、混合宏...的外面定义的变量为全局变量).block &#123; color: $color;//调用全局变量&#125;em &#123; $color: red;//定义局部变量 a &#123; color: $color;//调用局部变量 &#125;&#125;span &#123; color: $color;//调用全局变量&#125; 什么时候声明变量？ 我的建议，创建变量只适用于感觉确有必要的情况下。不要为了某些骇客行为而声明新变量，这丝毫没有作用。只有满足所有下述标准时方可创建新变量： 该值至少重复出现了两次； 该值至少可能会被更新一次； 该值所有的表现都与变量有关（非巧合）。基本上，没有理由声明一个永远不需要更新或者只在单一地方使用变量。 嵌套-选择器嵌套 Sass 中还提供了选择器嵌套功能，但这也并不意味着你在 Sass 中的嵌套是无节制的，因为你嵌套的层级越深，编译出来的 CSS 代码的选择器层级将越深，这往往是大家不愿意看到的一点。这个特性现在正被众多开发者滥用。 Sass 的嵌套分为三种： 选择器嵌套 属性嵌套 伪类嵌套 选择器嵌套假设我们有一段这样的结构：1234567&lt;header&gt;&lt;nav&gt; &lt;a href=“##”&gt;Home&lt;/a&gt; &lt;a href=“##”&gt;About&lt;/a&gt; &lt;a href=“##”&gt;Blog&lt;/a&gt;&lt;/nav&gt;&lt;header&gt; 想选中 header 中的 a 标签，在 Sass 中，就可以使用选择器的嵌套来实现：123456789nav &#123; a &#123; color: red; header &amp; &#123; color:green; &#125; &#125; &#125; 属性嵌套Sass 中还提供属性嵌套，CSS 有一些属性前缀相同，只是后缀不一样，比如：border-top/border-right，与这个类似的还有 margin、padding、font 等属性。假设你的样式中用到了： 1234.box &#123; border-top: 1px solid red; border-bottom: 1px solid green;&#125; 在 Sass 中我们可以这样写：123456.box &#123; border: &#123; top: 1px solid red; bottom: 1px solid green; &#125;&#125; 伪类嵌套1234567891011.clearfix&#123;&amp;:before,&amp;:after &#123; content:\"\"; display: table; &#125;&amp;:after &#123; clear:both; overflow: hidden; &#125;&#125; 避免选择器嵌套： 选择器嵌套最大的问题是将使最终的代码难以阅读。开发者需要花费巨大精力计算不同缩进级别下的选择器具体的表现效果。选择器越具体则声明语句越冗长，而且对最近选择器的引用(&amp;)也越频繁。在某些时候，出现混淆选择器路径和探索下一级选择器的错误率很高，这非常不值得。 混合宏-声明混合宏如果你的整个网站中有几处小样式类似，比如颜色，字体等，在 Sass 可以使用变量来统一处理，那么这种选择还是不错的。但当你的样式变得越来越复杂，需要重复使用大段的样式时，使用变量就无法达到我们目了。这个时候 Sass 中的混合宏就会变得非常有意义。 1、声明混合宏 不带参数混合宏： 在 Sass 中，使用“@mixin”来声明一个混合宏。如： 1234@mixin border-radius&#123; -webkit-border-radius: 5px; border-radius: 5px;&#125; 其中 @mixin 是用来声明混合宏的关键词，有点类似 CSS 中的 @media、@font-face 一样。border-radius 是混合宏的名称。大括号里面是复用的样式代码。 带参数混合宏： 除了声明一个不带参数的混合宏之外，还可以在定义混合宏时带有参数，如：1234@mixin border-radius($radius:5px)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 复杂的混合宏： 上面是一个简单的定义混合宏的方法，当然， Sass 中的混合宏还提供更为复杂的，你可以在大括号里面写上带有逻辑关系，帮助更好的做你想做的事情,如：12345678@mixin box-shadow($shadow...) &#123; @if length($shadow) &gt;= 1 &#123; @include prefixer(box-shadow, $shadow); &#125; @else&#123; $shadow:0 0 4px rgba(0,0,0,.3); @include prefixer(box-shadow, $shadow); &#125;&#125; 混合宏-调用混合宏在 Sass 中通过 @mixin 关键词声明了一个混合宏，那么在实际调用中，其匹配了一个关键词“@include”来调用声明好的混合宏。例如在你的样式中定义了一个圆角的混合宏“border-radius”: 1234@mixin border-radius&#123; -webkit-border-radius: 3px; border-radius: 3px;&#125; 在一个按钮中要调用定义好的混合宏“border-radius”，可以这样使用: 123button &#123; @include border-radius;&#125; 混合宏的参数–传一个不带值的参数1234@mixin border-radius($radius)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 在混合宏“border-radius”中定义了一个不带任何值的参数“$radius”。 在调用的时候可以给这个混合宏传一个参数值：123.box &#123; @include border-radius(3px);&#125; 混合宏的参数–传一个带值的参数Sass 混合宏除了能传一个参数之外，还可以传多个参数，如：123456789@mixin center($width,$height)&#123; width: $width; height: $height; position: absolute; top: 50%; left: 50%; margin-top: -($height) / 2; margin-left: -($width) / 2;&#125; 有一个特别的参数“…”。当混合宏传的参数过多之时，可以使用参数来替代，如： 12345678910@mixin box-shadow($shadows...)&#123; @if length($shadows) &gt;= 1 &#123; -webkit-box-shadow: $shadows; box-shadow: $shadows; &#125; @else &#123; $shadows: 0 0 2px rgba(#000,.25); -webkit-box-shadow: $shadow; box-shadow: $shadow; &#125;&#125; 继承在 Sass 中是通过关键词 “@extend”来继承已存在的类样式块，从而实现代码的继承。如下所示： 123456789101112131415161718//SCSS.btn &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff; @extend .btn;&#125;.btn-second &#123; background-color: orange; color: #fff; @extend .btn;&#125; 占位符 （重点）Sass 中的占位符 %placeholder 功能是一个很强大，很实用的一个功能，这也是我非常喜欢的功能。他可以取代以前 CSS 中的基类造成的代码冗余的情形。因为 %placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码。来看一个演示： 123456%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125; 这段代码没有被 @extend 调用，他并没有产生任何代码块，只是静静的躺在你的某个 SCSS 文件中。只有通过 @extend 调用才会产生代码： 1234567891011121314151617181920//SCSS%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125;.btn &#123; @extend %mt5; @extend %pt5;&#125;.block &#123; @extend %mt5; span &#123; @extend %pt5; &#125;&#125; 混合宏 VS 继承 VS 占位符a) Sass 中的混合宏使用 编译出来的 CSS 清晰告诉了大家，他不会自动合并相同的样式代码，如果在样式文件中调用同一个混合宏，会产生多个对应的样式代码，造成代码的冗余，这也是 CSSer 无法忍受的一件事情。不过他并不是一无事处，他可以传参数。 个人建议：如果你的代码块中涉及到变量，建议使用混合宏来创建相同的代码块。 b) Sass 中继承 总结：使用继承后，编译出来的 CSS 会将使用继承的代码块合并到一起，通过组合选择器的方式向大家展现，比如 .mt, .block, .block span, .header, .header span。这样编译出来的代码相对于混合宏来说要干净的多，也是 CSSer 期望看到。但是他不能传变量参数。 个人建议：如果你的代码块不需要专任何变量参数，而且有一个基类已在文件中存在，那么建议使用 Sass 的继承。 c) 占位符 总结：编译出来的 CSS 代码和使用继承基本上是相同，只是不会在代码中生成占位符 mt 的选择器。那么占位符和继承的主要区别的，“占位符是独立定义，不调用的时候是不会在 CSS 中产生任何代码；继承是首先有一个基类存在，不管调用与不调用，基类的样式都将会出现在编译出来的 CSS 代码中。” [Sass]插值#{}123456789$properties: (margin, padding);@mixin set-value($side, $value) &#123; @each $prop in $properties &#123; #&#123;$prop&#125;-#&#123;$side&#125;: $value; &#125;&#125;.login-box &#123; @include set-value(top, 14px);&#125; 它可以让变量和属性工作的很完美，上面的代码编译成 CSS： 12345.login-box &#123; margin-top: 14px; padding-top: 14px;&#125; Sass的基本特性-运算[Sass运算]加法加法运算是 Sass 中运算中的一种，在变量或属性中都可以做加法运算。如： 123.box &#123; width: 20px + 8in;&#125; 编译出来的 CSS:123.box &#123; width: 788px;&#125; 但对于携带不同类型的单位时，在 Sass 中计算会报错，如下例所示：123.box &#123; width: 20px + 1em;&#125; [Sass运算]减法Sass 的减法运算和加法运算类似，我们通过一个简单的示例来做阐述： 123456$full-width: 960px;$sidebar-width: 200px;.content &#123; width: $full-width - $sidebar-width;&#125; [Sass运算]乘法Sass 中的乘法运算和前面介绍的加法与减法运算还略有不同。虽然他也能够支持多种单位（比如 em ,px , %），但当一个单位同时声明两个值时会有问题。比如下面的示例： 123.box &#123; width:10px * 2px; &#125; 如果进行乘法运算时，两个值单位相同时，只需要为一个数值提供单位即可。上面的示例可以修改成： 123.box &#123; width: 10px * 2;&#125; [Sass运算]除法Sass 的乘法运算规则也适用于除法运算。不过除法运算还有一个特殊之处。众所周知“/”符号在 CSS 中已做为一种符号使用。因此在 Sass 中做除法运算时，直接使用“/”符号做为除号时，将不会生效，编译时既得不到我们需要的效果，也不会报错。一起先来看一个简单的示例： 123.box &#123; width: 100px / 2; &#125; 这样的结果对于大家来说没有任何意义。要修正这个问题，只需要给运算的外面添加一个小括号( )即可： 123.box &#123; width: (100px / 2); &#125; 除了上面情况带有小括号，“/”符号会当作除法运算符之外，如果“/”符号在已有的数学表达式中时，也会被认作除法符号。如下面示例： 123.box &#123; width: 100px / 2 + 2in; &#125; 另外，在 Sass 除法运算中，当用变量进行除法运算时，“/”符号也会自动被识别成除法，如下例所示： 12345678910$width: 1000px;$nums: 10;.item &#123; width: $width / 10; &#125;.list &#123; width: $width / $nums;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"Sass","slug":"技术/Sass","permalink":"https://www.kaige1220.top/categories/技术/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"https://www.kaige1220.top/tags/Sass/"}]},{"title":"React4-React事件与数据的双向绑定","slug":"React系列文章6","date":"2018-06-23T09:31:49.776Z","updated":"2018-06-10T02:42:32.388Z","comments":true,"path":"2018/06/23/React系列文章6/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/React系列文章6/","excerpt":"事件的绑定 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: \"IMOOC\",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"提交\" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125;","text":"事件的绑定 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: \"IMOOC\",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"提交\" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125; Props 属性： props 对于模块属于外来属性 传递参数： 在被引入模块中添加{this.props.userid} 这里面的userid就是你引用的一个参数，然后你就可以在引入该模块的文件中给这个userid进行赋值了：&lt;’被引入的模块’ userid={1220}/&gt;，这样就可以顺利的传递参数了。 模块中接受参数：this.props.username 被引入模块的示例代码：123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : \"Parry\", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 引入模块文件的示例代码：1234567891011121314151617var React = require('react');var ReactDOM = require('react-dom');import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;\"nick\"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"https://www.kaige1220.top/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"node","slug":"node","permalink":"https://www.kaige1220.top/tags/node/"}]},{"title":"React4-React 属性与事件","slug":"React系列文章5","date":"2018-06-23T09:31:49.759Z","updated":"2018-06-10T02:31:27.249Z","comments":true,"path":"2018/06/23/React系列文章5/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/React系列文章5/","excerpt":"State属性 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\", age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;","text":"State属性 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\", age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; Props 属性： props 对于模块属于外来属性 传递参数： 在被引入模块中添加{this.props.userid} 这里面的userid就是你引用的一个参数，然后你就可以在引入该模块的文件中给这个userid进行赋值了：&lt;’被引入的模块’ userid={1220}/&gt;，这样就可以顺利的传递参数了。 模块中接受参数：this.props.username 被引入模块的示例代码：123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : \"Parry\", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 引入模块文件的示例代码：1234567891011121314151617var React = require('react');var ReactDOM = require('react-dom');import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;\"nick\"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"https://www.kaige1220.top/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"node","slug":"node","permalink":"https://www.kaige1220.top/tags/node/"}]},{"title":"React4-React生命周期","slug":"React系列文章4","date":"2018-06-23T09:31:49.745Z","updated":"2018-06-12T00:25:56.288Z","comments":true,"path":"2018/06/23/React系列文章4/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/React系列文章4/","excerpt":"React生命周期官方文档React生命周期图例：","text":"React生命周期官方文档React生命周期图例： React生命周期代码示例：12345678910111213141516171819202122232425262728293031import React from 'react';export default class BodyIndex extends React.Component&#123;//定义页面将要加载 componentWillMount()&#123; //定义你的逻辑即可 console.log(\"BodyIndex - componentWillMount\"); &#125;//定义页面加载完成 componentDidMount()&#123; console.log(\"BodyIndex - componentDidMount\"); &#125; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"https://www.kaige1220.top/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"node","slug":"node","permalink":"https://www.kaige1220.top/tags/node/"}]},{"title":"React3-React内置表达式","slug":"React系列文章3","date":"2018-06-23T09:31:49.729Z","updated":"2018-06-12T00:30:36.755Z","comments":true,"path":"2018/06/23/React系列文章3/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/React系列文章3/","excerpt":"三元表达式：12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component&#123; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125;","text":"三元表达式：12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component&#123; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125; React 三元表达式 {window.userName == ‘’ ? ‘默认用户名’ : ‘用户名： ‘ + userName} 注意是== ， 而不是”=” React 传参 disabled={boolInput} 不要用”” 而是用{}; React注释如何来写 如果在代码块里面： {/注释/} 在代码块外面： //comments React如果要显示html里面的空格 HTML 要显示可以进行 Unicode 转码","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"https://www.kaige1220.top/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"node","slug":"node","permalink":"https://www.kaige1220.top/tags/node/"}]},{"title":"React2-React组件化","slug":"React系列文章2","date":"2018-06-23T09:31:49.717Z","updated":"2018-06-09T07:01:36.714Z","comments":true,"path":"2018/06/23/React系列文章2/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/React系列文章2/","excerpt":"React 机制","text":"React 机制 React 组件 组件是 React 的一个主要特性 组件对于模块化开发的重要性 组件的 return 函数里返回的 HTML 节点必须是一个 可以给外部使用的组件定义：export default class ComponentHeader extends React.Component{} 入口的定义：ReactDOM.render(, document.getElementById(‘example’)); 组件return 函数返回Html的节点必须是一个 index.js 里面代码示例:12345678910111213141516import React from 'react';import PCHeader from './pc_header';import PCFooter from './pc_footer';import PCNewsContainer from './pc_newscontainer';export default class PCIndex extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;PCHeader&gt;&lt;/PCHeader&gt; &lt;PCNewsContainer&gt;&lt;/PCNewsContainer&gt; &lt;PCFooter&gt;&lt;/PCFooter&gt; &lt;/div&gt; ); &#125;;&#125; pc_header.js 里面代码示例:1234567891011import React from 'react';import &#123;Row, Col&#125; from 'antd';import &#123;Router, Route, Link, browserHistory&#125; from 'react-router'class PCHeader extends React.Component &#123;render()&#123; return( &lt;h1&gt;这是页头&lt;/h1&gt; );&#125; &#125; React 多组件嵌套通过上面的示例我们可以看到：组件也可以通过参数的形式传递。把pc_header.js 组件作为一个参数传递到index.js里面。 这样我们可以分别开发页面不同的部分，非常方便。 需要注意的有两点： 命名的规范化。 项目搭建的规范化。 这里我们需要注意一个项目怎么去搭建项目的结构，下面是示例图片，可以参考下：","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"https://www.kaige1220.top/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"node","slug":"node","permalink":"https://www.kaige1220.top/tags/node/"}]},{"title":"React1-react简介及安装","slug":"react系列1","date":"2018-06-23T09:31:49.705Z","updated":"2018-06-09T06:40:55.284Z","comments":true,"path":"2018/06/23/react系列1/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/react系列1/","excerpt":"本文主要讲述使用react创建一个新闻站点的技术教程，本文主要技术来源于：慕课网。如果你感兴趣，可以跟着一起来完成。 React的简介 Facebook 内部用来开发Instagram JavaScript MVC框架 React 开源网址：React github React 中文文档：React中文文档","text":"本文主要讲述使用react创建一个新闻站点的技术教程，本文主要技术来源于：慕课网。如果你感兴趣，可以跟着一起来完成。 React的简介 Facebook 内部用来开发Instagram JavaScript MVC框架 React 开源网址：React github React 中文文档：React中文文档 学习React需要掌握的知识 JS ES5/Es6 ——会使用babel ——&gt; 中文文档：babel NodeJS CSS HTML React 安装及管理 确保先安装了node.js —-最新的node.js包已经包含了npm 怎么查看是否安装？ node -v npm -v npm 换镜像源 （用淘宝的源就可以） 这样下载就比较快了 最好采用npm 安装管理 （官方推荐方式） 用npm 安装React 项目初始化 1npm init 通过初始化就建立了一个react的配置文件，下面再进行安装react需要的其他依赖包。 安装依赖包可以有两种方式：1、先在配置文件里加入需要安装的文件包名和版本，然后通过npm install 来进行安装2、直接用npm来安装 方式如下：npm install babel-preset-es2015@版本号 –save 这样你安装的包就可以把安装依赖的信息存储到配置文件里了 这里我们需要安装的依赖包有babel-preset-es2015 、babelify、babel-preset-react、react、react-dom 等 其他需要的依赖包可以在后续不断加入 注： 如果要全局安装的话可以这样 npm install -g react 至此，我们还不能实现react的正常输出，我们还需要通过webpack来打包。 webpack 的安装 在安装webpack之前，先了解下react的写作流程：先在项目文件里建立一个src文件夹在里面建一个index.js文件 这个文件要传到外面的文件index.html。index.js里这样写： 12345678910var React = require(\"react\");var ReactDOM = require(\"react-dom\");class Index extends React.Component &#123; render() &#123; return( &lt;h1&gt;hello world&lt;/h1&gt; document.getElementById('example') ); &#125;&#125; index.html里这样写：12&lt;div id=\"example\"&gt;123&lt;/div&gt;&lt;script src=\"./src/bundle.js\"&gt;&lt;/script&gt; 这里引入的bundle.js 就是webpack 生成的，他是把我们之前写的index.js生成了浏览器能识别的js文件，这样才能被浏览器识别。 webpack正式安装首先定义一个webpack的配置文件：webpack config.js 通过官方文档来配置。安装：全局安装一下：12npm install -g webpacknpm install -g webpack-dev-server //服务器 项目目录里安装一下：12npm install webpack --savenpm install webpack-dev-server --save //服务器 注： 一定要注意版本的问题，要和react等合适，如果都是最新的应该没问题。 下面来运行： webpack //在命令行执行就会把我们的index.js生成可识别的js文件了。 怎样自动加载呢： webpack-dev-server --contentbase -src --inline //执行后就可以自动加载了","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"https://www.kaige1220.top/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.kaige1220.top/tags/react/"},{"name":"node","slug":"node","permalink":"https://www.kaige1220.top/tags/node/"}]},{"title":"node.js 入门系列","slug":"node学习","date":"2018-06-23T09:31:49.699Z","updated":"2018-06-25T02:46:42.258Z","comments":true,"path":"2018/06/23/node学习/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/node学习/","excerpt":"一、搭建node.js开发环境二、模块使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。","text":"一、搭建node.js开发环境二、模块使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。在上一节，我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。 我们把hello.js改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数： 123456789'use strict';var s = 'Hello';function greet(name) &#123; console.log(s + ', ' + name + '!');&#125;module.exports = greet; 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。 问题是其他模块怎么使用hello模块的这个greet函数呢？我们再编写一个main.js文件，调用hello模块的greet函数： 12345678'use strict';// 引入hello模块:var greet = require('./hello');var s = 'Michael';greet(s); // Hello, Michael! 注意到引入hello模块用Node提供的require函数： var greet = require(‘./hello’); 引入的模块作为变量保存在greet变量中，那greet变量到底是什么东西？其实变量greet就是在hello.js中我们用module.exports = greet;输出的greet函数。所以，main.js就成功地引用了hello.js模块中定义的greet()函数，接下来就可以直接使用它了。 在使用require()引入模块的时候，请注意模块的相对路径。因为main.js和hello.js位于同一个目录，所以我们用了当前目录.： var greet = require(‘./hello’); // 不要忘了写相对目录! CommonJS规范这种模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，hello.js和main.js都申明了全局变量var s = ‘xxx’，但互不影响。 一个模块想要对外暴露变量（函数也是变量），可以用module.exports = variable;，一个模块要引用其他模块暴露的变量，用var ref = require(‘module_name’);就拿到了引用模块的变量。 三、深入了解模块原理其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。 请注意我们编写的hello.js代码是这样的：1234var s = 'Hello';var name = 'world';console.log(s + ' ' + name + '!'); Node.js加载了hello.js后，它可以把代码包装一下，变成这样执行： 12345678(function () &#123; // 读取的hello.js代码: var s = 'Hello'; var name = 'world'; console.log(s + ' ' + name + '!'); // hello.js代码结束&#125;)(); 这样一来，原来的全局变量s现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义的“全局”变量s也互不干扰。 所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。 但是，模块的输出module.exports怎么实现？ 这个也很容易实现，Node可以先准备一个对象module： 123456789101112131415161718// 准备module对象:var module = &#123; id: 'hello', exports: &#123;&#125;&#125;;var load = function (module) &#123; // 读取的hello.js代码: function greet(name) &#123; console.log('Hello, ' + name + '!'); &#125; module.exports = greet; // hello.js代码结束 return module.exports;&#125;;var exported = load(module);// 保存module:save(module, exported); 可见，变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在hello.js中可以直接使用变量module原因就在于它实际上是函数的一个参数： module.exports = greet;通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。 由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出： var greet = require(‘./hello’); 四、基本模块4.1 global在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫window对象。而在Node.js环境中，也有唯一的全局对象，但不叫window，而叫global，这个对象的属性和方法也和浏览器环境的window不同。 4.2 processprocess也是Node.js提供的一个对象，它代表当前Node.js进程。通过process对象可以拿到许多有用信息： 4.3 fs基本模块Node.js内置的fs模块就是文件系统模块，负责读写文件。 和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。 异步读文件按照JavaScript的标准，异步读取一个文本文件的代码如下： 1234567891011'use strict';var fs = require('fs');fs.readFile('sample.txt', 'utf-8', function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。 如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？ 下面的例子演示了如何读取一个图片文件： 123456789101112'use strict';var fs = require('fs');fs.readFile('sample.png', function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + ' bytes'); &#125;&#125;); 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。 Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String：123// Buffer -&gt; Stringvar text = data.toString('utf-8');console.log(text); 或者把一个String转换成Buffer： 123// String -&gt; Buffervar buf = Buffer.from(text, 'utf-8');console.log(buf); 写文件将数据写入文件是通过fs.writeFile()实现的： 123456789101112'use strict';var fs = require('fs');var data = 'Hello, Node.js';fs.writeFile('output.txt', data, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('ok.'); &#125;&#125;); writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。 stat如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息： 12345678910111213141516171819202122'use strict';var fs = require('fs');fs.stat('sample.txt', function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log('isFile: ' + stat.isFile()); // 是否是目录: console.log('isDirectory: ' + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log('size: ' + stat.size); // 创建时间, Date对象: console.log('birth time: ' + stat.birthtime); // 修改时间, Date对象: console.log('modified time: ' + stat.mtime); &#125; &#125;&#125;); stream模块stream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。 什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。 如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。 有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。 在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。 下面是一个从文件流读取文本内容的示例： 1234567891011121314151617181920'use strict';var fs = require('fs');// 打开一个流:var rs = fs.createReadStream('sample.txt', 'utf-8');rs.on('data', function (chunk) &#123; console.log('DATA:') console.log(chunk);&#125;);rs.on('end', function () &#123; console.log('END');&#125;);rs.on('error', function (err) &#123; console.log('ERROR: ' + err);&#125;); 要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。 要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束：12345678910111213'use strict';var fs = require('fs');var ws1 = fs.createWriteStream('output1.txt', 'utf-8');ws1.write('使用Stream写入文本数据...\\n');ws1.write('END.');ws1.end();var ws2 = fs.createWriteStream('output2.txt');ws2.write(new Buffer('使用Stream写入二进制数据...\\n', 'utf-8'));ws2.write(new Buffer('END.', 'utf-8'));ws2.end(); 所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。 pipe就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。 在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。 让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：12345678'use strict';var fs = require('fs');var rs = fs.createReadStream('sample.txt');var ws = fs.createWriteStream('copied.txt');rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： readable.pipe(writable, { end: false }); http模块HTTP服务器要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。 request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息； response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!： 1234567891011121314151617181920'use strict';// 导入http模块:var http = require('http');// 创建http server，并传入回调函数:var server = http.createServer(function (request, response) &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(request.method + ': ' + request.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 将HTTP响应的HTML内容写入response: response.end('&lt;h1&gt;Hello world!&lt;/h1&gt;');&#125;);// 让服务器监听8080端口:server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); 在命令提示符下运行该程序，可以看到以下输出： $ node hello.jsServer is running at http://127.0.0.1:8080/ 文件服务器让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。 解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象： 12345678910111213141516171819202122232425'use strict';var url = require('url');console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));``` 结果如下：```jsUrl &#123; protocol: 'http:', slashes: true, auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/path/to/file', path: '/path/to/file?query=string', href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' &#125; 处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960'use strict';var path = require('path');// 解析当前目录:var workDir = path.resolve('.'); // '/Users/michael'// 组合完整的文件路径:当前目录+'pub'+'index.html':var filePath = path.join(workDir, 'pub', 'index.html');// '/Users/michael/pub/index.html'``` 使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于C:\\Users\\michael\\static\\index.html，这样，我们就不关心怎么拼接路径了。最后，我们实现一个文件服务器file_server.js：```js'use strict';var fs = require('fs'), url = require('url'), path = require('path'), http = require('http');// 从命令行参数获取root目录，默认是当前目录:var root = path.resolve(process.argv[2] || '.');console.log('Static root dir: ' + root);// 创建服务器:var server = http.createServer(function (request, response) &#123; // 获得URL的path，类似 '/css/bootstrap.css': var pathname = url.parse(request.url).pathname; // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css': var filepath = path.join(root, pathname); // 获取文件状态: fs.stat(filepath, function (err, stats) &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在: console.log('200 ' + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filepath).pipe(response); &#125; else &#123; // 出错了或者文件不存在: console.log('404 ' + request.url); // 发送404响应: response.writeHead(404); response.end('404 Not Found'); &#125; &#125;);&#125;);server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); crypto模块crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。 MD5和SHA1MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示： 123456789const crypto = require('crypto');const hash = crypto.createHash('md5');// 可任意多次调用update():hash.update('Hello, world!');hash.update('Hello, nodejs!');console.log(hash.digest('hex')); // 7e1977739c748beac0c0fd14fd26a544 update()方法默认字符串编码为UTF-8，也可以传入Buffer。 如果要计算SHA1，只需要把’md5’改成’sha1’，就可以得到SHA1的结果1f32b9c9932c02227819a4151feed43e131aca40。 还可以使用更安全的sha256和sha512。 HmacHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥： 123456789const crypto = require('crypto');const hmac = crypto.createHmac('sha256', 'secret-key');hmac.update('Hello, world!');hmac.update('Hello, nodejs!');console.log(hmac.digest('hex')); // 80f7e22570... 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"https://www.kaige1220.top/categories/技术/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.kaige1220.top/tags/node-js/"}]},{"title":"JS Map 和 Set","slug":"JS系列Map和Set","date":"2018-06-23T09:31:49.685Z","updated":"2018-06-15T01:14:22.249Z","comments":true,"path":"2018/06/23/JS系列Map和Set/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/JS系列Map和Set/","excerpt":"MapJavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。 为了解决这个问题，最新的ES6规范引入了新的数据类型Map。 Map是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85];","text":"MapJavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。 为了解决这个问题，最新的ES6规范引入了新的数据类型Map。 Map是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 注意数字3和字符串’3’是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素：1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for … of循环来遍历。 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： 123456789'use strict';var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"Map和Set","slug":"技术/JavaScript/Map和Set","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/Map和Set/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.kaige1220.top/tags/JavaScript/"},{"name":"Map和Set","slug":"Map和Set","permalink":"https://www.kaige1220.top/tags/Map和Set/"}]},{"title":"JS条件判断和循环","slug":"JS系列3","date":"2018-06-23T09:31:49.675Z","updated":"2018-06-15T01:00:48.804Z","comments":true,"path":"2018/06/23/JS系列3/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/JS系列3/","excerpt":"条件判断JavaScript使用if () { … } else { … }来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下： 多行条件判断如果还要更细致地判断条件，可以使用多个if…else…的组合： 12345678var age = 3;if (age &gt;= 18) &#123; alert('adult');&#125; else if (age &gt;= 6) &#123; alert('teenager');&#125; else &#123; alert('kid');&#125;","text":"条件判断JavaScript使用if () { … } else { … }来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下： 多行条件判断如果还要更细致地判断条件，可以使用多个if…else…的组合： 12345678var age = 3;if (age &gt;= 18) &#123; alert('adult');&#125; else if (age &gt;= 6) &#123; alert('teenager');&#125; else &#123; alert('kid');&#125; 循环计算1+2+3，我们可以直接写表达式： 1 + 2 + 3; // 6要计算1+2+3+…+10，勉强也能写出来。 但是，要计算1+2+3+…+10000，直接写表达式就不可能了。 为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。 JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块： 123456var x = 0;var i;for (i=1; i&lt;=10000; i++) &#123; x = x + i;&#125;x; // 50005000 for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环： for … infor循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来： 12345678var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; console.log(key); // 'name', 'age', 'city'&#125; 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for … in循环可以直接循环出Array的索引： 12345var a = ['A', 'B', 'C'];for (var i in a) &#123; console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'&#125; 请注意，for … in对Array的循环得到的是String而不是Number。 whilefor循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的for循环容易让人看不清循环的逻辑，此时用while循环更佳。 while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：1234567var x = 0;var n = 99;while (n &gt; 0) &#123; x = x + n; n = n - 2;&#125;x; // 2500 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 do … while最后一种循环是do { … } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件： 12345var n = 0;do &#123; n = n + 1;&#125; while (n &lt; 100);n; // 100","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"条件判断和循环","slug":"技术/JavaScript/条件判断和循环","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/条件判断和循环/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.kaige1220.top/tags/JavaScript/"},{"name":"条件判断和循环","slug":"条件判断和循环","permalink":"https://www.kaige1220.top/tags/条件判断和循环/"}]},{"title":"JS数据类型和变量","slug":"JS系列2","date":"2018-06-23T09:31:49.662Z","updated":"2018-06-15T00:33:40.459Z","comments":true,"path":"2018/06/23/JS系列2/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/JS系列2/","excerpt":"NumberJavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型： 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity","text":"NumberJavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型： 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。 如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。 如果字符串内部既包含’又包含”怎么办？可以用转义字符\\来标识，比如： 1'I\\'m \\\"OK\\\"!'; 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\表示的字符就是\\。 多行字符串由于多行字符串用\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ... 表示： 要把多个字符串连接起来，可以用+号连接 要把多个字符串连接起来，可以用+号连接： 1234var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 操作字符串1、 .length2、 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始： 1234567var s = 'Hello, world!';s[0]; // 'H's[6]; // ' 's[7]; // 'w's[12]; // '!'s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 3、 toUpperCase toLowerCase 4、 indexOf indexOf()会搜索指定字符串出现的位置： 123var s = 'hello, world';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1 5、 substring substring()返回指定索引区间的子串： 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值，要么是true，要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来： 1234true; // 这是一个true值false; // 这是一个false值2 &gt; 1; // 这是一个true值2 &gt;= 3; // 这是一个false值 比较运算符当我们对Number做比较时，可以通过比较运算符得到一个布尔值： 1232 &gt; 5; // false5 &gt;= 2; // true7 == 7; // true 实际上，JavaScript允许对任意数据类型做比较： 12false == 0; // truefalse === 0; // false 要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： 1NaN === NaN; // false 最后要注意浮点数的相等比较： 11 / 3 === (1 - 2 / 3); // false 浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true null和undefinednull表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。 在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：1[1, 2, 3.14, &apos;Hello&apos;, null, true]; 数组的元素可以通过索引来访问。请注意，索引的起始值为0： 1234var arr = [1, 2, 3.14, 'Hello', null, true];arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined 操作数组indexOf与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： 12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 注意了，数字30和字符串’30’是不同的元素。 sliceslice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false push和poppush()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift和shift如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： sortsort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] reversereverse()把整个Array的元素给掉个个，也就是反转： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splicesplice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concatconcat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] joinjoin()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 多维数组如果数组的某个元素又是一个Array，则可以形成多维数组，例如： 1var arr = [[1, 2, 3], [400, 500, 600], '-']; 上述Array包含3个元素，其中头两个元素本身也是Array。 对象JavaScript的对象是一组由键-值组成的无序集合，例如： 12345678var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;; 要获取一个对象的属性，我们用对象变量.属性名的方式： 12person.name; // 'Bob'person.zipcode; // null 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如： 12345var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = '007'; // s_007是一个字符串var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null strict模式JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：1i = 10; // i现在是全局变量","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/"},{"name":"数据类型和变量","slug":"技术/JavaScript/数据类型和变量","permalink":"https://www.kaige1220.top/categories/技术/JavaScript/数据类型和变量/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.kaige1220.top/tags/JavaScript/"},{"name":"数据类型和变量","slug":"数据类型和变量","permalink":"https://www.kaige1220.top/tags/数据类型和变量/"}]},{"title":"JS-AJAX","slug":"JS-AJAX","date":"2018-06-23T09:31:49.645Z","updated":"2018-06-20T07:44:17.204Z","comments":true,"path":"2018/06/23/JS-AJAX/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/JS-AJAX/","excerpt":"","text":"如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。 这就是Web的运作原理：一次HTTP请求对应一个页面。 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象： 1234567891011121314151617181920212223242526272829303132function success(text) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = text;&#125;function fail(code) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code;&#125;var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。 XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 安全限制上面代码的URL使用的是相对路径。如果你把它改为’http://www.sina.com.cn/&#39;，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。 这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。 完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。 那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的: 第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JS-AJAX","slug":"技术/JS-AJAX","permalink":"https://www.kaige1220.top/categories/技术/JS-AJAX/"}],"tags":[{"name":"JS-AJAX","slug":"JS-AJAX","permalink":"https://www.kaige1220.top/tags/JS-AJAX/"}]},{"title":"jQuery动画","slug":"jQuery4","date":"2018-06-23T09:31:49.632Z","updated":"2018-06-20T07:11:38.801Z","comments":true,"path":"2018/06/23/jQuery4/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/jQuery4/","excerpt":"show / hide直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画： toggle()方法则根据当前状态决定是show()还是hide()。 slideUp / slideDownshow()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的。 slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作。","text":"show / hide直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画： toggle()方法则根据当前状态决定是show()还是hide()。 slideUp / slideDownshow()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的。 slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作。 fadeIn / fadeOutfadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断设置DOM元素的opacity属性来实现，而fadeToggle()则根据元素是否可见来决定下一步动作 自定义动画animate()，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值： 123456var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000); // 在3秒钟内CSS过渡到设定值 animate()还可以再传入一个函数，当动画结束时，该函数将被调用： 12345678910var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000, function () &#123; console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');&#125;); 串行动画jQuery的动画效果还可以串行执行，通过delay()方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单： 123456789101112131415var div = $('#test-animates');// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小div.slideDown(2000) .delay(1000) .animate(&#123; width: '256px', height: '256px' &#125;, 2000) .delay(1000) .animate(&#123; width: '128px', height: '128px' &#125;, 2000);&#125;&lt;/script&gt; 为什么有的动画没有效果你可能会遇到，有的动画如slideUp()根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如height从100px逐渐变为0。但是很多不是block性质的DOM元素，对它们设置height根本就不起作用，所以动画也就没有效果。 此外，jQuery也没有实现对background-color的动画效果，用animate()设置background-color也没有效果。这种情况下可以使用CSS3的transition实现动画效果。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"jQuery动画","slug":"技术/jQuery动画","permalink":"https://www.kaige1220.top/categories/技术/jQuery动画/"}],"tags":[{"name":"jQuery动画","slug":"jQuery动画","permalink":"https://www.kaige1220.top/tags/jQuery动画/"}]},{"title":"jQuery事件","slug":"jQuery3","date":"2018-06-23T09:31:49.617Z","updated":"2018-06-20T00:06:22.551Z","comments":true,"path":"2018/06/23/jQuery3/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/jQuery3/","excerpt":"jQuery能够绑定的事件主要包括：鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。","text":"jQuery能够绑定的事件主要包括：鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件键盘事件仅作用在当前焦点的DOM上，通常是 &lt;input&gt; 和 &lt;textarea&gt; 。 keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 其他事件 focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发； submit：当&lt;form&gt;提交时触发； ready：当页面被载入并且DOM树完成初始化后触发。 其中，ready仅作用于document对象。由于ready事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。 因为JavaScript在此执行的时候，&lt;form&gt;尚未载入浏览器，所以$(‘#testForm)返回[]，并没有绑定事件到任何DOM上。 所以我们自己的初始化代码必须放到document对象的ready事件中，保证DOM已完成初始化： 12345$(document).on('ready', function () &#123; $('#testForm).on('submit', function () &#123; alert('submit!'); &#125;); &#125;); 由于ready事件使用非常普遍，所以可以这样简化：123456$(document).ready(function () &#123; // on('submit', function)也可以简化: $('#testForm).submit(function () &#123; alert('submit!'); &#125;);&#125;); 甚至还可以再简化为：123$(function () &#123; // init...&#125;); 上面的这种写法最为常见。如果你遇到$(function () {…})的形式，牢记这是document对象的ready事件处理函数。 事件参数有些事件，如mousemove和keypress，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入Event对象作为参数，可以从Event对象上获取到更多的信息：12345$(function () &#123; $('#testMouseMoveDiv').mousemove(function (e) &#123; $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); &#125;);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"jQuery事件","slug":"技术/jQuery事件","permalink":"https://www.kaige1220.top/categories/技术/jQuery事件/"}],"tags":[{"name":"jQuery事件","slug":"jQuery事件","permalink":"https://www.kaige1220.top/tags/jQuery事件/"}]},{"title":"jQuery操作DOM","slug":"jQuery2","date":"2018-06-23T09:31:49.602Z","updated":"2018-06-19T06:56:10.980Z","comments":true,"path":"2018/06/23/jQuery2/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/jQuery2/","excerpt":"一、修改Text和HTMLjQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构： 12345&lt;!-- HTML结构 --&gt;&lt;ul id=\"test-ul\"&gt; &lt;li class=\"js\"&gt;JavaScript&lt;/li&gt; &lt;li name=\"book\"&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 分别获取文本和HTML：12$('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript'$('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript' 如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作。","text":"一、修改Text和HTMLjQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构： 12345&lt;!-- HTML结构 --&gt;&lt;ul id=\"test-ul\"&gt; &lt;li class=\"js\"&gt;JavaScript&lt;/li&gt; &lt;li name=\"book\"&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 分别获取文本和HTML：12$('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript'$('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript' 如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作。 修改CSSjQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构 12345678&lt;!-- HTML结构 --&gt;&lt;ul id=\"test-css\"&gt; &lt;li class=\"lang dy\"&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang\"&gt;&lt;span&gt;Java&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang dy\"&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang\"&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang dy\"&gt;&lt;span&gt;Scheme&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; 要高亮显示动态语言，调用jQuery对象的css(‘name’, ‘value’)方法，我们用一行语句实现： $(‘#test-css li.dy&gt;span’).css(‘background-color’, ‘#ffd351’).css(‘color’, ‘red’); 为了和JavaScript保持一致，CSS属性可以用’background-color’和’backgroundColor’两种格式。 css()方法将作用于DOM节点的style属性，具有最高优先级。如果要修改class属性，可以用jQuery提供的下列方法： 1234var div = $('#test-div');div.hasClass('highlight'); // false， class是否包含highlightdiv.addClass('highlight'); // 添加highlight这个classdiv.removeClass('highlight'); // 删除highlight这个class 显示和隐藏DOM要隐藏一个DOM，我们可以设置CSS的display属性为none，利用css()方法就可以实现。不过，要显示这个DOM就需要恢复原有的display属性，这就得先记下来原有的display属性到底是block还是inline还是别的值。 考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供show()和hide()方法，我们不用关心它是如何修改display属性的，总之它能正常工作： var a = $(‘a[target=_blank]’);a.hide(); // 隐藏a.show(); // 显示 隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。 获取DOM信息利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码： 1234567891011121314// 浏览器可视窗口大小:$(window).width(); // 800$(window).height(); // 600// HTML文档大小:$(document).width(); // 800$(document).height(); // 3500// 某个div的大小:var div = $('#test-div');div.width(); // 600div.height(); // 300div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效 attr()和removeAttr()方法用于操作DOM节点的属性： // …var div = $(‘#test-div’);div.attr(‘data’); // undefined, 属性不存在div.attr(‘name’); // ‘Test’div.attr(‘name’, ‘Hello’); // div的name属性变为’Hello’div.removeAttr(‘name’); // 删除name属性div.attr(‘name’); // undefined 操作表单对于表单元素，jQuery对象统一提供val()方法获取和设置对应的value属性： 12345678910111213141516171819202122/* &lt;input id=\"test-input\" name=\"email\" value=\"\"&gt; &lt;select id=\"test-select\" name=\"city\"&gt; &lt;option value=\"BJ\" selected&gt;Beijing&lt;/option&gt; &lt;option value=\"SH\"&gt;Shanghai&lt;/option&gt; &lt;option value=\"SZ\"&gt;Shenzhen&lt;/option&gt; &lt;/select&gt; &lt;textarea id=\"test-textarea\"&gt;Hello&lt;/textarea&gt;*/var input = $('#test-input'), select = $('#test-select'), textarea = $('#test-textarea');input.val(); // 'test'input.val('abc@example.com'); // 文本框的内容已变为abc@example.comselect.val(); // 'BJ'select.val('SH'); // 选择框已变为Shanghaitextarea.val(); // 'Hello'textarea.val('Hi'); // 文本区域已更新为'Hi' 修改DOM要添加新的DOM节点，除了通过jQuery的html()这种暴力方法外，还可以用append()方法，例如：1234567&lt;div id=\"test-div\"&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如何向列表新增一个语言？首先要拿到节点： var ul = $(‘#test-div&gt;ul’); 然后，调用append()传入HTML片段：1ul.append('&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'); 除了接受字符串，append()还可以传入原始的DOM对象，jQuery对象和函数对象： append()把DOM添加到最后，prepend()则把DOM添加到最前。 删除节点要删除DOM节点，拿到jQuery对象后直接调用remove()方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点： var li = $(‘#test-div&gt;ul&gt;li’);li.remove(); // 所有全被删除","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"jQuery操作DOM","slug":"技术/jQuery操作DOM","permalink":"https://www.kaige1220.top/categories/技术/jQuery操作DOM/"}],"tags":[{"name":"jQuery操作DOM","slug":"jQuery操作DOM","permalink":"https://www.kaige1220.top/tags/jQuery操作DOM/"}]},{"title":"jQuery选择器","slug":"jQuery","date":"2018-06-23T09:31:49.586Z","updated":"2018-06-19T05:48:52.691Z","comments":true,"path":"2018/06/23/jQuery/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/jQuery/","excerpt":"一、选择器按ID查找// 查找:var div = $(‘#abc’); #abc以#开头。返回的对象是jQuery对象。 什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。 以上面的查找为例，如果id为abc的存在，返回的jQuery对象如下： […] 如果id为abc的不存在，返回的jQuery对象如下： []","text":"一、选择器按ID查找// 查找:var div = $(‘#abc’); #abc以#开头。返回的对象是jQuery对象。 什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。 以上面的查找为例，如果id为abc的存在，返回的jQuery对象如下： […] 如果id为abc的不存在，返回的jQuery对象如下： [] 按tag查找按tag查找只需要写上tag名称就可以了： var ps = $(‘p’); // 返回所有节点ps.length; // 数一数页面有多少个节点 按class查找按class查找注意在class名称前加一个.： var a = $(‘.red’); // 所有节点包含class=&quot;red&quot;都将返回// 例如:// …// … 通常很多节点有多个class，我们可以查找同时包含red和green的节点： var a = $(‘.red.green’); // 注意没有空格！// 符合条件的节点：// …// … 按属性查找一个DOM节点除了id和class外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找： var email = $(‘[name=email]’); // 找出&lt;??? name=”email”&gt;var passwordInput = $(‘[type=password]’); // 找出&lt;??? type=”password”&gt;var a = $(‘[items=”A B”]’); // 找出&lt;??? items=”A B”&gt; 当属性的值包含空格等特殊字符时，需要用双引号括起来。 按属性查找还可以使用前缀查找或者后缀查找： var icons = $(‘[name^=icon]’); // 找出所有name属性值以icon开头的DOM// 例如: name=”icon-1”, name=”icon-2”var names = $(‘[name$=with]’); // 找出所有name属性值以with结尾的DOM// 例如: name=”startswith”, name=”endswith”这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响： var icons = $(‘[class^=”icon-“]’); // 找出所有class包含至少一个以icon-开头的DOM// 例如: class=”icon-clock”, class=”abc icon-home” 组合查找组合查找就是把上述简单选择器组合起来使用。如果我们查找$(‘[name=email]’)，很可能把表单外的也找出来，但我们只希望查找，就可以这么写： var emailInput = $(‘input[name=email]’); // 不会找出 同样的，根据tag和class来组合查找也很常见： var tr = $(‘tr.red’); // 找出… 多项选择器多项选择器就是把多个选择器用,组合起来一块选：$(‘p,div’); // 把和都选出来$(‘p.red,p.green’); // 把和都选出来 层级选择器（Descendant Selector）如果两个DOM元素具有层级关系，就可以用$(‘ancestor descendant’)来选择，层级之间用空格隔开。 子选择器（Child Selector）子选择器$(‘parent&gt;child’)类似层级选择器，但是限定了层级关系必须是父子关系，就是节点必须是节点的直属子节点。 过滤器（Filter）过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果： 1234567$('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点$('ul.lang li:first-child'); // 仅选出JavaScript$('ul.lang li:last-child'); // 仅选出Lua$('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始$('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素 表单相关针对表单元素，jQuery还有一组特殊的选择器： :input：可以选择，，和； :file：可以选择，和input[type=file]一样； :checkbox：可以选择复选框，和input[type=checkbox]一样； :radio：可以选择单选框，和input[type=radio]一样； :focus：可以选择当前输入焦点的元素，例如把光标放到一个上，用$(‘input:focus’)就可以选出； :checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$(‘input[type=radio]- :checked’)； :enabled：可以选择可以正常输入的、等，也就是没有灰掉的输入； :disabled：和:enabled正好相反，选择那些不能输入的。 查找和过滤通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。 最常见的查找是在某个节点的所有子节点中查找，使用find()方法，它本身又接收一个任意的选择器。 12345678&lt;!-- HTML结构 --&gt;&lt;ul class=\"lang\"&gt; &lt;li class=\"js dy\"&gt;JavaScript&lt;/li&gt; &lt;li class=\"dy\"&gt;Python&lt;/li&gt; &lt;li id=\"swift\"&gt;Swift&lt;/li&gt; &lt;li class=\"dy\"&gt;Scheme&lt;/li&gt; &lt;li name=\"haskell\"&gt;Haskell&lt;/li&gt;&lt;/ul&gt; 用find()查找：1234var ul = $('ul.lang'); // 获得&lt;ul&gt;var dy = ul.find('.dy'); // 获得JavaScript, Python, Schemevar swf = ul.find('#swift'); // 获得Swiftvar hsk = ul.find('[name=haskell]'); // 获得Haskell 如果要从当前节点开始向上查找，使用parent()方法; 对于位于同一层级的节点，可以通过next()和prev()方法; 过滤和函数式编程的map、filter类似，jQuery对象也有类似的方法。 filter()方法可以过滤掉不符合选择器条件的节点： var langs = $(‘ul.lang li’); // 拿到JavaScript, Python, Swift, Scheme和Haskellvar a = langs.filter(‘.dy’); // 拿到JavaScript, Python, Scheme","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"jQuery选择器","slug":"技术/jQuery选择器","permalink":"https://www.kaige1220.top/categories/技术/jQuery选择器/"}],"tags":[{"name":"jQuery选择器","slug":"jQuery选择器","permalink":"https://www.kaige1220.top/tags/jQuery选择器/"}]},{"title":"jQuery-AJAX","slug":"jQuery-AJAX","date":"2018-06-23T09:31:49.553Z","updated":"2018-06-20T07:28:29.394Z","comments":true,"path":"2018/06/23/jQuery-AJAX/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/jQuery-AJAX/","excerpt":"jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求。ajax(url, settings)函数需要接收一个URL和一个可选的settings对象，常用的选项如下： async：是否异步执行AJAX请求，默认为true，千万不要指定为false； method：发送的Method，缺省为’GET’，可指定为’POST’、’PUT’等； contentType：发送POST请求的格式，默认值为’application/x-www-form-urlencoded; charset=UTF-8’，也可以指定为text/plain、- application/json； data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据- contentType把data序列化成合适的格式； headers：发送的额外的HTTP头，必须是一个object； dataType：接收的数据格式，可以指定为’html’、’xml’、’json’、’text’等，缺省情况下根据响应的Content-Type猜测。 下面的例子发送一个GET请求，并返回一个JSON格式的数据：","text":"jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求。ajax(url, settings)函数需要接收一个URL和一个可选的settings对象，常用的选项如下： async：是否异步执行AJAX请求，默认为true，千万不要指定为false； method：发送的Method，缺省为’GET’，可指定为’POST’、’PUT’等； contentType：发送POST请求的格式，默认值为’application/x-www-form-urlencoded; charset=UTF-8’，也可以指定为text/plain、- application/json； data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据- contentType把data序列化成合适的格式； headers：发送的额外的HTTP头，必须是一个object； dataType：接收的数据格式，可以指定为’html’、’xml’、’json’、’text’等，缺省情况下根据响应的Content-Type猜测。 下面的例子发送一个GET请求，并返回一个JSON格式的数据： 1234var jqxhr = $.ajax('/api/categories', &#123; dataType: 'json'&#125;);// 请求已经发送了 不过，如何用回调函数处理返回的数据和出错时的响应呢？ 还记得Promise对象吗？jQuery的jqXHR对象类似一个Promise对象，我们可以用链式写法来处理各种回调： 12345678910111213141516171819'use strict';function ajaxLog(s) &#123; var txt = $('#test-response-text'); txt.val(txt.val() + '\\n' + s);&#125;$('#test-response-text').val('');var jqxhr = $.ajax('/api/categories', &#123; dataType: 'json'&#125;).done(function (data) &#123; ajaxLog('成功, 收到的数据: ' + JSON.stringify(data));&#125;).fail(function (xhr, status) &#123; ajaxLog('失败: ' + xhr.status + ', 原因: ' + status);&#125;).always(function () &#123; ajaxLog('请求完成: 无论成功或失败都会调用');&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"jQuery-AJAX","slug":"技术/jQuery-AJAX","permalink":"https://www.kaige1220.top/categories/技术/jQuery-AJAX/"}],"tags":[{"name":"jQuery-AJAX","slug":"jQuery-AJAX","permalink":"https://www.kaige1220.top/tags/jQuery-AJAX/"}]},{"title":"JavaScript 基础知识总结","slug":"javaScript系列文章","date":"2018-06-23T09:31:49.547Z","updated":"2018-06-12T12:35:07.912Z","comments":true,"path":"2018/06/23/javaScript系列文章/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/javaScript系列文章/","excerpt":"本文主要是一些基础性的知识回顾，后续吧深入理解的东西发表出来。现在先学习基础性的东西吧。 下面是我总结的一些思维导图：","text":"本文主要是一些基础性的知识回顾，后续吧深入理解的东西发表出来。现在先学习基础性的东西吧。 下面是我总结的一些思维导图：","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"JavaScript系列文章","slug":"技术/JavaScript系列文章","permalink":"https://www.kaige1220.top/categories/技术/JavaScript系列文章/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.kaige1220.top/tags/JavaScript/"}]},{"title":"CSS布局知识","slug":"css布局","date":"2018-06-23T09:31:49.525Z","updated":"2018-07-26T12:44:10.152Z","comments":true,"path":"2018/06/23/css布局/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/css布局/","excerpt":"display设置元素的显示方式 display 默认宽度 可设置宽高 起始位置 block 父元素宽度 是 换行 inline 内容宽度 否 同行 inline-block 内容宽度 是 同行","text":"display设置元素的显示方式 display 默认宽度 可设置宽高 起始位置 block 父元素宽度 是 换行 inline 内容宽度 否 同行 inline-block 内容宽度 是 同行 display:block默认为block的元素：&lt;div&gt;, &lt;p&gt;, &lt;h1&gt; ~ &lt;h6&gt;, &lt;ul&gt;, &lt;form&gt; display:inline默认为inline的元素：&lt;span&gt;, &lt;a&gt;, &lt;label&gt;, &lt;cite&gt;, &lt;em&gt; display:inline-block默认为inline-block的元素：&lt;input&gt;, &lt;textarea&gt;, &lt;select&gt;, &lt;button&gt; display:none设置元素不显示 display:none 与 visibility:hidden 的区别为 display:none 不显示且不占位，但 visibility:hidden 不显示但占位。 positionposition 用于设置定位的方式与top right bottom left z-index 则用于设置参照物位置（必须配合定位一同使用）。 三种定位形式 静态定位（static） 相对定位（relative） 绝对定位（absolute、fixed） position:relative相对定位的元素仍在文档流之中，并按照文档流中的顺序进行排列。参照物为元素本身的位置。 最常用的目的为改变元素层级和设置为绝对定位的参照物 position:absolute建立以包含块为基准的定位，其随即拥有偏移属性和 z-index 属性。 默认宽度为内容宽度 脱离文档流 参照物为第一个定位祖先或根元素（ 元素） position:fixed 默认宽度为内容宽度 脱离文档流 参照物为视窗 z-index其用于设置 Z 轴上得排序，默认值为 0 但可设置为负值。（如不做设置，则按照文档流的顺序排列。后面的元素将置于前面的元素之上） floatCSS 中规定的定位机制，其可实现块级元素同行显示并存在于文档流之中。浮动仅仅影响文档流中下一个紧邻的元素。 clearclear: both | left | right | none | inherit 应用于后续元素 应用于块级元素（block） 使用方法： 优先级自上而下 clearfix 于父元素 浮动后续空白元素 .emptyDiv {clear: both} 为受到影响的元素设置 width: 100% overflow: hidden 也可 块级元素可以使用 不建议使用，影响 HTML 结构 flex专门文章介绍了，在这里不做介绍。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"css布局","slug":"技术/css布局","permalink":"https://www.kaige1220.top/categories/技术/css布局/"}],"tags":[{"name":"css布局","slug":"css布局","permalink":"https://www.kaige1220.top/tags/css布局/"}]},{"title":"CSS 实现各种居中","slug":"CSS实现各种居中方法","date":"2018-06-23T09:31:49.501Z","updated":"2018-06-14T14:15:55.931Z","comments":true,"path":"2018/06/23/CSS实现各种居中方法/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/CSS实现各种居中方法/","excerpt":"一、水平居中1、行内元素居中 顾名思义，行内元素居中是只针对行内元素的，比如文本（text）、图片（img）、按钮等行内元素，可通过给父元素设置 text-align:center 来实现。另外，如果块状元素属性display 被设置为inline时，也是可以使用这种方法。但有个首要条件是子元素必须没有被float影响，否则一切都是无用功。 1234 .div1&#123; text-align:center; &#125;&lt;div class=\"div1\"&gt;Hello world&lt;/div&gt;","text":"一、水平居中1、行内元素居中 顾名思义，行内元素居中是只针对行内元素的，比如文本（text）、图片（img）、按钮等行内元素，可通过给父元素设置 text-align:center 来实现。另外，如果块状元素属性display 被设置为inline时，也是可以使用这种方法。但有个首要条件是子元素必须没有被float影响，否则一切都是无用功。 1234 .div1&#123; text-align:center; &#125;&lt;div class=\"div1\"&gt;Hello world&lt;/div&gt; 2、块状元素居中（1）、定宽块状元素居中 满足定宽（块状元素的宽度width为固定值）和块状两个条件的元素可以通过设置“左右margin”值为“auto”来实现居中。 123456 .div1&#123; width:200px; border:1px solid red; margin:0 auto; &#125;&lt;div class=\"div1\"&gt;Hello world&lt;/div&gt; （2）、不定宽块状元素居中在实际工作中我们会遇到需要为“不定宽度的块状元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。(不定宽块状元素：块状元素的宽度width不固定。) 有三种方法可以对不定宽块状元素进行居中： 方法1： 将要显示的元素加入到 table 标签当中，然后为 table 标签设置“左右margin”值为“auto”来实现居中； 或使用 display : table；然后设该元素“左右margin”值为“auto”来实现居中。后面的display:table; 方法会更简洁。 为什么加入table标签? 是利用table标签的长度自适应性—即不定义其长度也不默认父元素body的长度（table其长度根据其内文本长度决定），因此可以看做一个定宽度块元素，然后再利用定宽度块状居中的margin的方法，使其水平居中。 12345678910111213141516table&#123; margin:0 auto;&#125;&lt;div&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt; &lt;ul&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt; 123456789.wrap&#123; background:#ccc; display:table; margin:0 auto;&#125;&lt;div class=\"wrap\"&gt; Hello world &lt;/div&gt; 方法2： 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。 这种方法相比第一种方法的优势是不用增加无语义标签，但也存在着一些问题：它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值（变成inline-block就可以设置宽高）。 12345678910111213141516.container&#123; text-align:center; &#125;.container ul&#123; list-style:none; margin:0; padding:0; display:inline; //怎么这一句用不用都是一样效果的？ &#125;&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 方法3： 通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。 先设置父元素wrap清除浮动，然后左浮动。定位让wrap向右偏移50%。然后定义子元素相对于父元素向左偏移50%。脱离父元素。加个边框就可以明白一些了。另外用绝对定位也是可以的。123456789101112131415 .wrap&#123; float:left; position:relative; left:50%; clear:both;&#125;.wrap-center&#123; background:#ccc; position:relative; left:-50%;&#125;&lt;div class=\"wrap\"&gt; &lt;div class=\"wrap-center\"&gt;Hello world&lt;/div&gt;&lt;/div&gt; 二、垂直居中垂直居中可分为父元素高度确定的单行文本，以及父元素高度确定的多行文本。 1、父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高，指在文本中，行与行之间的 基线间的距离 )。 12345678910.wrap h2&#123; margin:0; height:100px; line-height:100px; background:#ccc;&#125;&lt;div class=\"wrap\"&gt; &lt;h2&gt;Hello world&lt;/h2&gt;&lt;/div&gt; 2、父元素高度确定的多行文本 有两种方法： 方法1：使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。 css12345678910111213141516171819.wrap&#123; height:300px; background:#ccc; vertical-align:middle; /* td 标签默认情况下就默认设置了 vertical-align 为 middle，可以不需要显式地设置 */&#125;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"wrap\"&gt; &lt;div&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 方法2： 设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性。但这种方法兼容性比较差， IE6、7 并不支持这个样式。 12345678910111213.wrap&#123; height:300px; background:#ccc; display:table-cell;/*IE8以上及Chrome、Firefox*/ vertical-align:middle;/*IE8以上及Chrome、Firefox*/&#125;&lt;div class=\"wrap\"&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt;&lt;/div&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/"},{"name":"css","slug":"技术/前端基础知识/css","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/css/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.kaige1220.top/tags/CSS/"},{"name":"居中","slug":"居中","permalink":"https://www.kaige1220.top/tags/居中/"}]},{"title":"CSS3","slug":"CSS3","date":"2018-06-23T09:31:49.479Z","updated":"2018-06-19T02:54:14.788Z","comments":true,"path":"2018/06/23/CSS3/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/CSS3/","excerpt":"引入方式：1、内联方式 Inline Styles 这一行的字体颜色将显示为红色 2、内部样式块对象 Embedding a Style Block 12345&lt;style&gt; .test2 &#123; color: #000; &#125;&lt;/style&gt;","text":"引入方式：1、内联方式 Inline Styles 这一行的字体颜色将显示为红色 2、内部样式块对象 Embedding a Style Block 12345&lt;style&gt; .test2 &#123; color: #000; &#125;&lt;/style&gt; 3、外部样式表 Linking to a Style Sheet 你可以先建立外部样式表文件*.css，然后使用 HTML 的 link 对象。或者使用 @import 来引入。 示例代码： 1234567&lt;!-- Use link elements --&gt;&lt;link rel=\"stylesheet\" href=\"core.css\"&gt;&lt;!-- Use @imports --&gt;&lt;style&gt; @import url(\"more.css\");&lt;/style&gt; 二、选择器权重权重主要分为 4 个等级： 第一等：代表内联样式，如: style=””，权值为1000 第二等：代表ID选择器，如：#content，权值为100 第三等：代表类，伪类和属性选择器，如.content，权值为10 第四等：代表类型选择器和伪元素选择器，如div p，权值为1 动画CSS3 @keyframes 规则要创建CSS3动画，你将不得不了解@keyframes规则。@keyframes规则是用来创建动画。 @keyframes规则内指定一个 CSS样式和动画将逐步从目前的样式更改为新的样式。 CSS3 动画当在@keyframe创建动画，把它绑定到一个选择器，否则动画不会有任何效果。指定至少这两个 CSS3 的动画属性绑定向一个选择器： 规定动画的名称 规定动画的时长 例子： 12345#animated_div &#123; animation: animated_div 5s infinite; -moz-animation: animated_div 5s infinite; -webkit-animation: animated_div 5s infinite;&#125; 常用属性 第一部分：CSS Transition在CSS 3引入Transition（过渡）这个概念之前，CSS是没有时间轴的。也就是说，所有的状态变化，都是即时完成。 123456789img&#123; height:15px; width:15px;&#125;img:hover&#123; height: 450px; width: 450px;&#125; transition的作用在于，指定状态变化所需要的时间。 123img&#123; transition: 1s;&#125; 我们还可以指定transition适用的属性，比如只适用于height。 123img&#123; transition: 1s height;&#125; transition-delay在同一行transition语句中，可以分别指定多个属性。 123img&#123; transition: 1s height, 1s width;&#125; 我们希望，让height先发生变化，等结束以后，再让width发生变化。实现这一点很容易，就是为width指定一个delay参数。123img&#123; transition: 1s height, 1s 1s width;&#125; transition-timing-functionransition的状态变化速度（又称timing function），默认不是匀速的，而是逐渐放慢，这叫做ease。 除了ease以外，其他模式还包括: （1）linear：匀速 （2）ease-in：加速 （3）ease-out：减速 （4）cubic-bezier函数：自定义速度模式 transition的各项属性:transition的完整写法如下 123img&#123; transition: 1s 1s height ease;&#125; transition的局限transition的优点在于简单易用，但是它有几个很大的局限。 （1）transition需要事件触发，所以没法在网页加载时自动发生。 （2）transition是一次性的，不能重复发生，除非一再触发。 （3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 （4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 CSS Animation就是为了解决这些问题而提出的。 第二部分：CSS Animation首先，CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。123div:hover &#123; animation: 1s rainbow;&#125; 上面代码表示，当鼠标悬停在div元素上时，会产生名为rainbow的动画效果，持续时间为1秒。为此，我们还需要用keyframes关键字，定义rainbow效果。 12345@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 默认情况下，动画只播放一次。加入infinite关键字，可以让动画无限次播放。 123div:hover &#123; animation: 1s rainbow infinite;&#125; 也可以指定动画具体播放的次数，比如3次。 123div:hover &#123; animation: 1s rainbow 3;&#125; animation-fill-mode动画结束以后，会立即从结束状态跳回到起始状态。如果想让动画保持在结束状态，需要使用animation-fill-mode属性。123div:hover &#123; animation: 1s rainbow forwards;&#125; forwards表示让动画停留在结束状态，效果如下。 animation-fill-mode还可以使用下列值: （1）none：默认值，回到动画没开始时的状态。 （2）backwards：让动画回到第一帧的状态。 （3）both: 根据animation-direction（见后）轮流应用forwards和backwards规则。 animation-direction动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变这种行为。 下面看一个例子，来说明如何使用animation-direction。假定有一个动画是这样定义的。 1234@keyframes rainbow &#123; 0% &#123; background-color: yellow; &#125; 100% &#123; background: blue; &#125;&#125; 默认情况是，animation-direction等于normal。此外，还可以等于取alternate、reverse、alternate-reverse等值。它们的含义见下图（假定动画连续播放三次）。简单说，animation-direction指定了动画播放的方向，最常用的值是normal和reverse。浏览器对其他值的支持情况不佳，应该慎用。 animation的各项属性同transition一样，animation也是一个简写形式。 123div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125; 下面来介绍下边框：CSS3 Border（边框）主要有以下属性： border-radius box-shadow border-image border-radius （圆角边框） 1border-radius: 25px; box-shadow （边框阴影）1box-shadow: 15px 15px 5px #888245; border-image （边框图片） 1234-moz-border-image: url(/images/border.png) 30 30 round; /* Firefox */ -webkit-border-image: url(/images/border.png) 30 30 round; /* Safari and Chrome */ -o-border-image: url(/images/border.png) 30 30 round; /* Opera */ border-image: url(/images/border.png) 30 30 round; 接下来是背景知识：主要是2个背景属性： background-size background-origin background-size 该属性规定背景图片的尺寸。在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以规定背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。您能够以像素或百分比规定尺寸。如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。 background-origin 该属性指定了背景图像的位置区域。content-box, padding-box,和 border-box 区域内可以放置背景图像。 字体以前 CSS3 的版本，网页设计师不得不使用用户计算机上已经安装的字体。使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。您所选择的字体在新的 CSS3 版本有关于@font-face规则描述。您”自己的”的字体是在 CSS3 @font-face 规则中定义的。 在 @font-face 规则中，您必须首先定义字体的名称（比如 FontAwesome ），然后指向该字体文件 fontawesome-webfont.woff 。 1234@font-face &#123; font-family: 'FontAwesome'; src: url('fonts/fontawesome-webfont.woff');&#125; 文本效果SS3 文本效果是这样一个术语用来在正常的文本中实现一些额外的特性。主要是两个属性的 CSS3 文本效果,如下: text-shadow word-wrap text-shadow 文本阴影。 您指定了水平阴影，垂直阴影，模糊的距离，以及阴影的颜色：123.text-shadow &#123; text-shadow: 10px 10px 10px #6AAFCF;&#125; word-wrap换行。 CSS3中，自动换行属性允许您强制文本换行 - 即使这意味着分裂它中间的一个字： 12345.word-wrap &#123; word-wrap: break-word; width: 150px; border: 1px solid #ff0000;&#125; 2D 转换CSS3 2D转换，我们可以斜拉(skew)，缩放(scale)，旋转(rotate)以及位移(translate)元素。 常用 2D 变换方法： translate() rotate() scale() skew() matrix() translate()translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动 rotate()rotate()方法，在一个给定度数沿着元素中心顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。 123456.rotate&#123; transform:rotate(30deg); -ms-transform:rotate(30deg); /* IE 9 */ -webkit-transform:rotate(30deg); /* Safari and Chrome */&#125; scale()scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数：123456.scale&#123; transform: scale(2,4); -ms-transform: scale(2,4); /* IE 9 */ -webkit-transform: scale(2,4); /* Safari and Chrome */&#125; skew()skew()方法，该元素会根据横向（X轴）和垂直（Y轴）线参数给定角度：123456.skew&#123; transform:skew(30deg,20deg); -ms-transform:skew(30deg,20deg); /* IE 9 */ -webkit-transform:skew(30deg,20deg); /* Safari and Chrome */&#125; matrix()matrix()方法和2D变换方法合并成一个。matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。 3D 转换CSS3 3D Transform,用于 3 维动画或旋转。CSS3 3D 转换是一个属性,用于改变元素的实际形式。这个特性可以改变元素的形状、大小和位置。主要有下列方法： rotateX() rotateY() rotateZ() 注意：Internet Explorer 10 和 Firefox 支持 3D 转换； Chrome 和 Safari 必须添加前缀 -webkit-； Opera 还不支持 3D 转换(支持 2D 转换 ) rotateX()rotateX()方法，围绕其在一个给定度数X轴旋转的元素。1234.rotate-x &#123; transform: rotateX(60deg); -webkit-transform: rotateX(120deg); /* Safari and Chrome */&#125; y、z轴 类似。 rotate3d()otate3d(x,y,z,a)中取值说明： x：是一个0到１之间的数值，主要用来描述元素围绕X轴旋转的矢量值； y：是一个０到１之间的数值，主要用来描述元素围绕Y轴旋转的矢量值； z：是一个０到１之间的数值，主要用来描述元素围绕Z轴旋转的矢量值； a：是一个角度值，主要用来指定元素在3D空间旋转的角度，如果其值为正值，元素顺时针旋转，反之元素逆时针旋转。 面介绍的三个旋转函数功能等同： &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/"},{"name":"css3","slug":"技术/前端基础知识/css3","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/css3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://www.kaige1220.top/tags/CSS3/"}]},{"title":"Chrome DevTools 技巧","slug":"Chrome DevTools技巧2","date":"2018-06-23T09:31:49.435Z","updated":"2018-06-21T02:00:14.982Z","comments":true,"path":"2018/06/23/Chrome DevTools技巧2/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/Chrome DevTools技巧2/","excerpt":"","text":"1、调试窗口切换： mac： command+alt+i win: F12 2、页面元素调试 保持住 hover 的状态，右键可以看到 hover: 单击选中即可。 3、元素状态改变的监控方法 右键 4、样式调试 盒模型调试 5、查看元素最终样式 选 computed 6、元素事件监听查看 event Listeners 7、console 8、如何查看被压缩 js css 的源码 点下面的{} format 9、查看整站加载的资源 sources 10、调试 JavaScript 的 call stack 堆栈 11、编辑源文件同步到本地文件里 source—-filesystem—+ ——添加本地文件 12、网络请求监控 network 13、监控页面重绘的方法 More tools—-Rendering—-paint flashing 14、如何监控并统计没有使用的脚本 More tools—-coverage —点小黑点变红 15、如何监控页面的动画变更 More tools—-Animation 16、网络条件与 user-Agent 的设置 More tools—-Network condition 17、快速以编辑状态查看一个站点加载的所有资源 scource—-ctr+p 18、调试 Android 设备的方法 More tools—Remote devices 19、如何让浏览器阻止请求某些资源 More tools–Request blocking 用正则的方法css 去掉包含css的文件 ad 去掉广告 20、如何对站点下所有的资源进行全部搜索 More tools–Search 21、如何在浏览器中模拟一些传感器数据 22、性能分析 Performance CPU设置 recoding 帧率fps 一秒改变多少 页面加载的过程中那部分比较卡 Call Tree 跳到源码里看看哪里比较耗时。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"Chrome DevTools","slug":"技术/Chrome-DevTools","permalink":"https://www.kaige1220.top/categories/技术/Chrome-DevTools/"}],"tags":[{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"https://www.kaige1220.top/tags/Chrome-DevTools/"}]},{"title":"Chrome DevTools 技巧","slug":"Chrome DevTools技巧","date":"2018-06-23T09:31:49.384Z","updated":"2018-06-12T12:21:09.152Z","comments":true,"path":"2018/06/23/Chrome DevTools技巧/","link":"","permalink":"https://www.kaige1220.top/2018/06/23/Chrome DevTools技巧/","excerpt":"1、拖拽面板中的元素","text":"1、拖拽面板中的元素 2、在控制台控制选中的元素 3、添加CSS并编辑元素的状态在元素面板有两个很好用的按钮add css: 4、找到css属性被定义在什么位置ctrl-click on Windows ctrl 键点击属性，可以定位","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"Chrome DevTools","slug":"技术/Chrome-DevTools","permalink":"https://www.kaige1220.top/categories/技术/Chrome-DevTools/"}],"tags":[{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"https://www.kaige1220.top/tags/Chrome-DevTools/"}]},{"title":"CSS 媒体查询","slug":"前端基础知识整理6","date":"2018-06-11T13:08:25.000Z","updated":"2018-06-12T12:22:09.690Z","comments":true,"path":"2018/06/11/前端基础知识整理6/","link":"","permalink":"https://www.kaige1220.top/2018/06/11/前端基础知识整理6/","excerpt":"&ensp; &ensp;所谓的媒体查询就是指，不同的条件使用不同的样式或样式集合。 @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式","text":"&ensp; &ensp;所谓的媒体查询就是指，不同的条件使用不同的样式或样式集合。 @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式 一、CSS 语法 device-width 和 width的区别： device-width表示的是设备的宽度，即屏幕的宽度。width所代表的是文档宽度，与屏幕大小没有关系，如果是在移动设备上，width表示的是布局视口的宽度。 必要的空格。 12//空格是有必要的，在某些情况下该样式永远不起作用。&lt;link rel=\"stylesheet\" media=\"(min-device-width:400px)【空格】and【空格】(max-device-width:900px)\" href=\"css/style1.css\"&gt; 语法示例： 12345678910&lt;!-- link元素中的CSS媒体查询 --&gt;&lt;link rel=\"stylesheet\" media=\"(max-width: 800px)\" href=\"example.css\" /&gt; //对什么状况下使用&lt;!-- 样式表中的CSS媒体查询 --&gt;&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 二、可供媒体查询检测的特性 width:视口宽度 height:视口高度 device-width:设备屏幕的宽度 device-height:设备屏幕的高度 orientation:检测设备处于横向还是纵向 aspect-radio:基于视口宽度和高度的宽高比 device-sapect-radio:基于设备渲染平面宽度和高度的宽高比 color:每种颜色的位数 color-index:设备的颜色索引表中的颜色数 monochrome:检测单色帧缓冲区中每像素所使用的位数 resolution:用来检测屏幕或打印机的分辨率， scan:电视机的烧苗方式，值可设为progressive(逐行扫描)或interlace(隔行扫描) 用来检测输出设备是网格设备还是位图设备 三、逻辑操作 and，且的关系，当所有的条件满足的时候返回true12345678//一个基本的媒体查询，即一个媒体属性和默认指定的all媒体类型@media (min-width:700px)&#123;&#125;//如果你只想再横屏时候应用,你可以使用and操作符合并媒体属性(min-width:700px)and(orientation:landscape)&#123;&#125;//如果你仅想在电视媒体上应用@media tv and (min-width:700px) and (orientation:landscape)&#123;&#125; 逗号分割列表，或的关系，只要有条件满足就返回ture not，类似于取反，最后参与运算的运算符 only，only关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/"},{"name":"媒体查询","slug":"技术/前端基础知识/媒体查询","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/媒体查询/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.kaige1220.top/tags/CSS/"},{"name":"媒体查询","slug":"媒体查询","permalink":"https://www.kaige1220.top/tags/媒体查询/"}]},{"title":"CSS 弹性盒子Flexbox","slug":"前端基础知识整理5","date":"2018-06-11T13:08:25.000Z","updated":"2018-06-12T07:11:23.380Z","comments":true,"path":"2018/06/11/前端基础知识整理5/","link":"","permalink":"https://www.kaige1220.top/2018/06/11/前端基础知识整理5/","excerpt":"&ensp; &ensp;布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 一、Flex 布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。","text":"&ensp; &ensp;布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 一、Flex 布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 ####二、基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 ####三、容器的属性 以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.flex-direction flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端 flex-flow column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 2.flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 4.justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5.align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6.align-content属性123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1.order属性123.item &#123; order: &lt;integer&gt;;&#125; 4.2.flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.kaige1220.top/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/"},{"name":"Flexbox","slug":"技术/前端基础知识/Flexbox","permalink":"https://www.kaige1220.top/categories/技术/前端基础知识/Flexbox/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.kaige1220.top/tags/CSS/"},{"name":"Flexbox","slug":"Flexbox","permalink":"https://www.kaige1220.top/tags/Flexbox/"}]}]}