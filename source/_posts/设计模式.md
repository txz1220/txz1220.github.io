---
title: JavaScript设计模式
categories:
- 技术
- JavaScript设计模式
tags:
- JS
- JavaScript设计模式
---

### 构造函数模式

```js
/**
 * 构造一个动物的函数
 */
function Animal(name, color) {
  this.name = name;
  this.color = color;
  this.getName = function() {
    return this.name;
  };
}
// 实例一个对象
var cat = new Animal('猫', '白色');
console.log(cat.getName());
```
<!--more-->
### 工厂模式

工厂模式的定义：提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象）。
创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。
创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。
工厂就是把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合(也就是相互影响)

```js
/**
 * 工厂模式
 */
function Animal(opts) {
  var obj = new Object();
  obj.name = opts.name;
  obj.color = opts.color;
  obj.getInfo = function() {
    return '名称：' + obj.name + '， 颜色：' + obj.color;
  };
  return obj;
}
var cat = Animal({ name: '波斯猫', color: '白色' });
cat.getInfo();
```

### 模块模式

```js
/**
 * 模块模式 = 封装大部分代码，只暴露必需接口
 */
var Car = (function() {
  var name = '法拉利';
  function sayName() {
    console.log(name);
  }
  function getColor(name) {
    console.log(name);
  }
  return {
    name: sayName,
    color: getColor,
  };
})();
Car.name();
Car.color('红色');
```

### 混合模式

```js
/**
 * 混合模式 = 原型模式 + 构造函数模式
 */
function Animal(name, color) {
  this.name = name;
  this.color = color;

  console.log(this.name + this.color);
}
Animal.prototype.getInfo = function() {
  console.log('名称：' + this.name);
};

function largeCat(name, color) {
  Animal.call(null, name, color);

  this.color = color;
}

largeCat.prototype = create(Animal.prototype);
function create(parentObj) {
  function F() {}
  F.prototype = parentObj;
  return new F();
}

largeCat.prototype.getColor = function() {
  return this.color;
};
var cat = new largeCat('Persian', '白色');
console.log(cat);
```

### 单例模式

单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点。也可以说单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。

```js
/**
 * 在执行当前 Single 只获得唯一一个对象
 */
var Single = (function() {
  var instance;
  function init() {
    //define private methods and properties
    //do something
    return {
      //define public methods and properties
    };
  }

  return {
    // 获取实例
    getInstance: function() {
      if (!instance) {
        instance = init();
      }
      return instance;
    },
  };
})();

var obj1 = Single.getInstance();
var obj2 = Single.getInstance();

console.log(obj1 === obj2);
```

### 发布订阅模式

定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。
它需要一种高级的抽象策略，以便订阅者能够彼此独立地发生改变，而发行方能够接受任何有消费意向的订阅者。

发布订阅模式的流程如下：

   1. 确定谁是发布者(比如我的博客)。

   2. 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者。

   3. 发布消息，发布者需要遍历这个缓存列表，依次触发里面存放的订阅者回调函数。

   4. 退订（比如不想再接收到这些订阅的信息了，就可以取消掉）

```js
/**
 * 发布订阅模式
 */
var EventCenter = (function() {
  var events = {};
  /*
    {
      my_event: [{handler: function(data){xxx}}, {handler: function(data){yyy}}]
    }
    */
  // 绑定事件 添加回调
  function on(evt, handler) {
    events[evt] = events[evt] || [];
    events[evt].push({
      handler: handler,
    });
  }
  function fire(evt, arg) {
    if (!events[evt]) {
      return;
    }
    for (var i = 0; i < events[evt].length; i++) {
      events[evt][i].handler(arg);
    }
  }
  function off(evt) {
    delete events[evt];
  }
  return {
    on: on,
    fire: fire,
    off: off,
  };
})();

var number = 1;
EventCenter.on('click', function(data) {
  console.log('click 事件' + data + number++ + '次');
});
EventCenter.off('click'); //  只绑定一次
EventCenter.on('click', function(data) {
  console.log('click 事件' + data + number++ + '次');
});

EventCenter.fire('click', '绑定');
```
