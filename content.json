{"meta":{"title":"KAIGE","subtitle":null,"description":null,"author":"KAIGE","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"React-Router","slug":"React.Router","date":"2018-06-24T03:45:45.140Z","updated":"2018-06-24T03:51:06.549Z","comments":true,"path":"2018/06/24/React.Router/","link":"","permalink":"http://yoursite.com/2018/06/24/React.Router/","excerpt":"","text":"首先是安装Router：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Router","slug":"技术/Router","permalink":"http://yoursite.com/categories/技术/Router/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"Router","slug":"Router","permalink":"http://yoursite.com/tags/Router/"}]},{"title":"React-样式","slug":"React样式","date":"2018-06-24T02:20:32.413Z","updated":"2018-06-24T03:46:25.545Z","comments":true,"path":"2018/06/24/React样式/","link":"","permalink":"http://yoursite.com/2018/06/24/React样式/","excerpt":"1、内联样式：1.1内部书写：a、首先在render里面定义变量：变量的形式： 12345678const styleComponentHeader = &#123; header: &#123; backgroundColor: '#333333', color: '#FFFFFF', 'padding-top': '15px', paddingBottom: '15px', &#125;,&#125;;","text":"1、内联样式：1.1内部书写：a、首先在render里面定义变量：变量的形式： 12345678const styleComponentHeader = &#123; header: &#123; backgroundColor: '#333333', color: '#FFFFFF', 'padding-top': '15px', paddingBottom: '15px', &#125;,&#125;; 注意上面的命名规范： 驼峰命名 paddingBottom: ‘15px’ 引号写法 ‘padding-top’: ‘15px’ 另外是属性值用引号括起来 b、然后在元素上进行引用：style={styleComponentHeader.header} 1.2 外部引用：在外部引用css文件： 在index.html里面全局应用：和正常的引用一样。 注意 class 需要更改成 className 上面两种方法的缺点： 动画、伪类 (hover) 等不能使用 1.3 内联样式的表达式首先在元素上绑定一个点击事件：onClick={this.switchHeader.bind(this)} 绑定一个函数 switchHeader 这个函数在render外面来定义： 12345678910111213//先初始化constrcutor()&#123; super(); this.state = &#123; miniHeader: false &#125;&#125;switchHeader()&#123; this.setState(&#123; miniHeader: !this.state.miniHeader; &#125;)&#125; 那我们怎么定义miniHeader的样式状态呢：可以吧他绑在我们刚才定义的样式里面 paddingBottom: (this.state.miniHeader) ? “3px” : “15px” 这里用到了三元表达式的写法 2、CSS模块化：首先安装三个模块，在配置文件先定义好，然后用npm安装即可。 这个三个模块分别是： babel-plugin-react-html-attrs 解决在react写类class不必非得用calssName style-loader css-loader 下面是配置webpack.config.js 具体配置可以看看相关的文档或者看我之前写的webpack教程。 下面是把你写的css文件导入到你制定的js文件页， 比如你写好了footer.css的样式文件，你可以把他引入到footer.js页面 引入方式： var footerCss = require(“../../css/footer.css”); 在footer.js使用它： 在你的元素上加上 这是footer页面 这里footerCSS是我们上面定义的 miniFooter是我们在footer.css里面写的。 2、jsx样式和css样式互转：css to react 在线转换","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"样式","slug":"技术/样式","permalink":"http://yoursite.com/categories/技术/样式/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"样式","slug":"样式","permalink":"http://yoursite.com/tags/样式/"}]},{"title":"React-组件的Refs","slug":"React组件的refs","date":"2018-06-23T14:20:39.474Z","updated":"2018-06-23T14:34:34.342Z","comments":true,"path":"2018/06/23/React组件的refs/","link":"","permalink":"http://yoursite.com/2018/06/23/React组件的refs/","excerpt":"","text":"操作DOM两种方法： 1、JS的原生写法： var myDiv =document.getElementById(‘myDiv’); ReactDOM.findDOMNode(myDiv).style.color =’green’; // 这里用到了ReactDOM 在头部先引入 import ReactDOM from ‘react-dom’ 2、在元素上定义ref=”submitButton” 然后直接可以调用了： this.refs.submitButton.style.color=”red”; Refs 是访问到组件内部 DOM 节点唯一可靠的方法 Refs 会自动销毁对子组件的引用 不要在 render 或 render 之前对 Refs 进行调用 //在事件内调用 或者render后面调用。 不要滥用 Refs","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"组件的Refs","slug":"技术/组件的Refs","permalink":"http://yoursite.com/categories/技术/组件的Refs/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"组件的Refs","slug":"组件的Refs","permalink":"http://yoursite.com/tags/组件的Refs/"}]},{"title":"React-可复用组件","slug":"React可复用组件","date":"2018-06-23T13:36:37.057Z","updated":"2018-06-23T14:37:23.624Z","comments":true,"path":"2018/06/23/React可复用组件/","link":"","permalink":"http://yoursite.com/2018/06/23/React可复用组件/","excerpt":"","text":"Prop 验证比如我们需要传入的是一种数字数据，我们可以用着用方法：123BodyIndex.propTypes = &#123; userid: React.PropTypes.number.isRequired&#125;; 其中我们看到用到了react里面的PropTypes 这个属性 后面跟了isRequired (这个数据类型是必须的) 默认 Prop 值const defaultProps = { text:’Hello World’ }; 使用方法：BodyIndex.defaultProps = defaultProps; 传递所有参数的快捷方式子页面代码： Component：代表的是子页面的子页面即孙页面的组件名。 {…this.props} 这个是我们从父页面传递过来的， 后面的more=”values” 就是我们新加的属性 然后在孙页面输出 {this.props.userid} {this.props.username} {this.props.id}","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"可复用组件","slug":"技术/可复用组件","permalink":"http://yoursite.com/categories/技术/可复用组件/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"可复用组件","slug":"可复用组件","permalink":"http://yoursite.com/tags/可复用组件/"}]},{"title":"git学习","slug":"Gitlearn1","date":"2018-06-23T12:41:05.514Z","updated":"2018-06-23T12:41:05.516Z","comments":true,"path":"2018/06/23/Gitlearn1/","link":"","permalink":"http://yoursite.com/2018/06/23/Gitlearn1/","excerpt":"1.初始化一个Git仓库，使用git init命令。 2.添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 3.要随时掌握工作区的状态，使用git status命令。 4.如果git status告诉你有文件被修改过，用git diff可以查看修改内容。","text":"1.初始化一个Git仓库，使用git init命令。 2.添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 3.要随时掌握工作区的状态，使用git status命令。 4.如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 5.版本回退： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hardcommit_id 或者用 –hard HEAD^ 这种形式回到上一个版本 上上个版本用 –hard HEAD^^ 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 6.工作区和暂存区 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 6.撤销修改命令 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 加入你已经add 了，但是还没有commit 你可以用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区： git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 接下来就是用git checkout – readme.txt 撤回工作区的修改了。 7.删除命令 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout – test.txtgit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程仓库首先在github 上建立我们的远程仓库，然后执行命令git remote add origin git@github.com:用户名/learngit.git 建立本地和远程的链接， 下面注意： 如果你的远程仓库里面含有README.md 而你本地的仓库没有这个文件，你需要执行git pull –rebase origin master 先合并， 然后再执行推送本地的内容，git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 远程仓库进行克隆：git clone git@github.com:你的用户名字/gitskills.git 再本地那个文件执行就会放在哪个文件下。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 下面看看具体是怎么做的呢首先，我们创建dev分支，然后切换到dev分支：12$ git checkout -b devSwitched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：123$ git branch dev$ git checkout devSwitched to branch &apos;dev&apos; 查看所处的分支： 123$ git branch* dev master 切换回master分支： 1$ git checkout master 合并分支： 1git merge dev git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： 1$ git branch -d dev 总结： Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Git学习","slug":"技术/Git学习","permalink":"http://yoursite.com/categories/技术/Git学习/"}],"tags":[{"name":"Git学习","slug":"Git学习","permalink":"http://yoursite.com/tags/Git学习/"}]},{"title":"JavaScript-高级函数","slug":"高阶函数","date":"2018-06-23T09:31:50.208Z","updated":"2018-06-12T13:15:03.173Z","comments":true,"path":"2018/06/23/高阶函数/","link":"","permalink":"http://yoursite.com/2018/06/23/高阶函数/","excerpt":"一、什么是JavaScript的高级函数通俗一点讲就是：函数作为参数的行为 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 123function add(x, y, f) &#123; return f(x) + f(y);&#125; 当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为： x = -5;y = 6;f = Math.abs;f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;return 11;","text":"一、什么是JavaScript的高级函数通俗一点讲就是：函数作为参数的行为 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 123function add(x, y, f) &#123; return f(x) + f(y);&#125; 当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为： x = -5;y = 6;f = Math.abs;f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;return 11; map举例说明，比如我们有一个函数$$ f(x)=x^2 $$要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下： 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果： 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results); map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串： 12var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)比方说对一个Array求和，就可以用reduce实现：1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25 filter filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] 把一个Array中的空字符串删掉，可以这么写： 12345var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);r; // ['A', 'B', 'C'] 可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。 注：trim()方法返回调用字符串对象的一个副本,但是所有起始和结尾的空格都被删除了 利用filter，可以巧妙地去除Array的重复元素： 123456789'use strict';var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;);console.log(r.toString()); // 把数组转化为字符串； sort:排序算法: 排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。 JavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊： 看上去正常的结果:1[&apos;Google&apos;, &apos;Apple&apos;, &apos;Microsoft&apos;].sort(); // [&apos;Apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;]; apple排在了最后:1[&apos;Google&apos;, &apos;apple&apos;, &apos;Microsoft&apos;].sort(); // [&apos;Google&apos;, &apos;Microsoft&quot;, &apos;apple&apos;] 无法理解的结果:1[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。 第三个排序结果是什么鬼？简单的数字排序都能错？ 这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果’10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小。 幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 要按数字大小排序，我们可以这么写： 12345678910111213'use strict';var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20] 如果要倒序排序，我们可以把大的数放前面： 12345678910var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return 1; &#125; if (x &gt; y) &#123; return -1; &#125; return 0;&#125;); // [20, 10, 2, 1] 默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：123456789101112var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) &#123; x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) &#123; return -1; &#125; if (x1 &gt; x2) &#123; return 1; &#125; return 0;&#125;); // ['apple', 'Google', 'Microsoft'] &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"高级函数","slug":"技术/JavaScript/高级函数","permalink":"http://yoursite.com/categories/技术/JavaScript/高级函数/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}]},{"title":"闭包","slug":"闭包","date":"2018-06-23T09:31:50.193Z","updated":"2018-06-19T02:54:00.058Z","comments":true,"path":"2018/06/23/闭包/","link":"","permalink":"http://yoursite.com/2018/06/23/闭包/","excerpt":"核心理解就两点： 1、函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 2、把私有变量封装起来，类似于java里面class的私有变量。由于JavaScript里面没有私有变量定义，所以采用闭包来封装起来。","text":"核心理解就两点： 1、函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 2、把私有变量封装起来，类似于java里面class的私有变量。由于JavaScript里面没有私有变量定义，所以采用闭包来封装起来。 我们来实现一个对Array的求和。通常情况下，求和的函数是这样定义的：1234567function sum(arr) &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;);&#125;sum([1, 2, 3, 4, 5]); // 15 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！12345678function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125; 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数： var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()调用函数f时，才真正计算求和的结果： f(); // 15 在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。 请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数： var f1 = lazy_sum([1, 2, 3, 4, 5]);var f2 = lazy_sum([1, 2, 3, 4, 5]);f1 === f2; // falsef1()和f2()的调用结果互不影响。 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 1234567891011121314151617181920function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123(function (x) &#123; return x * x;&#125;)(3); // 9 理论上讲，创建一个匿名函数并立刻执行可以这么写： function (x) { return x * x } (3); 但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来： (function (x) { return x * x }) (3); 通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写： (function (x) { return x * x;})(3); 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。 我们用JavaScript创建一个计数器： 1234567891011'use strict';function create_counter(initial) &#123; var x = initial || 0; return &#123; inc: function () &#123; x += 1; return x; &#125; &#125;&#125; 它用起来像这样： 123456789var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13 在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 闭包还可以把多参数的函数变成单参数的函数。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"闭包","slug":"技术/闭包","permalink":"http://yoursite.com/categories/技术/闭包/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2018-06-23T09:31:50.181Z","updated":"2018-06-20T00:06:57.950Z","comments":true,"path":"2018/06/23/箭头函数/","link":"","permalink":"http://yoursite.com/2018/06/23/箭头函数/","excerpt":"x =&gt; x * x 上面的箭头函数相当于： 123function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125;","text":"x =&gt; x * x 上面的箭头函数相当于： 123function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 如果参数不是一个，就需要用括号()括起来：(x, y) =&gt; x x + y y 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： 因为和函数体的{ … }有语法冲突，所以要改为： x =&gt; ({ foo: x }) 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域 12345678910var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window或undefined &#125;; return fn(); &#125;&#125;; 现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：123456789var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25 如果使用箭头函数，以前的那种hack写法： var that = this;就不再需要了。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"箭头函数","slug":"技术/箭头函数","permalink":"http://yoursite.com/categories/技术/箭头函数/"}],"tags":[{"name":"箭头函数","slug":"箭头函数","permalink":"http://yoursite.com/tags/箭头函数/"}]},{"title":"深入理解JS函数","slug":"深入理解JS函数","date":"2018-06-23T09:31:50.174Z","updated":"2018-06-22T09:39:55.582Z","comments":true,"path":"2018/06/23/深入理解JS函数/","link":"","permalink":"http://yoursite.com/2018/06/23/深入理解JS函数/","excerpt":"一、函数的三种角色 首先要先了解在函数本身会有一些自己的属性，比如： length：形参的个数； name：函数名； prototype：类的原型，在原型上定义的方法都是当前这个类的实例的公有方法； __proto__：把函数当做一个普通对象，指向Function这个类的原型","text":"一、函数的三种角色 首先要先了解在函数本身会有一些自己的属性，比如： length：形参的个数； name：函数名； prototype：类的原型，在原型上定义的方法都是当前这个类的实例的公有方法； __proto__：把函数当做一个普通对象，指向Function这个类的原型 函数在整个JavaScript中是最复杂也是最重要的知识，对于一个函数来说，会存在多种角色： 1234567891011121314function Fn() &#123; var num = 500; this.x = 100;&#125;Fn.prototype.getX = function () &#123; console.log(this.x);&#125;Fn.aaa = 1000;var f = new Fn;f.num // undefinedf.aaa // undefinedvar res = Fn(); // res是undefined Fn中的this是window 角色一：普通函数，对于Fn而言，它本身是一个普通的函数，执行的时候会形成私有的作用域，然后进行形参赋值、预解析、代码执行、执行完成后内存销毁； 角色二：类，它有自己的实例，f就是Fn作为类而产生的一个实例，也有一个叫做prototype的属性是自己的原型，它的实例都可以指向自己的原型； 角色三：普通对象，Fn和 var obj = {} 中的obj一样，就是一个普通的对象（所有的函数都是Function的实例），它作为对象可以有一些自己的私有属性，也可以通过proto找到Function.prototype； 二、call深入12var ary = [12, 23, 34];ary.slice(); 以上两行简单的代码的执行过程为：ary这个实例通过原型链的查找机制找到Array.prototype上的slice方法，让找到的slice方法执行，在执行slice方法的过程中才把ary数组进行了截取。 slice方法执行之前有一个在原型上查找的过程（当前实例中没有找到，再根据原型链查找）。 当知道了一个对象调用方法会有一个查找过程之后，我们再看： 12345678var obj = &#123;name:'iceman'&#125;;function fn() &#123; console.log(this); console.log(this.name);&#125;fn(); // this --&gt; window// obj.fn(); // Uncaught TypeError: obj.fn is not a functionfn.call(obj); call方法的作用：首先寻找call方法，最后通过原型链在Function的原型中找到call方法，然后让call方法执行，在执行call方法的时候，让fn方法中的this变为第一个参数值obj，最后再把fn这个函数执行。 2.2、call方法原理123456 function fn1() &#123; console.log(1);&#125;function fn2() &#123; console.log(2);&#125; 输出 fn1.call(fn2); // 1 首先fn1通过原型链查找机制找到Function.prototype上的call方法，并且让call方法执行，此时call这个方法中的this就是要操作的fn1。在call方法代码执行的过程过程中，首先让fn1中的“this关键字”变为fn2，然后再让fn1这个方法执行。 注意：在执行call方法的时候，fn1中的this的确会变为fn2，但是在fn1的方法体中输出的内容中并没有涉及到任何和this相关的内容，所以还是输出1。 apply方法、bind方法和call方法apply方法和call方法的作用是一模一样的，都是用来改变方法的this关键字，并且把方法执行，而且在严格模式下和非严格模式下，对于第一个参数是null/undefined这种情况规律也是一样的，只是传递函数的的参数的时候有区别。123456function fn(num1, num2) &#123; console.log(num1 + num2); console.log(this);&#125;fn.call(obj , 100 , 200);fn.apply(obj , [100, 200]); bind方法和apply、call稍有不同，bind方法是事先把fn的this改变为我们要想要的结果，并且把对应的参数值准备好，以后要用到了，直接的执行即可，也就是说bind同样可以改变this的指向，但和apply、call不同就是不会马上的执行。 12var tempFn = fn.bind(obj, 1, 2);tempFn(); 第一行代码只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，但是此时并没有把fn这个函数给执行，执行bind会有一个返回值，这个返回值tempFn就是把fn的this改变后的那个结果。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"深入理解JS函数","slug":"技术/深入理解JS函数","permalink":"http://yoursite.com/categories/技术/深入理解JS函数/"}],"tags":[{"name":"深入理解JS函数","slug":"深入理解JS函数","permalink":"http://yoursite.com/tags/深入理解JS函数/"}]},{"title":"JS方法","slug":"方法","date":"2018-06-23T09:31:50.164Z","updated":"2018-06-15T01:33:42.488Z","comments":true,"path":"2018/06/23/方法/","link":"","permalink":"http://yoursite.com/2018/06/23/方法/","excerpt":"在一个对象中绑定函数，称为这个对象的方法。 在JavaScript中，对象的定义是这样的： 1234var xiaoming = &#123; name: '小明', birth: 1990&#125;;","text":"在一个对象中绑定函数，称为这个对象的方法。 在JavaScript中，对象的定义是这样的： 1234var xiaoming = &#123; name: '小明', birth: 1990&#125;; 但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄： 1234567891011var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？ 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 12345678910111213141516'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"方法","slug":"技术/JavaScript/方法","permalink":"http://yoursite.com/categories/技术/JavaScript/方法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"方法","slug":"方法","permalink":"http://yoursite.com/tags/方法/"}]},{"title":"谷歌浏览器开发工具综述","slug":"开发者工具","date":"2018-06-23T09:31:50.157Z","updated":"2018-06-14T14:17:40.549Z","comments":true,"path":"2018/06/23/开发者工具/","link":"","permalink":"http://yoursite.com/2018/06/23/开发者工具/","excerpt":"总体而言，有八个主要的工具可供查看开发工具： 元素 资源 网络 源 时间表 简介 审核 控制台","text":"总体而言，有八个主要的工具可供查看开发工具： 元素 资源 网络 源 时间表 简介 审核 控制台 你可以使用 Ctrl + [ 和 Ctrl + ] 快捷键在面板之间移动。 查阅 DOM 和格式1、实时编辑 DOM 节点 要实时编辑 DOM 节点，只需双击选定元素，然后进行更改： 2、实时编辑样式 在 Styles 窗格中实时编辑样式属性名称和值。所有样式均可修改，除了灰色部分（与 User Agent 样式表一样）。 要编辑名称或值，请点击它，进行更改，然后按 Tab 或 Enter 保存更改。 3、检查和编辑框模型参数 利用控制台进行工作JavaScript 控制台为开发者提供了测试 Web 页面和应用程序两个主要功能,其中包括： 在开发过程中记录诊断信息。 一个可与文档和工具交互的 shell 提示符。 您可以使用控制台编程接口提供的方法来记录诊断信息。如 console.log() 或 console.profile()。 您可以直接在控制台中评估表达式，并使用命令行提供的方法。这些包括使用 $() 命令选择元素或通过 profile() 方法启动 CPU 分析器命令。 JavaScript 的调试1、断点调试代码行断点在 DevTools 中设置一行代码断点： 点击 Sources 选项卡。 打开包含您想要打破的代码行的文件。 去代码的行。 行号的左边是行号列。点击它。一个蓝色图标显示在行号列的顶部。 条件行代码断点当您知道需要调查的确切代码区域时，请使用有条件的代码行断点，但只有在其他条件成立时才想暂停。 要设置条件的代码行断点： 点击 Sources 选项卡。 打开包含您想要打破的代码行的文件。 去代码的行。 行号的左边是行号列。用鼠标右键单击它。 选择添加条件断点。代码行下面会显示一个对话框。 在对话框中输入你的条件。 按 Enter 激活断点。行号列上出现橙色图标。 DOM 更改断点当您想要更改 DOM 节点或其子节点的代码时，使用 DOM 更改断点。 要设置 DOM 更改断点： 点击元素标签。 转到您想设置断点的元素。 右键单击该元素。 将鼠标悬停在 Break 上，然后选择 Subtree 修改，属性修改或节点删除。 事件监听器断点当想要暂停事件侦听器代码时，使用事件侦听器断点。您可以选择特定的事件，例如事件 click 类别，例如所有的鼠标事件。 点击 Sources 选项卡。 展开“ 事件侦听器断点”窗格。DevTools 显示事件类别的列表，例如动画。 选中这些类别中的一个可以暂停该类别的任何事件，或者展开类别并检查特定事件。 异常断点当您想暂停引发捕获或未捕获异常的代码行时，使用异常断点。 点击 Sources 选项卡。 点击暂停例外 暂停例外。启用后变成蓝色。 （可选）如果除了未捕获的异常外，还想暂停捕获的异常，请选中“ 捕获异常时暂停”复选框。 测量资源加载时间使用 Network 面板测量您的网站网络性能。 Network 面板记录页面上每个网络操作的相关信息，包括详细的耗时数据、HTTP 请求与响应标头和 Cookie，等等。 待更新","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"开发者工具","slug":"技术/开发者工具","permalink":"http://yoursite.com/categories/技术/开发者工具/"}],"tags":[{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"}]},{"title":"如何优化你的网站","slug":"如何优化你的网站","date":"2018-06-23T09:31:50.131Z","updated":"2018-06-14T14:15:14.145Z","comments":true,"path":"2018/06/23/如何优化你的网站/","link":"","permalink":"http://yoursite.com/2018/06/23/如何优化你的网站/","excerpt":"1、利用浏览器缓存你的 js 和 CSS 文件： 在网站根目录 .htaccess 中加入以下代码 123 ExpiresActive on ExpiresDefault “access plus 1 year” 这段代码的意思是对 jpg|gif|png|css|js 发送 header 缓存头，进行一年的缓存、在浏览器不使用 ctrl+F5 强制刷新时，会一直缓存到时间时间结束，唯一遗憾的是如果你更改了js或者css文件必须把以前的路径或者文件名更改，可以这样 base.js?ver=(x) 这种方式下次浏览器就会自动读取并缓存。","text":"1、利用浏览器缓存你的 js 和 CSS 文件： 在网站根目录 .htaccess 中加入以下代码 123 ExpiresActive on ExpiresDefault “access plus 1 year” 这段代码的意思是对 jpg|gif|png|css|js 发送 header 缓存头，进行一年的缓存、在浏览器不使用 ctrl+F5 强制刷新时，会一直缓存到时间时间结束，唯一遗憾的是如果你更改了js或者css文件必须把以前的路径或者文件名更改，可以这样 base.js?ver=(x) 这种方式下次浏览器就会自动读取并缓存。 2、把你的 .js 库文件地址替换成 Google CDN的地址： 随着 jquery 和 mootools 等js库的使用需要加载的.js文件越来越多也越来越大，通常传统的网站是上传到网站本身的目录。但对于一个接近70多KB的jquery.js体积确实不利于网站响应速度的提升，此时就应该使用Google API 。 例如：把你的 http://www.***.cn/jquery.x.x.js 替换为 http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js，其意义在于当一个用户访问过使用 google api 的网站之后，再次访问其他调用了该api地址的网站就不需要再次加载该文件了。从而达到提速的目的。 不单是jquery库，其他诸如mootools yui 也可以使用这种方式。 3、精简和优化你的 js 和 CSS： 虽然有了缓存和gzip保驾护航，但是对于 js 和 css 的优化却也是必须的。我们写的javascript脚本和 css 代码都是经过缩进和换行的，适合人类阅读，但是浏览器执行这些脚本不并需要这些无意义的空格和换行。所以我们应该去除这一些空格换行，甚至缩短 javascript 和 css 里面的变量。诸如此类的优化工具有 YUI Compressor 和 Closure Compiler 。这两个工具都是基于 java 的，使用应该安装jdk并且设置 JAVA_HOME 。(对于非程序员的网站管理员而言确实有点困难) 此工具可以不用在本地安装jdk，直接上传 js 和 css 文件进行压缩，可选择是采用 YUI Compressor 或 Closure Compiler 。 4、GZIP 压缩你的 JS 和 CSS 文件： 压缩js和css可以通过服务器动态脚本进行也可以更简单的使用apache服务器可以在网站根目录 .htaccess 中加入以下代码 AddOutputFilterByType DEFLATE text/html text/css text/plain text/xml application/x-javascript application/json Header append Vary Accept-Encoding 这段代码的意思是调用服务器的压缩模块对以上文件输出之前进行GZIP压缩，gzip的压缩之后所有文件都应该能减少30%以上的体积。特别是对于大量使用js的博客有了gzip保驾护航之后速度能提高不少。 5、使用css sprites合并图片 一个网站经常使用小图标和小图片进行美化，但是很遗憾这些小图片占用了大量的HTTP请求，因此可以采用sprites的方式把所有的图片合并成一张图片 ，可以通过相关工具在线合并，也可以在ps中合并。 6、优化你网站图片： 大量使用的图片和图标虽然可以给网站带来美轮美奂的效果，图文混编更是一种非常绚丽的博文展现方法。可图片的体积确实不是很给力，jpg是一种有损压缩格式，而png虽然是无损的，但缺憾是体积颇大。为了减少图片体积达到最快的下载速度，每一张图片上传前应该优化一下体积。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网站优化","slug":"技术/网站优化","permalink":"http://yoursite.com/categories/技术/网站优化/"}],"tags":[{"name":"网站优化","slug":"网站优化","permalink":"http://yoursite.com/tags/网站优化/"}]},{"title":"网页响应式开发3","slug":"响应式开发3","date":"2018-06-23T09:31:50.119Z","updated":"2018-06-13T11:24:51.049Z","comments":true,"path":"2018/06/23/响应式开发3/","link":"","permalink":"http://yoursite.com/2018/06/23/响应式开发3/","excerpt":"1、不使用绝对宽度由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。 具体说，CSS代码不能指定像素宽度： 1width: xx%; 或者1width:auto;","text":"1、不使用绝对宽度由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。 具体说，CSS代码不能指定像素宽度： 1width: xx%; 或者1width:auto; 2、相对大小的字体3、设置 box-sizing: border-box字体也不能使用绝对大小（px），而只能使用相对大小（em）。123body &#123; font: normal 100% Helvetica, Arial, sans-serif; &#125; 123h1 &#123; font-size: 1.5em; &#125; 4、流动布局（fluid grid）“流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。 12345678910.main &#123; float: right; width: 70%; &#125; .leftBar &#123; float: left; width: 25%; &#125; float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。 另外，绝对定位（position: absolute）的使用，也要非常小心。 5、选择加载CSS“自适应网页设计”的核心，就是CSS3引入的Media Query模块。 它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 123&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-device-width: 400px)\" href=\"tinyScreen.css\" /&gt; 上面的代码意思是，如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。 6、CSS的@media规则同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 123456789101112@media screen and (max-device-width: 400px) &#123; .column &#123; float: none; width:auto; &#125; #sidebar &#123; display:none; &#125; &#125; 上面的代码意思是，如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）。 7、图片的自适应（fluid image）除了布局和文本，”自适应网页设计”还必须实现图片的自动缩放。 这只要一行CSS代码： 1img &#123; max-width: 100%;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"http://yoursite.com/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"http://yoursite.com/tags/响应式开发/"}]},{"title":"网页响应式开发2","slug":"响应式开发2","date":"2018-06-23T09:31:50.103Z","updated":"2018-06-13T11:25:15.986Z","comments":true,"path":"2018/06/23/响应式开发2/","link":"","permalink":"http://yoursite.com/2018/06/23/响应式开发2/","excerpt":"遵循的一些准则和基础1、在 Viewport 里加 Meta 标签在你 HTML 的&lt;head&gt; 代码里添加 Meta 标签。它可以使 media queries 在不同设备上起作用 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;","text":"遵循的一些准则和基础1、在 Viewport 里加 Meta 标签在你 HTML 的&lt;head&gt; 代码里添加 Meta 标签。它可以使 media queries 在不同设备上起作用 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 2、理解CSS盒模型 3、设置 box-sizing: border-box在 CSS 文件最顶端设置 box-sizing。运用 * 通用选择器使其应用到页面的每个元素上。12345*, *:before, *:after &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;&#125; 4、创建容器一个容器将包含页面所有标签，并控制页面最大宽度. 运用容器，让我们的响应式设计更进了一步！ 5、创建列在移动优先里，列默认均是 block 级别的（可以占满整行的宽度）。不需要额外的样式！ 12345&lt;div class=\"container\"&gt; &lt;div class=\"column\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt;&lt;/div&gt; 6、创建列宽在大屏中，用 float: left 将列水平排列。然后运用 padding 设置相邻两列之间的间隙，忘掉传统的margin吧。 7、创建行列应该包裹在行内，以避免其他元素堆放在其旁边造成布局混乱。否则就会出现广为人知的 clearing 问题。出现之后可以使用由 Nicolas Gallagher 发明的 clearfix 解决。 12345678910111213141516171819&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213.clearfix:before,.clearfix:after &#123; content: \" \"; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 8、相对流（ Flow Opposite ）给你想让它在移动端优先显示，而在大屏幕中右侧显示的列，添加 .flow-opposite 类。 12345678910&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half flow-opposite\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123@media (min-width: 40rem) &#123; .column.flow-opposite &#123; float: right; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"http://yoursite.com/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"http://yoursite.com/tags/响应式开发/"}]},{"title":"网页响应式开发","slug":"响应式开发","date":"2018-06-23T09:31:50.079Z","updated":"2018-06-14T01:07:01.689Z","comments":true,"path":"2018/06/23/响应式开发/","link":"","permalink":"http://yoursite.com/2018/06/23/响应式开发/","excerpt":"一、原理定义最小宽度： // Extra small devices (portrait phones, less than 576px)// No media query since this is the default in Bootstrap // Small devices (landscape phones, 576px and up)@media (min-width: 576px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … }","text":"一、原理定义最小宽度： // Extra small devices (portrait phones, less than 576px)// No media query since this is the default in Bootstrap // Small devices (landscape phones, 576px and up)@media (min-width: 576px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … } 定义最大宽度：// Extra small devices (portrait phones, less than 576px)@media (max-width: 575.98px) { … } // Small devices (landscape phones, less than 768px)@media (max-width: 767.98px) { … } // Medium devices (tablets, less than 992px)@media (max-width: 991.98px) { … } // Large devices (desktops, less than 1200px)@media (max-width: 1199.98px) { … } // Extra large devices (large desktops)// No media query since the extra-large breakpoint has no upper bound on its width 使用逻辑混用：// Extra small devices (portrait phones, less than 576px)@media (max-width: 575.98px) { … } // Small devices (landscape phones, 576px and up)@media (min-width: 576px) and (max-width: 767.98px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) and (max-width: 991.98px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) and (max-width: 1199.98px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … } 提取模板：(用的 bootstrap)12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css\" integrity=\"sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Hello, world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.2.1.slim.min.js\" integrity=\"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js\" integrity=\"sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js\" integrity=\"sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 响应式框架介绍1、bootstrap如何安装？ 建议使用npm来安装：命令如下：12npm install bootstrap 也可以用CDN安装： CSS only 1&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\" integrity=\"sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB\" crossorigin=\"anonymous\"&gt; JS, Popper.js, and jQuery 123&lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js\" integrity=\"sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; 2、Foundation模板快速开发具体的模板，可以看bootstrap,不做详细介绍了。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"http://yoursite.com/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"http://yoursite.com/tags/响应式开发/"}]},{"title":"CSS 网格布局知识2","slug":"前端基础知识整理4","date":"2018-06-23T09:31:50.034Z","updated":"2018-06-11T12:57:59.131Z","comments":true,"path":"2018/06/23/前端基础知识整理4/","link":"","permalink":"http://yoursite.com/2018/06/23/前端基础知识整理4/","excerpt":"定义一个网格：Grid(网格) 模块为 display 属性提供了一个新的值：grid。当你将任何元素的 display 属性设置为 grid 时，那么这个元素就是一个 网格容器(grid container)，它的所有直接子元素就成了 网格项(grid items)。 让我们创建创建一个 3×3 的布局，做一个 Tic-Tac-Toe (井字游戏) 棋盘。 首先，我们将写一些 HTML： 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;","text":"定义一个网格：Grid(网格) 模块为 display 属性提供了一个新的值：grid。当你将任何元素的 display 属性设置为 grid 时，那么这个元素就是一个 网格容器(grid container)，它的所有直接子元素就成了 网格项(grid items)。 让我们创建创建一个 3×3 的布局，做一个 Tic-Tac-Toe (井字游戏) 棋盘。 首先，我们将写一些 HTML： 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt; .game-board div 是网格容器，而 .box div 是网格项。现在我们将通过 Grid 布局来实现 3×3 布局。 123456.game-board &#123; display: grid; grid-template-rows: 200px 200px 200px; grid-template-columns: 200px 200px 200px; &#125; grid-template-rows 属性允许我们指定网格中的行数及行的高度。那么你应该猜到另一个属性是干什么的了。 grid-template-columns 属性允许我们指定网格中的列数及列的宽度。 fr 单位(等分)fr 是为网格布局定义的一个新单位。它可以帮助你摆脱计算百分比，并将可用空间等分。 例如，如果在网格容器中设置这个规则：grid-template-rows: 2fr 3fr，那么你的网格容器将首先被分成 2 行。然后将数字部分加在一起，这里总和为 5， 即 5 等分。 就是说，我们将有 2 行：第一排占据垂直空间的 2/5 。 第二排占垂直空间的 3/5 。 回到我们的 Tic-Tac-Toe 例子，我们使用 fr 代替 px。我们想要的是，应该有3行3列。所以，我们只需要用 3 个 1fr 替换 3 个 200px 即可： 123456.game-board &#123; display: grid; grid-template-rows: 1fr 1fr 1fr; grid-template-columns: 1fr 1fr 1fr; &#125; 这里特别需要注意的是： fr 单位是等分可用空间，或者说剩余空间。看个例子: 123456789.game-board &#123; grid-gap:2px; display: grid; width:300px; height:200px; grid-template-rows: 100px 1fr 1fr; grid-template-columns: 1fr 50px 1fr; &#125; 你会看到 fr 单位是将 总的尺寸 减去 单元格明确尺寸后，在等分剩余空间。 grid-gap 是间隔。 repeat() 函数在某些情况下，我们可能有很多的列和行。在 grid-template 属性中指定每一个值可能会很乏味。幸运的是，有一个 repeat 函数，就像任何一个循环重复多少次输出某个给定值。它有两个参数。第一个是迭代次数，第二个是要重复的值。我们用 repeat 函数重写上面的例子。 123456.game-board &#123; display: grid; grid-template-rows: repeat(3, 1fr); grid-template-columns: repeat(3, 1fr); &#125; grid-template 属性grid-template 属性是 grid-template-rows 和 grid-template-columns 的简写语法。 这是它的语法： grid-template: ro ws / co lu mns; 我们上面的例子使用这个简写语法后，看起来非常整齐。 12345.game-board &#123; display: grid; grid-template: repeat(3, 1fr) / repeat(3, 1fr); &#125; 下面是具体创建的例子了：HTML 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt;&lt;/div&gt; CSS 12345678910111213141516171819202122232425.game-board&#123; width: 600px; height: 600px; margin: 0 auto; background-color: #34495e; color: #fff; border: 6px solid #2c3e50; border-radius: 10px; display: grid; grid-template: repeat(3, 1fr) / repeat(3, 1fr);&#125;.box&#123; border: 6px solid #2c3e50; border-radius: 2px; font-family: Helvetica; font-weight: bold; font-size: 4em; display: flex; justify-content: center; align-items: center;&#125; 网格线编号,网格单元格，网格轨道网格线是存在于列和行每一侧的线。一组垂直线将空间垂直划分成列，而另一组水平线将空间水平划分成行。这意味着在我们之前的例子中，有四条垂直线和四条水平线包含它们之间的行和列。 在将网格项从一个位置跨越到另一个位置时，网格线变得非常有用。 网格轨道是两条线之间的空间。 网格轨道可以是一行或一列。 网格单元格很像表格单元，是两条相邻垂直线和两条相邻水平线之间的空间。 这是网格中最小的单位。 定位网格项采取了前面的例子的网格，并用数字从1到9标记每个单元格，而不是X或O，下面是它的样子： 假设我想将第 6 个框移到第 2 个框的位置。 我们使用网格模块，改变网格中网格项的位置是一件轻而易举的事情。 要将第6个框移到第2个框的位置，我们必须确切知道第2个框在哪里。通过网格线编号的帮助，我们可以很容易地找到这个位置。第二个方框位于第2条列网格线之后，第3条列网格线之前，第1条行网格线之下，第2条行网格线之上。现在我们可以使用以下属性将这些网格线编号分配到第6个框中： grid-column-start grid-column-end grid-row-start grid-row-end 前两个属性对应于垂直网格线，也就是列网格线的开始和结束。 最后两个属性是指水平网格线，也就是行网格线的开始和结束。 让我们分配正确的网格线编号来移动第 6 个框。 1234567.box:nth-child(6) &#123; grid-row-start: 1; grid-row-end: 2; grid-column-start: 2; grid-column-end: 3; &#125; 还有两个简写属性用于将行和列的开始网格线和结束网格线设置在一起。 12345.box:nth-child(6) &#123; grid-row: 1 / 2; grid-column: 2 / 3; &#125; 此外，还有一个grid-area属性是所有四个上述属性的简写属性。 它按以下顺序取值： grid-area: / / / ; 现在我们的例子可以写成这样: 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / 3; &#125; 如果我们想要第6个框跨越两个框的区域呢？ 这很容易通过将 column-end 值加 1 的办法来完成。 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / 4; &#125; 您也可以使用 span 关键字和占据的 轨道数量，来代替指定 grid-row-end 和 grid-column-end 的结束网格线编号。 在这种情况下，第6个框是跨越 2 列和 1 行。 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / span 2; &#125; 网格区域命名grid-area 属性也可以用来命名网格的某一个部分，然后我们可以用 grid-template-areas 属性来定位。让我们创建一个简单的 bread-and-butter 布局，顶部有一个 top, nav，中间有 main 和 aside，下面是 footer。这是所需的HTML： 1234567&lt;div class=\"container\"&gt; &lt;header&gt;&lt;/header&gt; &lt;nav&gt;&lt;/nav&gt; &lt;main&gt;&lt;/main&gt; &lt;aside&gt;&lt;/aside&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/div&gt; 我们需要使用 grid-area 属性来命名每个区域： 1234567891011121314151617181920212223242526272829header &#123; grid-area: header; background-color: #9b59b6; &#125; nav &#123; grid-area: nav; background-color: #3498db; &#125; main &#123; grid-area: main; background-color: #2ecc71; &#125; aside &#123; grid-area: aside; background-color: #f1c40f; &#125; footer &#123; grid-area: footer; background-color: #1abc9c; &#125; 现在我们将使用 grid-template-areas 属性来指定每个网格区域所占据的行和列。 以下是我们如何做到的： 1234567891011.container &#123; display: grid; grid-template-rows: 1fr 5fr 1fr; grid-template-columns: 2fr 5fr 3fr; grid-template-areas: \"header header header\" \"nav main aside\" \"footer footer footer\"; grid-gap: .75em; &#125; 请注意，header 和 footer 单词重复三次。 这表明，header 和 footer 横跨 3 列的宽度。 你可以把它全部写在一行中，但是把每一行写在一个单独的行上很好，很干净。 你可以看到我在这里使用了一个新的属性 grid-gap。 它所做的只是在两个网格区域之间添加一个间距。 你也可以使用 grid-row-gap 和 grid-column-gap 来为行和列指定不同的间距值。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"网格布局","slug":"技术/前端基础知识/网格布局","permalink":"http://yoursite.com/categories/技术/前端基础知识/网格布局/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"网格布局","slug":"网格布局","permalink":"http://yoursite.com/tags/网格布局/"}]},{"title":"CSS 网格布局知识1","slug":"前端基础知识整理3","date":"2018-06-23T09:31:50.016Z","updated":"2018-06-11T12:33:13.612Z","comments":true,"path":"2018/06/23/前端基础知识整理3/","link":"","permalink":"http://yoursite.com/2018/06/23/前端基础知识整理3/","excerpt":"2.1 网格布局知识 CSS Grid(网格) 布局使我们能够比以往任何时候都可以更灵活构建和控制自定义网格。 Grid(网格) 布局使我们能够将网页分成具有简单属性的行和列。它还能使我们在不改变任何HTML的情况下，使用 CSS 来定位和调整网格内的每个元素。它允许 HTML 纯粹作为内容的容器。HTML 结构不再受限于样式表现，比如不要为了实现某种布局而多次嵌套，现在这些都可以让 CSS 来完成。 浏览器兼容性 对于大多数布局，我们会使用下面的query特性来让老的浏览器对他们理解的特性也能工作： 12345@supports (display: grid) &#123; .grid &#123; display: grid; &#125;&#125; 不支持浏览器@supports或网格的浏览器将不会生效。","text":"2.1 网格布局知识 CSS Grid(网格) 布局使我们能够比以往任何时候都可以更灵活构建和控制自定义网格。 Grid(网格) 布局使我们能够将网页分成具有简单属性的行和列。它还能使我们在不改变任何HTML的情况下，使用 CSS 来定位和调整网格内的每个元素。它允许 HTML 纯粹作为内容的容器。HTML 结构不再受限于样式表现，比如不要为了实现某种布局而多次嵌套，现在这些都可以让 CSS 来完成。 浏览器兼容性 对于大多数布局，我们会使用下面的query特性来让老的浏览器对他们理解的特性也能工作： 12345@supports (display: grid) &#123; .grid &#123; display: grid; &#125;&#125; 不支持浏览器@supports或网格的浏览器将不会生效。 创建带有间距（gutter）的两列（column）网格 [使用grid-template-columns 和 grid-gap创建带间距的两列布局] 为了创建上述网格布局，我们需要使用grid-template-columns和grid-gap。grid-template-columns表示网格中的列是如何布局的，它的值是一连串以空格分割的的值，这些值标识每列的大小，值的个数表示列的数目。 例如，四列250px宽度的网格布局可以这样表示： 1grid-template-columns: 250px 250px 250px 250px; 也可以使用repeat关键字表示：1grid-template-columns: repeat(4, 250px); 定义间距grid-gap定义了网格布局的间距大小，接收一个或两个值，如果定义两个值则表示列（column）和行（row）的间距大小。 在两列布局示例中，我们可以如下使用： 12345.grid &#123; display: grid; grid-template-columns: 50vw 50vw; grid-gap: 1rem;&#125; 不幸的是，这个间距将会占用容器元素的整体宽度，计算出来就是100vw + 1rem，最终这个布局会导致出现水平滚动条。 为了解决这个空间溢出问题，我们需要些不同的方法来处理，需要用分数单位或者说是FR。 分数单位标识占用可用空间的份额，如果900px是可用空间，其中的一个元素占有1份，另外的元素占有2份——那么第一个元素的宽度会是900px的1/3，另外的元素是900px的2/3。修改后用分数代替view-port单位的新代码如下： 12345.grid &#123; display: grid; grid-template-columns: 1fr 1fr; grid-gap: 1rem;&#125; 内容对齐为了对齐示例中的内容，我们在子元素上使用grid布局，并加上对齐属性来定位他们到指定轨道(track)，轨道就是一个网格的列或行的某个位置的常见的名称。网格跟Flex布局一样，有一系列对齐的属性——共有四种值——start, center, end, 和stretch，分别对应其子元素所在的轨道。stretch跟其他不太一样，它会将元素从所在轨道的头拉伸到尾。 [align-items 和 justify-content] 例子中我们要将内容水平和垂直居中，可以通过在容器上设置下面这些属性：12345.center-content &#123; display: grid; align-items: center; justify-content: center;&#125; 通过CSS网格实现内边距（Negative Space）网格布局允许你通过grid-column-start属性指定列开始的位置，所以就有了可以在网格内创建内边距的可能性。[使用grid-template-columns和grid-column-start创建内边距] 在上面的内边距示例中，html结构中用一个div包裹另外一个div：123&lt;div class=\"grid\"&gt; &lt;div class=\"child\"&gt;&lt;!-- 内容 --&gt;&lt;/div&gt;&lt;/div 网格像这样设置： 123.child &#123; grid-column-start: 2;&#125; 创建行如果我们想分割布局为四份，我们目前所了解的关于列的布局方式对行同样有效： 12345.grid &#123; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 250px 250px;&#125; 理想情况下这个示例是没问题的。因为此时每个网格项的内容足够少而不会撑开每行。但随着内容的变化，一切都不一样了。当示例中的内容超出指定行的大小后，看下会发生什么： [内容超出声明的行高] 我们创建了250px高的两行，如果内容超过每行的高度，将会打破布局并和后面的行的内容重叠。并不是一个我们想要的结果。 灵活的设置最小值我们在该场景下需要的是设置最小尺寸的能力，但又要允许尺寸可以根据内容弹性变化。这里我们通过上面旧浏览器示例中的minmax关键字实现。 123.grid &#123; grid-template-rows: minmax(250px, auto) minmax(250px, auto);&#125; 现在我们已经了解了创建带有内容的行的基础方法，我们开始来创建水平和垂直交错的更复杂网格布局。 [使用grid-column-start和span关键字创建复杂网格布局Unsplash] 123.span-column-3 &#123; grid-column-start: span 3;&#125; 不需要媒体查询（media queries）的弹性网格虽然上面说到的例子能在可用空间内适应变化，但是没有一个是专门为空间变化设计的。网格有两个非常有用的特性来适应可用空间的变化。这两个属性叫‘auto-fit’和‘auto-fill’，像下面这样结合repeat function和minmax function使用： 1grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); auto-fill的表现跟auto-fit类似，但是任何的空白空间都会自动收缩，同时这一行的元素也会被拉升——类似flexbox的效果，列会随着可用空间变小发生折叠。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"网格布局","slug":"技术/前端基础知识/网格布局","permalink":"http://yoursite.com/categories/技术/前端基础知识/网格布局/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"网格布局","slug":"网格布局","permalink":"http://yoursite.com/tags/网格布局/"}]},{"title":"CSS 基础知识整理","slug":"前端基础知识整理2","date":"2018-06-23T09:31:49.997Z","updated":"2018-06-11T08:17:38.481Z","comments":true,"path":"2018/06/23/前端基础知识整理2/","link":"","permalink":"http://yoursite.com/2018/06/23/前端基础知识整理2/","excerpt":"1、CSS基础知识亲自做的思维导图：方便学习查看","text":"1、CSS基础知识亲自做的思维导图：方便学习查看 2、CSS 布局知识亲自做的思维导图：方便学习查看","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML 基础知识整理","slug":"前端基础知识整理1","date":"2018-06-23T09:31:49.978Z","updated":"2018-06-11T06:43:26.675Z","comments":true,"path":"2018/06/23/前端基础知识整理1/","link":"","permalink":"http://yoursite.com/2018/06/23/前端基础知识整理1/","excerpt":"把很久之前学习的基础知识整理一遍：1、HTML基础元素亲自做的思维导图：方便学习查看","text":"把很久之前学习的基础知识整理一遍：1、HTML基础元素亲自做的思维导图：方便学习查看 1.2 HTML表单元素亲自做的思维导图：方便学习查看 2、DOM文档对象模型 根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 亲自做的思维导图：方便学习查看 上面两个图标明了其属性，下面看看具体的方法： 1、创建 HTML 内容1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=\"p1\"&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById(\"p1\").innerHTML=\"New text!\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、改变 HTML 样式1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=\"p2\"&gt;Hello world!&lt;/p&gt;&lt;script&gt;document.getElementById(\"p2\").style.color=\"blue\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、创建新的 HTML 元素 将新元素作为父元素的最后一个子元素进行添加。 12345678910111213&lt;&lt;div id=\"d1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var element=document.getElementById(\"d1\");element.appendChild(para);&lt;/script&gt; 插在前面1234567891011121314&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var element=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");element.insertBefore(para,child);&lt;/script&gt; 4、删除已有的 HTML 元素 如需删除 HTML 元素，您必须清楚该元素的父元素： 12345678910&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var parent=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");parent.removeChild(child);&lt;/script&gt;&lt;/html&gt; 6、替换 HTML 元素 如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法： 1234567891011121314&lt;&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var parent=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");parent.replaceChild(para,child);&lt;/script&gt; 7、使用事件：123456789101112131415&lt;html&gt;&lt;body&gt;&lt;script&gt;function ChangeBackground()&#123;document.body.style.backgroundColor=\"lavender\";&#125;&lt;/script&gt;&lt;input type=\"button\" onclick=\"ChangeBackground()\"value=\"Change background color\" /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"}]},{"title":"JS函数","slug":"函数","date":"2018-06-23T09:31:49.964Z","updated":"2018-06-14T14:19:35.053Z","comments":true,"path":"2018/06/23/函数/","link":"","permalink":"http://yoursite.com/2018/06/23/函数/","excerpt":"一、小心你的return语句我们JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑： 1234function foo() &#123; return &#123; name: 'foo' &#125;;&#125;foo(); // &#123; name: 'foo' &#125;","text":"一、小心你的return语句我们JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑： 1234function foo() &#123; return &#123; name: 'foo' &#125;;&#125;foo(); // &#123; name: 'foo' &#125; 如果把return语句拆成两行： 123456function foo() &#123; return &#123; name: 'foo' &#125;;&#125;foo(); // undefined 要小心了，由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了： 1234function foo() &#123; return; // 自动添加了分号，相当于return undefined; &#123; name: 'foo' &#125;; // 这行语句已经没法执行到了&#125; 所以正确的多行写法是：12345function foo() &#123; return &#123; // 这里不会自动加分号，因为&#123;表示语句尚未结束 name: 'foo' &#125;;&#125; 二、变量和作用域：在JavaScript中，用var申明的变量实际上是有作用域的。 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量： 123456'use strict';function foo() &#123; var x = 1; x = x + 1;&#125; x = x + 2; // ReferenceError! 无法在函数体外引用变量x 如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：123456'use strict';function foo() &#123; var x = 1; x = x + 1;&#125; 1234function bar() &#123; var x = 'A'; x = x + 'B';&#125; 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：123456789'use strict';function foo() &#123; var x = 1; function bar() &#123; var y = x + 1; // bar可以访问foo的变量x! &#125; var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!&#125; JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：123456789'use strict';function foo() &#123; var x = 'Hello, ' + y; console.log(x); var y = 'Bob';&#125;foo(); 虽然是strict模式，但语句var x = ‘Hello, ‘ + y;并不报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 对于上述foo()函数，JavaScript引擎看到的代码相当于：123456function foo() &#123; var y; // 提升变量y的申明，此时y为undefined var x = 'Hello, ' + y; console.log(x); y = 'Bob';&#125; 由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：12345678910function foo() &#123; var x = 1, // x初始化为1 y = x + 1, // y初始化为2 z, i; // z和i为undefined // 其他语句: for (i=0; i&lt;100; i++) &#123; ... &#125;&#125; 三、名字空间 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如： 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。 许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。 四、局部作用域由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的： 12345678'use strict';function foo() &#123; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125; 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量： 12345678910'use strict';function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; // SyntaxError: i += 1;&#125; 五、常量由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”： var PI = 3.14;ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域： 12345'use strict';const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 六、解构赋值从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。 什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量：1234var array = ['hello', 'JavaScript', 'ES6'];var x = array[0];var y = array[1];var z = array[2]; 现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值： 1234'use strict';// 如果浏览器支持解构赋值就不会报错:var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的：12345678910111213141516171819var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: &#123; city: 'Beijing', street: 'No.1 Road', zipcode: '100001' &#125;&#125;;var &#123;name, address: &#123;city, zip&#125;&#125; = person;name; // '小明'city; // 'Beijing'zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：1234567891011121314var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'&#125;;// 把passport属性赋值给变量id:let &#123;name, passport:id&#125; = person;name; // '小明'id; // 'G-12345678'// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题：123456789101112131415161718192021var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678'&#125;;// 如果person对象没有single属性，默认赋值为true:var &#123;name, single=true&#125; = person;name; // '小明'single; // true``````javascript有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：// 声明变量:var x, y;// 解构赋值:&#123;x, y&#125; = &#123; name: '小明', x: 100, y: 200&#125;;// 语法错误: Uncaught SyntaxError: Unexpected token = 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：1(&#123;x, y&#125; = &#123; name: '小明', x: 100, y: 200&#125;); 使用场景解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量： 12var x=1, y=2;[x, y] = [y, x] 快速获取当前页面的域名和路径： 1var &#123;hostname:domain, pathname:path&#125; = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象： 1234function buildDate(&#123;year, month, day, hour=0, minute=0, second=0&#125;) &#123; return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);&#125; 它的方便之处在于传入的对象只需要year、month和day这三个属性： 123456buildDate(&#123; year: 2017, month: 1, day: 1 &#125;);// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)也可以传入hour、minute和second属性：buildDate(&#123; year: 2017, month: 1, day: 1, hour: 20, minute: 15 &#125;);// Sun Jan 01 2017 20:15:00 GMT+0800 (CST) &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"函数","slug":"技术/函数","permalink":"http://yoursite.com/categories/技术/函数/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}]},{"title":"JS原型继承","slug":"关于JS继承","date":"2018-06-23T09:31:49.935Z","updated":"2018-06-22T09:39:26.995Z","comments":true,"path":"2018/06/23/关于JS继承/","link":"","permalink":"http://yoursite.com/2018/06/23/关于JS继承/","excerpt":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。 由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。","text":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。 由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。 首先看一个构造函数： 1234567function Student(props) &#123; this.name = props.name || 'Unnamed';&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125; 构造Student函数， 然后给他一个hello方法 其原型链 我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：12345function PrimaryStudent(props) &#123; // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1;&#125; 但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是： new PrimaryStudent() —-&gt; PrimaryStudent.prototype —-&gt; Object.prototype —-&gt; null 必须想办法把原型链修改为： new PrimaryStudent() —-&gt; PrimaryStudent.prototype —-&gt; Student.prototype —-&gt; Object.prototype —-&gt; null 这样，原型链对了，继承关系就对了。新的基于PrimaryStudent创建的对象不但能调用PrimaryStudent.prototype定义的方法，也可以调用Student.prototype定义的方法。 如果你想用最简单粗暴的方法这么干： PrimaryStudent.prototype = Student.prototype; 是不行的！如果这样的话，PrimaryStudent和Student共享一个原型对象，那还要定义PrimaryStudent干啥？ 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： 123456789101112131415161718192021222324252627282930313233343536373839// PrimaryStudent构造函数:function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 空函数F:function F() &#123;&#125;// 把F的原型指向Student.prototype:F.prototype = Student.prototype;// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:PrimaryStudent.prototype = new F();// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:PrimaryStudent.prototype.constructor = PrimaryStudent;// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;;// 创建xiaoming:var xiaoming = new PrimaryStudent(&#123; name: '小明', grade: 2&#125;);xiaoming.name; // '小明'xiaoming.grade; // 2// 验证原型:xiaoming.__proto__ === PrimaryStudent.prototype; // truexiaoming.__proto__.__proto__ === Student.prototype; // true// 验证继承关系:xiaoming instanceof PrimaryStudent; // truexiaoming instanceof Student; // true 注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。 如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码： 1234567function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125; 这个inherits()函数可以复用： 123456789101112131415161718192021function Student(props) &#123; this.name = props.name || 'Unnamed';&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125;function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 实现原型继承链:inherits(PrimaryStudent, Student);// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;; JavaScript的原型继承实现方式就是： 定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this； 借助中间函数F实现原型链继承，最好通过封装的inherits函数完成； 继续在新的构造函数的原型上定义新方法。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JS原型继承","slug":"技术/JS原型继承","permalink":"http://yoursite.com/categories/技术/JS原型继承/"}],"tags":[{"name":"JS原型继承","slug":"JS原型继承","permalink":"http://yoursite.com/tags/JS原型继承/"}]},{"title":"HTML 中的data_","slug":"关于data_","date":"2018-06-23T09:31:49.919Z","updated":"2018-06-14T14:16:39.043Z","comments":true,"path":"2018/06/23/关于data_/","link":"","permalink":"http://yoursite.com/2018/06/23/关于data_/","excerpt":"‘data-‘属性的作用是什么?下面我们通过一个例子来看看 我们写一个html页面，自定义一个data-chb=”header”的属性，希望具备这个属性的div区域背景颜色为黑色，文字为白色，居中显示；不具备data-chb自定义属性的div按照默认方式显示，html代码如下： 123456789&lt;body&gt; &lt;div data-chb=\"header\"&gt; &lt;h1&gt;我是使用了data-chb自定义属性的div&lt;/h1&gt; &lt;/div&gt; &lt;br/&gt; &lt;div&gt; 我没有使用data-chb自定义属性，该怎么展现就怎么展现； &lt;/div&gt; &lt;/body&gt;","text":"‘data-‘属性的作用是什么?下面我们通过一个例子来看看 我们写一个html页面，自定义一个data-chb=”header”的属性，希望具备这个属性的div区域背景颜色为黑色，文字为白色，居中显示；不具备data-chb自定义属性的div按照默认方式显示，html代码如下： 123456789&lt;body&gt; &lt;div data-chb=\"header\"&gt; &lt;h1&gt;我是使用了data-chb自定义属性的div&lt;/h1&gt; &lt;/div&gt; &lt;br/&gt; &lt;div&gt; 我没有使用data-chb自定义属性，该怎么展现就怎么展现； &lt;/div&gt; &lt;/body&gt; 要想实现”背景颜色为黑色，文字为白色，居中显示”的显示效果，我们定义如下的css： 12345678&lt;style&gt; .ui_header &#123; background-color: black; text-align: center; color:white; border:1px solid #000; &#125; &lt;/style&gt; 然后我们通过如下js方法实现在页面加载时，动态添加css定义，改变具备data-chb属性的div的显示样式： 123456789101112131415161718192021&lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var elems = document.getElementsByTagName(\"div\"); if(elems!=null&amp;&amp;elems.length&gt;0)&#123; var length = elems.length; //遍历所有DIV控件 for(var i=0;i&lt;length;i++)&#123; var elem = elems[i]; //获取该控件的自定义属性 var customAttr = elem.dataset.chb; //也可以通过如下方式获得自定义属性 //var customAttr = elem.dataset[\"chb\"]; //如果是我们预先定义好的header值，表示需要处理 if(customAttr==\"header\")&#123; //添加样式 elem.setAttribute(\"class\",\"ui_header\"); &#125; &#125; &#125; &#125; &lt;/script&gt; 这样我们就能动态的改变需要控制的div了。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"html","slug":"技术/html","permalink":"http://yoursite.com/categories/技术/html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"},{"name":"data_","slug":"data","permalink":"http://yoursite.com/tags/data/"}]},{"title":"前端问题集合及思考","slug":"一些问题集合及理解","date":"2018-06-23T09:31:49.909Z","updated":"2018-06-15T07:36:52.517Z","comments":true,"path":"2018/06/23/一些问题集合及理解/","link":"","permalink":"http://yoursite.com/2018/06/23/一些问题集合及理解/","excerpt":"1、前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标","text":"1、前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 2、的title和alt有什么区别 title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。alt是的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 3、HTML全局属性(global attribute)有哪些 accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素 class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素 contenteditable: 指定元素内容是否可编辑 contextmenu: 自定义鼠标右键弹出菜单内容 data-*: 为元素增加自定义属性 dir: 设置元素文本方向 draggable: 设置元素是否可拖拽 dropzone: 设置元素拖放类型： copy, move, link hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果 id: 元素id，文档内唯一 lang: 元素内容的的语言 spellcheck: 是否启动拼写和语法检查 style: 行内css样式 tabindex: 设置元素可以获得焦点，通过tab可以导航 title: 元素相关的建议信息 translate: 元素和子孙节点内容是否需要本地化 4、HTTP method 一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可 GET是最常用的方法，通常用于请求服务器发送某个资源。 HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分 PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它 POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将- 其发送到要去的地方。 TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。 OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。 DELETE请求服务器删除请求URL指定的资源 5、如何进行网站性能优化 1、content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下- 载和DNS查询 避免重定向：多余的中间访问 使Ajax可缓存 非必须组件延迟加载 未来所需组件预加载 减少DOM元素数量 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 减少iframe数量 不要404 2、Server方面 使用CDN 添加Expires或者Cache-Control响应头 对组件使用Gzip压缩 配置ETag Flush Buffer Early Ajax使用GET进行请求 避免空src的img标签 3、Cookie方面 减小cookie大小 引入资源的域名不要包含cookie 4、css方面 将样式表放到页面顶部 不使用CSS表达式 使用不使用@import 不使用IE的Filter 5 Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 合理设计事件监听器 6 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 保证favicon.ico小并且可缓存 7 HTTP状态码及其含义 1XX：信息状态码 2XX：成功状态码 3XX：重定向 4XX：客户端错误 5XX: 服务器错误 7、CSS选择器有哪些 *通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+ #X id选择器：选择id值为X的元素，兼容性：IE6+ .X 类选择器： 选择class包含X的元素，兼容性：IE6+ X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+ X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+ :link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+ X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+ X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+ X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+ [attr]：选择所有设置了attr属性的元素，兼容性IE7+ [attr=value]：选择属性值刚好为value的元素 [attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素 [attr|=value]：选择属性值刚好为value或者value-开头的元素 [attr^=value]：选择属性值以value开头的元素 [attr$=value]：选择属性值以value结尾的元素 [attr=value]*：选择属性值中包含value的元素 [:checked]：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+ X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，- ::after为IE9+ :hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+ :not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+ ::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+ ::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+ :nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n &gt;= 0， 兼容性IE9+ :nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素 其中n &gt;= 0，兼容性IE9+ X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+ X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+ X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+ X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+ X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+ X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+ X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素 是此此类型元素的第一个兄弟。选中它。兼容性IE9+ 8、css hack原理及常用hack 原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。常见的hack有1）属性hack。2）选择器hack。3）IE条件注释 9、link与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC link可以通过rel=”alternate stylesheet”指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import 10、PNG,GIF,JPG的区别及如何选 GIF: 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG： 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG： 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 11、容器包含若干浮动元素时如何清理(包含)浮动 容器元素闭合标签前添加额外元素并设置clear: both 父元素触发块级格式化上下文(见块级可视化上下文部分) 设置容器元素伪元素进行清理推荐的清理浮动方法示例： 1234567891011121314151617181920212223242526/*** 在标准浏览器下使用* 1 content内容为空格用于修复opera下文档中出现* contenteditable属性时在清理浮动元素上下的空白* 2 使用display使用table而不是block：可以防止容器和* 子元素top-margin折叠,这样能使清理效果与BFC，IE6/7* zoom: 1;一致**/.clearfix:before,.clearfix:after &#123; content: \" \"; /* 1 */ display: table; /* 2 */&#125;.clearfix:after &#123; clear: both;&#125;/*** IE 6/7下使用* 通过触发hasLayout实现包含浮动**/.clearfix &#123; *zoom: 1;&#125; 12、外边距折叠(collapsing margins) 毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下： 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 元素自身的margin-bottom和margin-top相邻时也会折叠 13、如何水平居中一个元素 如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现 如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。3）IE6下需在父元素上设置text-align: center;,再给子元素恢复需要的值 12345678910111213141516171819&lt;body&gt; &lt;div class=\"content\"&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; text-align: center; /* 3 */ &#125; .content &#123; width: 500px; /* 1 */ text-align: left; /* 3 */ margin: 0 auto; /* 2 */ background: purple; &#125;&lt;/style&gt; 如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=\"content\"&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; &#125; .content &#123; width: 500px; /* 1 */ float: left; position: relative; /* 2 */ left: 50%; /* 3 */ margin-left: -250px; /* 4 */ background-color: purple; &#125;&lt;/style&gt; 如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=\"content\"&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; position: relative; &#125; .content &#123; width: 800px; position: absolute; left: 50%; margin-left: -400px; background-color: purple; &#125;&lt;/style&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端问题集合及思考","slug":"技术/前端问题集合及思考","permalink":"http://yoursite.com/categories/技术/前端问题集合及思考/"}],"tags":[{"name":"问题集合","slug":"问题集合","permalink":"http://yoursite.com/tags/问题集合/"}]},{"title":"webpack使用技术详情","slug":"webpack系列文章7","date":"2018-06-23T09:31:49.891Z","updated":"2018-06-10T12:13:50.341Z","comments":true,"path":"2018/06/23/webpack系列文章7/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章7/","excerpt":"本文主要步骤：1、创建文件 mkdir mywebpack2、npm init -y // 用来创建webpack的配置文件3、安装webpack npm install webpack –save-dev4、安装组件 npm install html-webpack-plugin –save-dev //具体的index等文件自己创建就好了5、webpack.config.js 的使用 //这个之前基础都学习过了","text":"本文主要步骤：1、创建文件 mkdir mywebpack2、npm init -y // 用来创建webpack的配置文件3、安装webpack npm install webpack –save-dev4、安装组件 npm install html-webpack-plugin –save-dev //具体的index等文件自己创建就好了5、webpack.config.js 的使用 //这个之前基础都学习过了 5、处理js文件需要用的依赖包： 12npm install --save-dev babel-loader babel-core npm install --save-dev babel-preset-env //转义ES6 为防止浏览器不支持 Promise/Object.assign/Array.from等还有性能问题,我们引入两个包: babel-polyfill babel-plugin-transform-runtime 1npm install --save-dev babel-polyfill babel-plugin-transform-runtime 引入生产版本依赖 npm install –save babel-runtime 通过 .babelrc 添加配置: 12345678&#123; \"presets\": [ \"env\" ], \"plugins\": [ \"transform-runtime\" ]&#125; 将 babel-polyfill 加到你的 entry 数组中使用，配置js文件要经过babel转义： 12345678910111213141516171819202122232425const path = require('path');module.exports = &#123; //entry为入口,webpack从这里开始编译 entry: [ \"babel-polyfill\", path.join(__dirname, './src/index.js') ], //output为输出 path代表路径 filename代表文件名称 output: &#123; path: path.join(__dirname, './bundle'), filename: 'bundle.js' &#125;, //module是配置所有模块要经过什么处理 //test:处理什么类型的文件,use:用什么,include:处理这里的,exclude:不处理这里的 module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], include: path.join(__dirname , 'src'), exclude: /node_modules/ &#125; ] &#125;,&#125;; 6、打包： 直接执行命令webpack7、看看日志说明：8、使用快捷方式进行编译： 可以在项目package.json里面来配置 ： 123456789101112131415161718192021&#123; \"name\": \"05-01\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" \"build\":\"webpack\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"babel-preset-es2015\": \"^6.14.0\", \"babel-preset-react\": \"^6.11.1\", \"babelify\": \"^7.3.0\", \"react\": \"^15.3.2\", \"react-dom\": \"^15.3.2\", \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.1\" &#125;&#125; 下面你可以使用命令： 1npm run build 9、怎样自动加载： 首先安装webpack-dev-server 执行命令：1npm install webpack-dev-serve --save-dev 下面就可以执行如下命令了1webpack-dev-server --contentbase -src --inline 注意： 这里版本很重要，要匹配。 如果安装其他版本，可以在名称后面加@跟上版本号就可以了。 10、配置端口号 webpakc.config.js 里面配置 12345 devServer: &#123; contentBase: path.join(__dirname, \"dist\"), compress: true, port: 9000&#125; 接下来以管理员身份执行命令 1npm run start 11、配置ESLint 实现代码规范化自动化测试 安装： npm install eslint --save-dev 配置： package.json 里面的配置： { \"name\": \"05-01\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" \"build\":\"webpack\" \"lintjs\":\"eslint app/ webpack.*.js --cache\" //这是我们需要配置的 }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"babel-preset-es2015\": \"^6.14.0\", \"babel-preset-react\": \"^6.11.1\", \"babelify\": \"^7.3.0\", \"react\": \"^15.3.2\", \"react-dom\": \"^15.3.2\", \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.1\" } } eslintrc.js 里面的配置： 具体的规则可以去官网查看。 执行如下命令即可： npm run lintjs 如果有错误：会相应的提示。 怎样修复呢：执行命令： npm run lintjs -- --fix 如何自动测试 在webpack 中集成： 首先进行安装： npm install eslint-loader –save-dev 然后在webpack.config.js 里面进行配置： 具体配置可以查看官方文档。 12、webpack中加载CSS的相关配置 需要安装两个插件： npm insatall css-loader style-loader --save-dev webpack.config.js进行配置： const ExtractTextPlugin = require('extract-text-webpack-plugin'); ... module: { rules: [ ... { test: /\\.less$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: ['css-loader', 'style-loader','postcss-loader', 'less-loader'] //进行配置 }) } ] }, plugins: [ ... new ExtractTextPlugin({ filename: 'index.css' }), ], 13、webpack中加载图片 在 webpack 里，负责图片翻译的是 file-loader： npm install file-loader --save-dev 在webpack.config.js里面进行配置： }, { test: /\\.(png|jpg|gif)$/, use: [ { loader: 'file-loader', options: {} } ] } ] 至于我们怎样在js文件里配置： 我们需要一张图片，我从 unsplash 找来了一张玫瑰，放到 src/img/rose.jpg 位置。 我们在 src/index.js 中 import 它： import ReactDOM from 'react-dom' import Rose from './img/rose.jpg' class App extends React.Component { render () { return ( &lt;div&gt;&lt;img src={Rose} alt='玫瑰' /&gt;&lt;/div&gt; ) } } ReactDOM.render(&lt;App /&gt;, document.body) 14、打包： 在完成项目开发后，我们需要输出文件给生产环境部署，只要执行： npx webpack --mode production 14、部署： 部署时，拷贝 dist 目录即可。 15、清理 dist 随着某些文件的增删，我们的 dist 目录下会产生一些不再使用的文件，我们不想这些文件也部署到生产环境上占用空间，所以 webpack 在打包前最好能删除 dist 目录。 我们来试试 clean-webpack-plugin。 首先是安装： npm i -D clean-webpack-plugin 然后在 webpack.config.js 中调用： const path = require('path') const CleanWebpackPlugin = require('clean-webpack-plugin') module.exports = { mode: 'development', devServer: { contentBase: path.resolve(__dirname, 'dist') }, plugins: [ new CleanWebpackPlugin(['dist']) //需要实例化 ], module: { 再执行 npx webpack –mode production，webpack 确实会在打包前清空 dist 目录，但我们的 index.html 也一起被清空了。 下面我们使用 html-webpack-plugin 来自动生成 index.html： 首先是安装： npm i --save-dev html-webpack-plugin 调整 webpack.config.js： const CleanWebpackPlugin = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', devServer: { contentBase: path.resolve(__dirname, 'dist') }, plugins: [ new CleanWebpackPlugin(['dist']) new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin() ], 再运行 npx webpack –mode production，dist 下已经自动生成 index.html，再 title 却是 Webpack App，我们需要再调整一下 webpack.config.js： plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin() new HtmlWebpackPlugin({ title: 'webpack 教程' }) ], 至此，我们大致的教程算是完结了，但是这样比较麻烦，如果开发一个特定类型的项目，我们可以采用脚手架的方式直接生成： 比较有名的有： create-react-app react 官方出品的一套，只适用开发 react.js 项目； neutrino.js 这是 Mozilla 出品的一套解决方案，Web、React、Node.js 等方案均有；","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-配置","slug":"webpack系列文章6","date":"2018-06-23T09:31:49.883Z","updated":"2018-06-10T05:36:38.888Z","comments":true,"path":"2018/06/23/webpack系列文章6/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章6/","excerpt":"12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ &#125;,","text":"12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ &#125;, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157 module: &#123; // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: &#123; test, include, exclude &#125;, // issuer 条件（导入源） enforce: \"pre\", enforce: \"post\", // 标识应用这些规则，即使规则覆盖（高级选项） loader: \"babel-loader\", // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: &#123; presets: [\"es2015\"] &#125;, // loader 的可选项 &#125;, &#123; test: /\\.html$/, test: \"\\.html$\" use: [ // 应用多个 loader 和选项 \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // 只使用这些嵌套规则之一 &#123; rules: [ /* rules */ ] &#125;, // 使用所有这些嵌套规则（合并可用条件） &#123; resource: &#123; and: [ /* 条件 */ ] &#125; &#125;, // 仅当所有条件都匹配时才匹配 &#123; resource: &#123; or: [ /* 条件 */ ] &#125; &#125;, &#123; resource: [ /* 条件 */ ] &#125;, // 任意条件匹配时匹配（默认为数组） &#123; resource: &#123; not: /* 条件 */ &#125; &#125; // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ &#125;, resolve: &#123; // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ \"node_modules\", path.resolve(__dirname, \"app\") ], // 用于查找模块的目录 extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 使用的扩展名 alias: &#123; // 模块别名列表 \"module\": \"new-module\", // 起别名：\"module\" -&gt; \"new-module\" 和 \"module/path/file\" -&gt; \"new-module/path/file\" \"only-module$\": \"new-module\", // 起别名 \"only-module\" -&gt; \"new-module\"，但不匹配 \"only-module/path/file\" -&gt; \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // 起别名 \"module\" -&gt; \"./app/third/module.js\" 和 \"module/file\" 会导致错误 // 模块别名相对于当前上下文导入 &#125;, /* 可供选择的别名语法（点击展示） */ /* 高级解析选项（点击展示） */ &#125;, performance: &#123; hints: \"warning\", // 枚举 maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // enum // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map' 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: \"web\", // 枚举 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: [\"react\", /^@angular\\//], // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: \"errors-only\", // 精确控制要显示的 bundle 信息 devServer: &#123; proxy: &#123; // proxy URLs to backend development server '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... &#125;, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-插件","slug":"webpack系列文章5","date":"2018-06-23T09:31:49.877Z","updated":"2018-06-10T05:32:59.393Z","comments":true,"path":"2018/06/23/webpack系列文章5/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章5/","excerpt":"插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。","text":"插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。 用法由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。 根据你的 webpack 用法，这里有多种方式使用插件： 12345678910111213141516171819202122232425const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, use: 'babel-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-loader","slug":"webpack系列文章4","date":"2018-06-23T09:31:49.867Z","updated":"2018-06-10T05:26:58.187Z","comments":true,"path":"2018/06/23/webpack系列文章4/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章4/","excerpt":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;;","text":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;; loader的使用方式 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 //不推荐就不作介绍了 CLI：在 shell 命令中指定它们。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-出口","slug":"webpack系列文章3","date":"2018-06-23T09:31:49.850Z","updated":"2018-06-10T05:17:33.215Z","comments":true,"path":"2018/06/23/webpack系列文章3/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章3/","excerpt":"配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 单个出口用法在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config;","text":"配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 单个出口用法在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config; 多个出口如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 123456789101112&#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' &#125;&#125;// 写入到硬盘：./dist/app.js, ./dist/search.js","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-入口起点","slug":"webpack系列文章2","date":"2018-06-23T09:31:49.845Z","updated":"2018-06-10T05:08:39.152Z","comments":true,"path":"2018/06/23/webpack系列文章2/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章2/","excerpt":"单个入口单个入口在上一章其实已经看到了，下面，我们主要学习下多个入口怎样创建。","text":"单个入口单个入口在上一章其实已经看到了，下面，我们主要学习下多个入口怎样创建。 多个入口1、分离 应用程序(app) 和 第三方库(vendor) 入口123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 从表面上看，这告诉我们 webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。 2、多页面应用程序1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; webpack 需要 3 个独立分离的依赖图（如上面的示例）。在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事： 使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习","slug":"webpack系列文章1","date":"2018-06-23T09:31:49.836Z","updated":"2018-06-10T04:51:28.443Z","comments":true,"path":"2018/06/23/webpack系列文章1/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章1/","excerpt":"简介webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 核心概念的理解1.入口(entry)2.输出(output)3.loader4.插件(plugins)","text":"简介webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 核心概念的理解1.入口(entry)2.输出(output)3.loader4.插件(plugins) 1、入口入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中.可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。接下来我们看一个 entry 配置的最简单例子： 123456789module.exports = &#123; context: path.join(dirname), devtool: debug ? “inline-sourcemap” : null, entry: “./src/js/index.js”, output: &#123; path: dirname, filename: “./src/bundle.js” &#125;,&#125;; 2、出口output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： 1234567891011121314 var debug = process.env.NODE_ENV !== “production”; var webpack = require(‘webpack’); var path = require(‘path’);module.exports = &#123; context: path.join(dirname), devtool: debug ? “inline-sourcemap” : null, entry: “./src/js/index.js”, output: &#123; path: dirname, filename: “./src/bundle.js” &#125;,&#125;; 3、loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在更高层面，在 webpack 的配置中 loader 有两个目标：1、test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。2、use 属性，表示进行转换时，应该使用哪个 loader。 123456789101112131415const path = require(‘path’);const config = &#123; output: &#123; filename: ‘my-first-webpack.bundle.js’ &#125;, module: &#123; rules: [ &#123; test: /.txt$/, use: ‘raw-loader’ &#125; // 也可以改成.js?$/ ] &#125;&#125;;module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。” 4、插件loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 1234567891011121314151617const HtmlWebpackPlugin = require(‘html-webpack-plugin’); // 通过 npm 安装const webpack = require(‘webpack’); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /.txt$/, use: ‘raw-loader’ &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: ‘./src/index.html’&#125;) ]&#125;;module.exports = config; 5、模式通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 123module.exports = &#123; mode: ‘production’&#125;; 以上是对webpack 作了一个简短的介绍，后面详细学习之！","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Sass学习","slug":"Sass","date":"2018-06-23T09:31:49.803Z","updated":"2018-06-14T14:16:23.953Z","comments":true,"path":"2018/06/23/Sass/","link":"","permalink":"http://yoursite.com/2018/06/23/Sass/","excerpt":"一、安装由于Sass是基于ruby的，所以先安装ruby。 Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板：Start Command Prompt with Ruby 1、通过命令安装 Sass 1gem install sass 使用国内淘宝镜像gem。第一步：gem sources –remove https://rubygems.org/ 删除自带gem第二步：gem sources -a https://ruby.taobao.org/ 添加国内淘宝镜像gem第三步：gem sources 显示下载的gem信息 查看版本sass -v 更新：gem update sass 删除gem uninstall sass","text":"一、安装由于Sass是基于ruby的，所以先安装ruby。 Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板：Start Command Prompt with Ruby 1、通过命令安装 Sass 1gem install sass 使用国内淘宝镜像gem。第一步：gem sources –remove https://rubygems.org/ 删除自带gem第二步：gem sources -a https://ruby.taobao.org/ 添加国内淘宝镜像gem第三步：gem sources 显示下载的gem信息 查看版本sass -v 更新：gem update sass 删除gem uninstall sass 后缀sass 和scss 的区别： sass 不用{} 包裹， 而scss可以包裹。建议使用scss。 示例： 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 二、Sass编译 命令编译 GUI工具编译 自动化编译 1、命令编译单文件编译： sass &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css 多文件编译： sass sass/:css/ 上面的命令表示将项目中“sass”文件夹中所有“.scss”(“.sass”)文件编译成“.css”文件，并且将这些 CSS 文件都放在项目中“css”文件夹中。 2、GUI 界面工具编译就推荐Koala 其他就不介绍了。 3、自动化编译 Grunt Gulp 具体配置自行查看文档 三、常见错误： 最为常见的一个错误就是字符编译引起的。在Sass的编译的过程中，是不是支持“GBK”编码的。所以在创建 Sass 文件时，就需要将文件编码设置为“utf-8”。 另外一个错误就是路径中的中文字符引起的。建议在项目中文件命名或者文件目录命名不要使用中文字符。而至于人为失误造成的编译失败，在编译过程中都会有具体的说明，大家可以根据编译器提供的错误信息进行对应的修改。 四、不同样式风格的输出方法 嵌套输出方式 nested 展开输出方式 expanded 紧凑输出方式 compact 压缩输出方式 compressed 4.1嵌套输出方式 nested语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style nested”:sass –watch test.scss:test.css –style nested 编译出来的 CSS 样式风格：12345678910nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; 4.2 展开输出方式 expanded语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style expanded”: sass –watch test.scss:test.css –style expanded 这个输出的 CSS 样式风格和 nested 类似，只是大括号在另起一行，同样上面的代码，编译出来：12345678910111213nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 4.3 紧凑输出方式 compact语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style compact”: sass –watch test.scss:test.css –style compact 该方式适合那些喜欢单行 CSS 样式格式的朋友，编译后的代码如下： 123nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; 4.4 压缩输出方式 compressed在编译的时候带上参数“ –style compressed”: sass –watch test.scss:test.css –style compressed 压缩输出方式会去掉标准的 Sass 和 CSS 注释及空格。也就是压缩好的 CSS 代码样式风格：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Sass","slug":"技术/Sass","permalink":"http://yoursite.com/categories/技术/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"}]},{"title":"Sass学习2","slug":"Sass.1","date":"2018-06-23T09:31:49.788Z","updated":"2018-06-13T07:07:34.096Z","comments":true,"path":"2018/06/23/Sass.1/","link":"","permalink":"http://yoursite.com/2018/06/23/Sass.1/","excerpt":"一、Sass的基本特性 上图非常清楚告诉了大家，Sass 的变量包括三个部分： 1.声明变量的符号“$”2.变量名称3.赋予变量的值","text":"一、Sass的基本特性 上图非常清楚告诉了大家，Sass 的变量包括三个部分： 1.声明变量的符号“$”2.变量名称3.赋予变量的值 1.1普通变量和默认变量：1、普通变量定义之后可以在全局范围内使用。 2、默认变量sass 的默认变量仅需要在值后面加上 !default 即可。 sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。12345$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight; &#125; 1.2变量的调用1.3 全局比那里和局部变量1234567891011121314//SCSS$color: orange !default;//定义全局变量(在选择器、函数、混合宏...的外面定义的变量为全局变量).block &#123; color: $color;//调用全局变量&#125;em &#123; $color: red;//定义局部变量 a &#123; color: $color;//调用局部变量 &#125;&#125;span &#123; color: $color;//调用全局变量&#125; 什么时候声明变量？ 我的建议，创建变量只适用于感觉确有必要的情况下。不要为了某些骇客行为而声明新变量，这丝毫没有作用。只有满足所有下述标准时方可创建新变量： 该值至少重复出现了两次； 该值至少可能会被更新一次； 该值所有的表现都与变量有关（非巧合）。基本上，没有理由声明一个永远不需要更新或者只在单一地方使用变量。 嵌套-选择器嵌套 Sass 中还提供了选择器嵌套功能，但这也并不意味着你在 Sass 中的嵌套是无节制的，因为你嵌套的层级越深，编译出来的 CSS 代码的选择器层级将越深，这往往是大家不愿意看到的一点。这个特性现在正被众多开发者滥用。 Sass 的嵌套分为三种： 选择器嵌套 属性嵌套 伪类嵌套 选择器嵌套假设我们有一段这样的结构：1234567&lt;header&gt;&lt;nav&gt; &lt;a href=“##”&gt;Home&lt;/a&gt; &lt;a href=“##”&gt;About&lt;/a&gt; &lt;a href=“##”&gt;Blog&lt;/a&gt;&lt;/nav&gt;&lt;header&gt; 想选中 header 中的 a 标签，在 Sass 中，就可以使用选择器的嵌套来实现：123456789nav &#123; a &#123; color: red; header &amp; &#123; color:green; &#125; &#125; &#125; 属性嵌套Sass 中还提供属性嵌套，CSS 有一些属性前缀相同，只是后缀不一样，比如：border-top/border-right，与这个类似的还有 margin、padding、font 等属性。假设你的样式中用到了： 1234.box &#123; border-top: 1px solid red; border-bottom: 1px solid green;&#125; 在 Sass 中我们可以这样写：123456.box &#123; border: &#123; top: 1px solid red; bottom: 1px solid green; &#125;&#125; 伪类嵌套1234567891011.clearfix&#123;&amp;:before,&amp;:after &#123; content:\"\"; display: table; &#125;&amp;:after &#123; clear:both; overflow: hidden; &#125;&#125; 避免选择器嵌套： 选择器嵌套最大的问题是将使最终的代码难以阅读。开发者需要花费巨大精力计算不同缩进级别下的选择器具体的表现效果。选择器越具体则声明语句越冗长，而且对最近选择器的引用(&amp;)也越频繁。在某些时候，出现混淆选择器路径和探索下一级选择器的错误率很高，这非常不值得。 混合宏-声明混合宏如果你的整个网站中有几处小样式类似，比如颜色，字体等，在 Sass 可以使用变量来统一处理，那么这种选择还是不错的。但当你的样式变得越来越复杂，需要重复使用大段的样式时，使用变量就无法达到我们目了。这个时候 Sass 中的混合宏就会变得非常有意义。 1、声明混合宏 不带参数混合宏： 在 Sass 中，使用“@mixin”来声明一个混合宏。如： 1234@mixin border-radius&#123; -webkit-border-radius: 5px; border-radius: 5px;&#125; 其中 @mixin 是用来声明混合宏的关键词，有点类似 CSS 中的 @media、@font-face 一样。border-radius 是混合宏的名称。大括号里面是复用的样式代码。 带参数混合宏： 除了声明一个不带参数的混合宏之外，还可以在定义混合宏时带有参数，如：1234@mixin border-radius($radius:5px)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 复杂的混合宏： 上面是一个简单的定义混合宏的方法，当然， Sass 中的混合宏还提供更为复杂的，你可以在大括号里面写上带有逻辑关系，帮助更好的做你想做的事情,如：12345678@mixin box-shadow($shadow...) &#123; @if length($shadow) &gt;= 1 &#123; @include prefixer(box-shadow, $shadow); &#125; @else&#123; $shadow:0 0 4px rgba(0,0,0,.3); @include prefixer(box-shadow, $shadow); &#125;&#125; 混合宏-调用混合宏在 Sass 中通过 @mixin 关键词声明了一个混合宏，那么在实际调用中，其匹配了一个关键词“@include”来调用声明好的混合宏。例如在你的样式中定义了一个圆角的混合宏“border-radius”: 1234@mixin border-radius&#123; -webkit-border-radius: 3px; border-radius: 3px;&#125; 在一个按钮中要调用定义好的混合宏“border-radius”，可以这样使用: 123button &#123; @include border-radius;&#125; 混合宏的参数–传一个不带值的参数1234@mixin border-radius($radius)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 在混合宏“border-radius”中定义了一个不带任何值的参数“$radius”。 在调用的时候可以给这个混合宏传一个参数值：123.box &#123; @include border-radius(3px);&#125; 混合宏的参数–传一个带值的参数Sass 混合宏除了能传一个参数之外，还可以传多个参数，如：123456789@mixin center($width,$height)&#123; width: $width; height: $height; position: absolute; top: 50%; left: 50%; margin-top: -($height) / 2; margin-left: -($width) / 2;&#125; 有一个特别的参数“…”。当混合宏传的参数过多之时，可以使用参数来替代，如： 12345678910@mixin box-shadow($shadows...)&#123; @if length($shadows) &gt;= 1 &#123; -webkit-box-shadow: $shadows; box-shadow: $shadows; &#125; @else &#123; $shadows: 0 0 2px rgba(#000,.25); -webkit-box-shadow: $shadow; box-shadow: $shadow; &#125;&#125; 继承在 Sass 中是通过关键词 “@extend”来继承已存在的类样式块，从而实现代码的继承。如下所示： 123456789101112131415161718//SCSS.btn &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff; @extend .btn;&#125;.btn-second &#123; background-color: orange; color: #fff; @extend .btn;&#125; 占位符 （重点）Sass 中的占位符 %placeholder 功能是一个很强大，很实用的一个功能，这也是我非常喜欢的功能。他可以取代以前 CSS 中的基类造成的代码冗余的情形。因为 %placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码。来看一个演示： 123456%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125; 这段代码没有被 @extend 调用，他并没有产生任何代码块，只是静静的躺在你的某个 SCSS 文件中。只有通过 @extend 调用才会产生代码： 1234567891011121314151617181920//SCSS%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125;.btn &#123; @extend %mt5; @extend %pt5;&#125;.block &#123; @extend %mt5; span &#123; @extend %pt5; &#125;&#125; 混合宏 VS 继承 VS 占位符a) Sass 中的混合宏使用 编译出来的 CSS 清晰告诉了大家，他不会自动合并相同的样式代码，如果在样式文件中调用同一个混合宏，会产生多个对应的样式代码，造成代码的冗余，这也是 CSSer 无法忍受的一件事情。不过他并不是一无事处，他可以传参数。 个人建议：如果你的代码块中涉及到变量，建议使用混合宏来创建相同的代码块。 b) Sass 中继承 总结：使用继承后，编译出来的 CSS 会将使用继承的代码块合并到一起，通过组合选择器的方式向大家展现，比如 .mt, .block, .block span, .header, .header span。这样编译出来的代码相对于混合宏来说要干净的多，也是 CSSer 期望看到。但是他不能传变量参数。 个人建议：如果你的代码块不需要专任何变量参数，而且有一个基类已在文件中存在，那么建议使用 Sass 的继承。 c) 占位符 总结：编译出来的 CSS 代码和使用继承基本上是相同，只是不会在代码中生成占位符 mt 的选择器。那么占位符和继承的主要区别的，“占位符是独立定义，不调用的时候是不会在 CSS 中产生任何代码；继承是首先有一个基类存在，不管调用与不调用，基类的样式都将会出现在编译出来的 CSS 代码中。” [Sass]插值#{}123456789$properties: (margin, padding);@mixin set-value($side, $value) &#123; @each $prop in $properties &#123; #&#123;$prop&#125;-#&#123;$side&#125;: $value; &#125;&#125;.login-box &#123; @include set-value(top, 14px);&#125; 它可以让变量和属性工作的很完美，上面的代码编译成 CSS： 12345.login-box &#123; margin-top: 14px; padding-top: 14px;&#125; Sass的基本特性-运算[Sass运算]加法加法运算是 Sass 中运算中的一种，在变量或属性中都可以做加法运算。如： 123.box &#123; width: 20px + 8in;&#125; 编译出来的 CSS:123.box &#123; width: 788px;&#125; 但对于携带不同类型的单位时，在 Sass 中计算会报错，如下例所示：123.box &#123; width: 20px + 1em;&#125; [Sass运算]减法Sass 的减法运算和加法运算类似，我们通过一个简单的示例来做阐述： 123456$full-width: 960px;$sidebar-width: 200px;.content &#123; width: $full-width - $sidebar-width;&#125; [Sass运算]乘法Sass 中的乘法运算和前面介绍的加法与减法运算还略有不同。虽然他也能够支持多种单位（比如 em ,px , %），但当一个单位同时声明两个值时会有问题。比如下面的示例： 123.box &#123; width:10px * 2px; &#125; 如果进行乘法运算时，两个值单位相同时，只需要为一个数值提供单位即可。上面的示例可以修改成： 123.box &#123; width: 10px * 2;&#125; [Sass运算]除法Sass 的乘法运算规则也适用于除法运算。不过除法运算还有一个特殊之处。众所周知“/”符号在 CSS 中已做为一种符号使用。因此在 Sass 中做除法运算时，直接使用“/”符号做为除号时，将不会生效，编译时既得不到我们需要的效果，也不会报错。一起先来看一个简单的示例： 123.box &#123; width: 100px / 2; &#125; 这样的结果对于大家来说没有任何意义。要修正这个问题，只需要给运算的外面添加一个小括号( )即可： 123.box &#123; width: (100px / 2); &#125; 除了上面情况带有小括号，“/”符号会当作除法运算符之外，如果“/”符号在已有的数学表达式中时，也会被认作除法符号。如下面示例： 123.box &#123; width: 100px / 2 + 2in; &#125; 另外，在 Sass 除法运算中，当用变量进行除法运算时，“/”符号也会自动被识别成除法，如下例所示： 12345678910$width: 1000px;$nums: 10;.item &#123; width: $width / 10; &#125;.list &#123; width: $width / $nums;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Sass","slug":"技术/Sass","permalink":"http://yoursite.com/categories/技术/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"}]},{"title":"React4-React事件与数据的双向绑定","slug":"React系列文章6","date":"2018-06-23T09:31:49.776Z","updated":"2018-06-10T02:42:32.388Z","comments":true,"path":"2018/06/23/React系列文章6/","link":"","permalink":"http://yoursite.com/2018/06/23/React系列文章6/","excerpt":"事件的绑定 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: \"IMOOC\",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"提交\" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125;","text":"事件的绑定 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: \"IMOOC\",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"提交\" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125; Props 属性： props 对于模块属于外来属性 传递参数： 在被引入模块中添加{this.props.userid} 这里面的userid就是你引用的一个参数，然后你就可以在引入该模块的文件中给这个userid进行赋值了：&lt;’被引入的模块’ userid={1220}/&gt;，这样就可以顺利的传递参数了。 模块中接受参数：this.props.username 被引入模块的示例代码：123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : \"Parry\", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 引入模块文件的示例代码：1234567891011121314151617var React = require('react');var ReactDOM = require('react-dom');import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;\"nick\"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React4-React 属性与事件","slug":"React系列文章5","date":"2018-06-23T09:31:49.759Z","updated":"2018-06-10T02:31:27.249Z","comments":true,"path":"2018/06/23/React系列文章5/","link":"","permalink":"http://yoursite.com/2018/06/23/React系列文章5/","excerpt":"State属性 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\", age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;","text":"State属性 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\", age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; Props 属性： props 对于模块属于外来属性 传递参数： 在被引入模块中添加{this.props.userid} 这里面的userid就是你引用的一个参数，然后你就可以在引入该模块的文件中给这个userid进行赋值了：&lt;’被引入的模块’ userid={1220}/&gt;，这样就可以顺利的传递参数了。 模块中接受参数：this.props.username 被引入模块的示例代码：123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : \"Parry\", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 引入模块文件的示例代码：1234567891011121314151617var React = require('react');var ReactDOM = require('react-dom');import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;\"nick\"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React4-React生命周期","slug":"React系列文章4","date":"2018-06-23T09:31:49.745Z","updated":"2018-06-12T00:25:56.288Z","comments":true,"path":"2018/06/23/React系列文章4/","link":"","permalink":"http://yoursite.com/2018/06/23/React系列文章4/","excerpt":"React生命周期官方文档React生命周期图例：","text":"React生命周期官方文档React生命周期图例： React生命周期代码示例：12345678910111213141516171819202122232425262728293031import React from 'react';export default class BodyIndex extends React.Component&#123;//定义页面将要加载 componentWillMount()&#123; //定义你的逻辑即可 console.log(\"BodyIndex - componentWillMount\"); &#125;//定义页面加载完成 componentDidMount()&#123; console.log(\"BodyIndex - componentDidMount\"); &#125; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React3-React内置表达式","slug":"React系列文章3","date":"2018-06-23T09:31:49.729Z","updated":"2018-06-12T00:30:36.755Z","comments":true,"path":"2018/06/23/React系列文章3/","link":"","permalink":"http://yoursite.com/2018/06/23/React系列文章3/","excerpt":"三元表达式：12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component&#123; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125;","text":"三元表达式：12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component&#123; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125; React 三元表达式 {window.userName == ‘’ ? ‘默认用户名’ : ‘用户名： ‘ + userName} 注意是== ， 而不是”=” React 传参 disabled={boolInput} 不要用”” 而是用{}; React注释如何来写 如果在代码块里面： {/注释/} 在代码块外面： //comments React如果要显示html里面的空格 HTML 要显示可以进行 Unicode 转码","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React2-React组件化","slug":"React系列文章2","date":"2018-06-23T09:31:49.717Z","updated":"2018-06-09T07:01:36.714Z","comments":true,"path":"2018/06/23/React系列文章2/","link":"","permalink":"http://yoursite.com/2018/06/23/React系列文章2/","excerpt":"React 机制","text":"React 机制 React 组件 组件是 React 的一个主要特性 组件对于模块化开发的重要性 组件的 return 函数里返回的 HTML 节点必须是一个 可以给外部使用的组件定义：export default class ComponentHeader extends React.Component{} 入口的定义：ReactDOM.render(, document.getElementById(‘example’)); 组件return 函数返回Html的节点必须是一个 index.js 里面代码示例:12345678910111213141516import React from 'react';import PCHeader from './pc_header';import PCFooter from './pc_footer';import PCNewsContainer from './pc_newscontainer';export default class PCIndex extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;PCHeader&gt;&lt;/PCHeader&gt; &lt;PCNewsContainer&gt;&lt;/PCNewsContainer&gt; &lt;PCFooter&gt;&lt;/PCFooter&gt; &lt;/div&gt; ); &#125;;&#125; pc_header.js 里面代码示例:1234567891011import React from 'react';import &#123;Row, Col&#125; from 'antd';import &#123;Router, Route, Link, browserHistory&#125; from 'react-router'class PCHeader extends React.Component &#123;render()&#123; return( &lt;h1&gt;这是页头&lt;/h1&gt; );&#125; &#125; React 多组件嵌套通过上面的示例我们可以看到：组件也可以通过参数的形式传递。把pc_header.js 组件作为一个参数传递到index.js里面。 这样我们可以分别开发页面不同的部分，非常方便。 需要注意的有两点： 命名的规范化。 项目搭建的规范化。 这里我们需要注意一个项目怎么去搭建项目的结构，下面是示例图片，可以参考下：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React1-react简介及安装","slug":"react系列1","date":"2018-06-23T09:31:49.705Z","updated":"2018-06-09T06:40:55.284Z","comments":true,"path":"2018/06/23/react系列1/","link":"","permalink":"http://yoursite.com/2018/06/23/react系列1/","excerpt":"本文主要讲述使用react创建一个新闻站点的技术教程，本文主要技术来源于：慕课网。如果你感兴趣，可以跟着一起来完成。 React的简介 Facebook 内部用来开发Instagram JavaScript MVC框架 React 开源网址：React github React 中文文档：React中文文档","text":"本文主要讲述使用react创建一个新闻站点的技术教程，本文主要技术来源于：慕课网。如果你感兴趣，可以跟着一起来完成。 React的简介 Facebook 内部用来开发Instagram JavaScript MVC框架 React 开源网址：React github React 中文文档：React中文文档 学习React需要掌握的知识 JS ES5/Es6 ——会使用babel ——&gt; 中文文档：babel NodeJS CSS HTML React 安装及管理 确保先安装了node.js —-最新的node.js包已经包含了npm 怎么查看是否安装？ node -v npm -v npm 换镜像源 （用淘宝的源就可以） 这样下载就比较快了 最好采用npm 安装管理 （官方推荐方式） 用npm 安装React 项目初始化 1npm init 通过初始化就建立了一个react的配置文件，下面再进行安装react需要的其他依赖包。 安装依赖包可以有两种方式：1、先在配置文件里加入需要安装的文件包名和版本，然后通过npm install 来进行安装2、直接用npm来安装 方式如下：npm install babel-preset-es2015@版本号 –save 这样你安装的包就可以把安装依赖的信息存储到配置文件里了 这里我们需要安装的依赖包有babel-preset-es2015 、babelify、babel-preset-react、react、react-dom 等 其他需要的依赖包可以在后续不断加入 注： 如果要全局安装的话可以这样 npm install -g react 至此，我们还不能实现react的正常输出，我们还需要通过webpack来打包。 webpack 的安装 在安装webpack之前，先了解下react的写作流程：先在项目文件里建立一个src文件夹在里面建一个index.js文件 这个文件要传到外面的文件index.html。index.js里这样写： 12345678910var React = require(\"react\");var ReactDOM = require(\"react-dom\");class Index extends React.Component &#123; render() &#123; return( &lt;h1&gt;hello world&lt;/h1&gt; document.getElementById('example') ); &#125;&#125; index.html里这样写：12&lt;div id=\"example\"&gt;123&lt;/div&gt;&lt;script src=\"./src/bundle.js\"&gt;&lt;/script&gt; 这里引入的bundle.js 就是webpack 生成的，他是把我们之前写的index.js生成了浏览器能识别的js文件，这样才能被浏览器识别。 webpack正式安装首先定义一个webpack的配置文件：webpack config.js 通过官方文档来配置。安装：全局安装一下：12npm install -g webpacknpm install -g webpack-dev-server //服务器 项目目录里安装一下：12npm install webpack --savenpm install webpack-dev-server --save //服务器 注： 一定要注意版本的问题，要和react等合适，如果都是最新的应该没问题。 下面来运行： webpack //在命令行执行就会把我们的index.js生成可识别的js文件了。 怎样自动加载呢： webpack-dev-server --contentbase -src --inline //执行后就可以自动加载了","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"node.js 入门系列","slug":"node学习","date":"2018-06-23T09:31:49.699Z","updated":"2018-06-14T05:48:10.809Z","comments":true,"path":"2018/06/23/node学习/","link":"","permalink":"http://yoursite.com/2018/06/23/node学习/","excerpt":"","text":"npm 学习： npm init 初始化来配置package.json –save 生产依赖-S –save-dev 开发依赖-D 是一样的， 加 -f 就是强制安装 mkdr 创建文件 npm update npm uninstall","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"http://yoursite.com/categories/技术/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]},{"title":"JS Map 和 Set","slug":"JS系列Map和Set","date":"2018-06-23T09:31:49.685Z","updated":"2018-06-15T01:14:22.249Z","comments":true,"path":"2018/06/23/JS系列Map和Set/","link":"","permalink":"http://yoursite.com/2018/06/23/JS系列Map和Set/","excerpt":"MapJavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。 为了解决这个问题，最新的ES6规范引入了新的数据类型Map。 Map是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85];","text":"MapJavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。 为了解决这个问题，最新的ES6规范引入了新的数据类型Map。 Map是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 注意数字3和字符串’3’是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素：1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for … of循环来遍历。 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： 123456789'use strict';var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"Map和Set","slug":"技术/JavaScript/Map和Set","permalink":"http://yoursite.com/categories/技术/JavaScript/Map和Set/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Map和Set","slug":"Map和Set","permalink":"http://yoursite.com/tags/Map和Set/"}]},{"title":"JS条件判断和循环","slug":"JS系列3","date":"2018-06-23T09:31:49.675Z","updated":"2018-06-15T01:00:48.804Z","comments":true,"path":"2018/06/23/JS系列3/","link":"","permalink":"http://yoursite.com/2018/06/23/JS系列3/","excerpt":"条件判断JavaScript使用if () { … } else { … }来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下： 多行条件判断如果还要更细致地判断条件，可以使用多个if…else…的组合： 12345678var age = 3;if (age &gt;= 18) &#123; alert('adult');&#125; else if (age &gt;= 6) &#123; alert('teenager');&#125; else &#123; alert('kid');&#125;","text":"条件判断JavaScript使用if () { … } else { … }来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下： 多行条件判断如果还要更细致地判断条件，可以使用多个if…else…的组合： 12345678var age = 3;if (age &gt;= 18) &#123; alert('adult');&#125; else if (age &gt;= 6) &#123; alert('teenager');&#125; else &#123; alert('kid');&#125; 循环计算1+2+3，我们可以直接写表达式： 1 + 2 + 3; // 6要计算1+2+3+…+10，勉强也能写出来。 但是，要计算1+2+3+…+10000，直接写表达式就不可能了。 为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。 JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块： 123456var x = 0;var i;for (i=1; i&lt;=10000; i++) &#123; x = x + i;&#125;x; // 50005000 for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环： for … infor循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来： 12345678var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; console.log(key); // 'name', 'age', 'city'&#125; 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for … in循环可以直接循环出Array的索引： 12345var a = ['A', 'B', 'C'];for (var i in a) &#123; console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'&#125; 请注意，for … in对Array的循环得到的是String而不是Number。 whilefor循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的for循环容易让人看不清循环的逻辑，此时用while循环更佳。 while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：1234567var x = 0;var n = 99;while (n &gt; 0) &#123; x = x + n; n = n - 2;&#125;x; // 2500 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 do … while最后一种循环是do { … } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件： 12345var n = 0;do &#123; n = n + 1;&#125; while (n &lt; 100);n; // 100","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"条件判断和循环","slug":"技术/JavaScript/条件判断和循环","permalink":"http://yoursite.com/categories/技术/JavaScript/条件判断和循环/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"条件判断和循环","slug":"条件判断和循环","permalink":"http://yoursite.com/tags/条件判断和循环/"}]},{"title":"JS数据类型和变量","slug":"JS系列2","date":"2018-06-23T09:31:49.662Z","updated":"2018-06-15T00:33:40.459Z","comments":true,"path":"2018/06/23/JS系列2/","link":"","permalink":"http://yoursite.com/2018/06/23/JS系列2/","excerpt":"NumberJavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型： 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity","text":"NumberJavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型： 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。 如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。 如果字符串内部既包含’又包含”怎么办？可以用转义字符\\来标识，比如： 1'I\\'m \\\"OK\\\"!'; 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\表示的字符就是\\。 多行字符串由于多行字符串用\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ... 表示： 要把多个字符串连接起来，可以用+号连接 要把多个字符串连接起来，可以用+号连接： 1234var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 操作字符串1、 .length2、 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始： 1234567var s = 'Hello, world!';s[0]; // 'H's[6]; // ' 's[7]; // 'w's[12]; // '!'s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 3、 toUpperCase toLowerCase 4、 indexOf indexOf()会搜索指定字符串出现的位置： 123var s = 'hello, world';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1 5、 substring substring()返回指定索引区间的子串： 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值，要么是true，要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来： 1234true; // 这是一个true值false; // 这是一个false值2 &gt; 1; // 这是一个true值2 &gt;= 3; // 这是一个false值 比较运算符当我们对Number做比较时，可以通过比较运算符得到一个布尔值： 1232 &gt; 5; // false5 &gt;= 2; // true7 == 7; // true 实际上，JavaScript允许对任意数据类型做比较： 12false == 0; // truefalse === 0; // false 要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： 1NaN === NaN; // false 最后要注意浮点数的相等比较： 11 / 3 === (1 - 2 / 3); // false 浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true null和undefinednull表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。 在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：1[1, 2, 3.14, &apos;Hello&apos;, null, true]; 数组的元素可以通过索引来访问。请注意，索引的起始值为0： 1234var arr = [1, 2, 3.14, 'Hello', null, true];arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined 操作数组indexOf与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： 12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 注意了，数字30和字符串’30’是不同的元素。 sliceslice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false push和poppush()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift和shift如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： sortsort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] reversereverse()把整个Array的元素给掉个个，也就是反转： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splicesplice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concatconcat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] joinjoin()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 多维数组如果数组的某个元素又是一个Array，则可以形成多维数组，例如： 1var arr = [[1, 2, 3], [400, 500, 600], '-']; 上述Array包含3个元素，其中头两个元素本身也是Array。 对象JavaScript的对象是一组由键-值组成的无序集合，例如： 12345678var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;; 要获取一个对象的属性，我们用对象变量.属性名的方式： 12person.name; // 'Bob'person.zipcode; // null 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如： 12345var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = '007'; // s_007是一个字符串var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null strict模式JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：1i = 10; // i现在是全局变量","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"数据类型和变量","slug":"技术/JavaScript/数据类型和变量","permalink":"http://yoursite.com/categories/技术/JavaScript/数据类型和变量/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"数据类型和变量","slug":"数据类型和变量","permalink":"http://yoursite.com/tags/数据类型和变量/"}]},{"title":"JS-AJAX","slug":"JS-AJAX","date":"2018-06-23T09:31:49.645Z","updated":"2018-06-20T07:44:17.204Z","comments":true,"path":"2018/06/23/JS-AJAX/","link":"","permalink":"http://yoursite.com/2018/06/23/JS-AJAX/","excerpt":"","text":"如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。 这就是Web的运作原理：一次HTTP请求对应一个页面。 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象： 1234567891011121314151617181920212223242526272829303132function success(text) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = text;&#125;function fail(code) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code;&#125;var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。 XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 安全限制上面代码的URL使用的是相对路径。如果你把它改为’http://www.sina.com.cn/&#39;，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。 这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。 完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。 那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的: 第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JS-AJAX","slug":"技术/JS-AJAX","permalink":"http://yoursite.com/categories/技术/JS-AJAX/"}],"tags":[{"name":"JS-AJAX","slug":"JS-AJAX","permalink":"http://yoursite.com/tags/JS-AJAX/"}]},{"title":"jQuery动画","slug":"jQuery4","date":"2018-06-23T09:31:49.632Z","updated":"2018-06-20T07:11:38.801Z","comments":true,"path":"2018/06/23/jQuery4/","link":"","permalink":"http://yoursite.com/2018/06/23/jQuery4/","excerpt":"show / hide直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画： toggle()方法则根据当前状态决定是show()还是hide()。 slideUp / slideDownshow()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的。 slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作。","text":"show / hide直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画： toggle()方法则根据当前状态决定是show()还是hide()。 slideUp / slideDownshow()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的。 slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作。 fadeIn / fadeOutfadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断设置DOM元素的opacity属性来实现，而fadeToggle()则根据元素是否可见来决定下一步动作 自定义动画animate()，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值： 123456var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000); // 在3秒钟内CSS过渡到设定值 animate()还可以再传入一个函数，当动画结束时，该函数将被调用： 12345678910var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000, function () &#123; console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');&#125;); 串行动画jQuery的动画效果还可以串行执行，通过delay()方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单： 123456789101112131415var div = $('#test-animates');// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小div.slideDown(2000) .delay(1000) .animate(&#123; width: '256px', height: '256px' &#125;, 2000) .delay(1000) .animate(&#123; width: '128px', height: '128px' &#125;, 2000);&#125;&lt;/script&gt; 为什么有的动画没有效果你可能会遇到，有的动画如slideUp()根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如height从100px逐渐变为0。但是很多不是block性质的DOM元素，对它们设置height根本就不起作用，所以动画也就没有效果。 此外，jQuery也没有实现对background-color的动画效果，用animate()设置background-color也没有效果。这种情况下可以使用CSS3的transition实现动画效果。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"jQuery动画","slug":"技术/jQuery动画","permalink":"http://yoursite.com/categories/技术/jQuery动画/"}],"tags":[{"name":"jQuery动画","slug":"jQuery动画","permalink":"http://yoursite.com/tags/jQuery动画/"}]},{"title":"jQuery事件","slug":"jQuery3","date":"2018-06-23T09:31:49.617Z","updated":"2018-06-20T00:06:22.551Z","comments":true,"path":"2018/06/23/jQuery3/","link":"","permalink":"http://yoursite.com/2018/06/23/jQuery3/","excerpt":"jQuery能够绑定的事件主要包括：鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。","text":"jQuery能够绑定的事件主要包括：鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件键盘事件仅作用在当前焦点的DOM上，通常是 &lt;input&gt; 和 &lt;textarea&gt; 。 keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 其他事件 focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发； submit：当&lt;form&gt;提交时触发； ready：当页面被载入并且DOM树完成初始化后触发。 其中，ready仅作用于document对象。由于ready事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。 因为JavaScript在此执行的时候，&lt;form&gt;尚未载入浏览器，所以$(‘#testForm)返回[]，并没有绑定事件到任何DOM上。 所以我们自己的初始化代码必须放到document对象的ready事件中，保证DOM已完成初始化： 12345$(document).on('ready', function () &#123; $('#testForm).on('submit', function () &#123; alert('submit!'); &#125;); &#125;); 由于ready事件使用非常普遍，所以可以这样简化：123456$(document).ready(function () &#123; // on('submit', function)也可以简化: $('#testForm).submit(function () &#123; alert('submit!'); &#125;);&#125;); 甚至还可以再简化为：123$(function () &#123; // init...&#125;); 上面的这种写法最为常见。如果你遇到$(function () {…})的形式，牢记这是document对象的ready事件处理函数。 事件参数有些事件，如mousemove和keypress，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入Event对象作为参数，可以从Event对象上获取到更多的信息：12345$(function () &#123; $('#testMouseMoveDiv').mousemove(function (e) &#123; $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); &#125;);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"jQuery事件","slug":"技术/jQuery事件","permalink":"http://yoursite.com/categories/技术/jQuery事件/"}],"tags":[{"name":"jQuery事件","slug":"jQuery事件","permalink":"http://yoursite.com/tags/jQuery事件/"}]},{"title":"jQuery操作DOM","slug":"jQuery2","date":"2018-06-23T09:31:49.602Z","updated":"2018-06-19T06:56:10.980Z","comments":true,"path":"2018/06/23/jQuery2/","link":"","permalink":"http://yoursite.com/2018/06/23/jQuery2/","excerpt":"一、修改Text和HTMLjQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构： 12345&lt;!-- HTML结构 --&gt;&lt;ul id=\"test-ul\"&gt; &lt;li class=\"js\"&gt;JavaScript&lt;/li&gt; &lt;li name=\"book\"&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 分别获取文本和HTML：12$('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript'$('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript' 如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作。","text":"一、修改Text和HTMLjQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构： 12345&lt;!-- HTML结构 --&gt;&lt;ul id=\"test-ul\"&gt; &lt;li class=\"js\"&gt;JavaScript&lt;/li&gt; &lt;li name=\"book\"&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 分别获取文本和HTML：12$('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript'$('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript' 如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作。 修改CSSjQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构 12345678&lt;!-- HTML结构 --&gt;&lt;ul id=\"test-css\"&gt; &lt;li class=\"lang dy\"&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang\"&gt;&lt;span&gt;Java&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang dy\"&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang\"&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang dy\"&gt;&lt;span&gt;Scheme&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; 要高亮显示动态语言，调用jQuery对象的css(‘name’, ‘value’)方法，我们用一行语句实现： $(‘#test-css li.dy&gt;span’).css(‘background-color’, ‘#ffd351’).css(‘color’, ‘red’); 为了和JavaScript保持一致，CSS属性可以用’background-color’和’backgroundColor’两种格式。 css()方法将作用于DOM节点的style属性，具有最高优先级。如果要修改class属性，可以用jQuery提供的下列方法： 1234var div = $('#test-div');div.hasClass('highlight'); // false， class是否包含highlightdiv.addClass('highlight'); // 添加highlight这个classdiv.removeClass('highlight'); // 删除highlight这个class 显示和隐藏DOM要隐藏一个DOM，我们可以设置CSS的display属性为none，利用css()方法就可以实现。不过，要显示这个DOM就需要恢复原有的display属性，这就得先记下来原有的display属性到底是block还是inline还是别的值。 考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供show()和hide()方法，我们不用关心它是如何修改display属性的，总之它能正常工作： var a = $(‘a[target=_blank]’);a.hide(); // 隐藏a.show(); // 显示 隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。 获取DOM信息利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码： 1234567891011121314// 浏览器可视窗口大小:$(window).width(); // 800$(window).height(); // 600// HTML文档大小:$(document).width(); // 800$(document).height(); // 3500// 某个div的大小:var div = $('#test-div');div.width(); // 600div.height(); // 300div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效 attr()和removeAttr()方法用于操作DOM节点的属性： // …var div = $(‘#test-div’);div.attr(‘data’); // undefined, 属性不存在div.attr(‘name’); // ‘Test’div.attr(‘name’, ‘Hello’); // div的name属性变为’Hello’div.removeAttr(‘name’); // 删除name属性div.attr(‘name’); // undefined 操作表单对于表单元素，jQuery对象统一提供val()方法获取和设置对应的value属性： 12345678910111213141516171819202122/* &lt;input id=\"test-input\" name=\"email\" value=\"\"&gt; &lt;select id=\"test-select\" name=\"city\"&gt; &lt;option value=\"BJ\" selected&gt;Beijing&lt;/option&gt; &lt;option value=\"SH\"&gt;Shanghai&lt;/option&gt; &lt;option value=\"SZ\"&gt;Shenzhen&lt;/option&gt; &lt;/select&gt; &lt;textarea id=\"test-textarea\"&gt;Hello&lt;/textarea&gt;*/var input = $('#test-input'), select = $('#test-select'), textarea = $('#test-textarea');input.val(); // 'test'input.val('abc@example.com'); // 文本框的内容已变为abc@example.comselect.val(); // 'BJ'select.val('SH'); // 选择框已变为Shanghaitextarea.val(); // 'Hello'textarea.val('Hi'); // 文本区域已更新为'Hi' 修改DOM要添加新的DOM节点，除了通过jQuery的html()这种暴力方法外，还可以用append()方法，例如：1234567&lt;div id=\"test-div\"&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如何向列表新增一个语言？首先要拿到节点： var ul = $(‘#test-div&gt;ul’); 然后，调用append()传入HTML片段：1ul.append('&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'); 除了接受字符串，append()还可以传入原始的DOM对象，jQuery对象和函数对象： append()把DOM添加到最后，prepend()则把DOM添加到最前。 删除节点要删除DOM节点，拿到jQuery对象后直接调用remove()方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点： var li = $(‘#test-div&gt;ul&gt;li’);li.remove(); // 所有全被删除","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"jQuery操作DOM","slug":"技术/jQuery操作DOM","permalink":"http://yoursite.com/categories/技术/jQuery操作DOM/"}],"tags":[{"name":"jQuery操作DOM","slug":"jQuery操作DOM","permalink":"http://yoursite.com/tags/jQuery操作DOM/"}]},{"title":"jQuery选择器","slug":"jQuery","date":"2018-06-23T09:31:49.586Z","updated":"2018-06-19T05:48:52.691Z","comments":true,"path":"2018/06/23/jQuery/","link":"","permalink":"http://yoursite.com/2018/06/23/jQuery/","excerpt":"一、选择器按ID查找// 查找:var div = $(‘#abc’); #abc以#开头。返回的对象是jQuery对象。 什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。 以上面的查找为例，如果id为abc的存在，返回的jQuery对象如下： […] 如果id为abc的不存在，返回的jQuery对象如下： []","text":"一、选择器按ID查找// 查找:var div = $(‘#abc’); #abc以#开头。返回的对象是jQuery对象。 什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。 以上面的查找为例，如果id为abc的存在，返回的jQuery对象如下： […] 如果id为abc的不存在，返回的jQuery对象如下： [] 按tag查找按tag查找只需要写上tag名称就可以了： var ps = $(‘p’); // 返回所有节点ps.length; // 数一数页面有多少个节点 按class查找按class查找注意在class名称前加一个.： var a = $(‘.red’); // 所有节点包含class=&quot;red&quot;都将返回// 例如:// …// … 通常很多节点有多个class，我们可以查找同时包含red和green的节点： var a = $(‘.red.green’); // 注意没有空格！// 符合条件的节点：// …// … 按属性查找一个DOM节点除了id和class外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找： var email = $(‘[name=email]’); // 找出&lt;??? name=”email”&gt;var passwordInput = $(‘[type=password]’); // 找出&lt;??? type=”password”&gt;var a = $(‘[items=”A B”]’); // 找出&lt;??? items=”A B”&gt; 当属性的值包含空格等特殊字符时，需要用双引号括起来。 按属性查找还可以使用前缀查找或者后缀查找： var icons = $(‘[name^=icon]’); // 找出所有name属性值以icon开头的DOM// 例如: name=”icon-1”, name=”icon-2”var names = $(‘[name$=with]’); // 找出所有name属性值以with结尾的DOM// 例如: name=”startswith”, name=”endswith”这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响： var icons = $(‘[class^=”icon-“]’); // 找出所有class包含至少一个以icon-开头的DOM// 例如: class=”icon-clock”, class=”abc icon-home” 组合查找组合查找就是把上述简单选择器组合起来使用。如果我们查找$(‘[name=email]’)，很可能把表单外的也找出来，但我们只希望查找，就可以这么写： var emailInput = $(‘input[name=email]’); // 不会找出 同样的，根据tag和class来组合查找也很常见： var tr = $(‘tr.red’); // 找出… 多项选择器多项选择器就是把多个选择器用,组合起来一块选：$(‘p,div’); // 把和都选出来$(‘p.red,p.green’); // 把和都选出来 层级选择器（Descendant Selector）如果两个DOM元素具有层级关系，就可以用$(‘ancestor descendant’)来选择，层级之间用空格隔开。 子选择器（Child Selector）子选择器$(‘parent&gt;child’)类似层级选择器，但是限定了层级关系必须是父子关系，就是节点必须是节点的直属子节点。 过滤器（Filter）过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果： 1234567$('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点$('ul.lang li:first-child'); // 仅选出JavaScript$('ul.lang li:last-child'); // 仅选出Lua$('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始$('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素 表单相关针对表单元素，jQuery还有一组特殊的选择器： :input：可以选择，，和； :file：可以选择，和input[type=file]一样； :checkbox：可以选择复选框，和input[type=checkbox]一样； :radio：可以选择单选框，和input[type=radio]一样； :focus：可以选择当前输入焦点的元素，例如把光标放到一个上，用$(‘input:focus’)就可以选出； :checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$(‘input[type=radio]- :checked’)； :enabled：可以选择可以正常输入的、等，也就是没有灰掉的输入； :disabled：和:enabled正好相反，选择那些不能输入的。 查找和过滤通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。 最常见的查找是在某个节点的所有子节点中查找，使用find()方法，它本身又接收一个任意的选择器。 12345678&lt;!-- HTML结构 --&gt;&lt;ul class=\"lang\"&gt; &lt;li class=\"js dy\"&gt;JavaScript&lt;/li&gt; &lt;li class=\"dy\"&gt;Python&lt;/li&gt; &lt;li id=\"swift\"&gt;Swift&lt;/li&gt; &lt;li class=\"dy\"&gt;Scheme&lt;/li&gt; &lt;li name=\"haskell\"&gt;Haskell&lt;/li&gt;&lt;/ul&gt; 用find()查找：1234var ul = $('ul.lang'); // 获得&lt;ul&gt;var dy = ul.find('.dy'); // 获得JavaScript, Python, Schemevar swf = ul.find('#swift'); // 获得Swiftvar hsk = ul.find('[name=haskell]'); // 获得Haskell 如果要从当前节点开始向上查找，使用parent()方法; 对于位于同一层级的节点，可以通过next()和prev()方法; 过滤和函数式编程的map、filter类似，jQuery对象也有类似的方法。 filter()方法可以过滤掉不符合选择器条件的节点： var langs = $(‘ul.lang li’); // 拿到JavaScript, Python, Swift, Scheme和Haskellvar a = langs.filter(‘.dy’); // 拿到JavaScript, Python, Scheme","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"jQuery选择器","slug":"技术/jQuery选择器","permalink":"http://yoursite.com/categories/技术/jQuery选择器/"}],"tags":[{"name":"jQuery选择器","slug":"jQuery选择器","permalink":"http://yoursite.com/tags/jQuery选择器/"}]},{"title":"jQuery-AJAX","slug":"jQuery-AJAX","date":"2018-06-23T09:31:49.553Z","updated":"2018-06-20T07:28:29.394Z","comments":true,"path":"2018/06/23/jQuery-AJAX/","link":"","permalink":"http://yoursite.com/2018/06/23/jQuery-AJAX/","excerpt":"jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求。ajax(url, settings)函数需要接收一个URL和一个可选的settings对象，常用的选项如下： async：是否异步执行AJAX请求，默认为true，千万不要指定为false； method：发送的Method，缺省为’GET’，可指定为’POST’、’PUT’等； contentType：发送POST请求的格式，默认值为’application/x-www-form-urlencoded; charset=UTF-8’，也可以指定为text/plain、- application/json； data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据- contentType把data序列化成合适的格式； headers：发送的额外的HTTP头，必须是一个object； dataType：接收的数据格式，可以指定为’html’、’xml’、’json’、’text’等，缺省情况下根据响应的Content-Type猜测。 下面的例子发送一个GET请求，并返回一个JSON格式的数据：","text":"jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求。ajax(url, settings)函数需要接收一个URL和一个可选的settings对象，常用的选项如下： async：是否异步执行AJAX请求，默认为true，千万不要指定为false； method：发送的Method，缺省为’GET’，可指定为’POST’、’PUT’等； contentType：发送POST请求的格式，默认值为’application/x-www-form-urlencoded; charset=UTF-8’，也可以指定为text/plain、- application/json； data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据- contentType把data序列化成合适的格式； headers：发送的额外的HTTP头，必须是一个object； dataType：接收的数据格式，可以指定为’html’、’xml’、’json’、’text’等，缺省情况下根据响应的Content-Type猜测。 下面的例子发送一个GET请求，并返回一个JSON格式的数据： 1234var jqxhr = $.ajax('/api/categories', &#123; dataType: 'json'&#125;);// 请求已经发送了 不过，如何用回调函数处理返回的数据和出错时的响应呢？ 还记得Promise对象吗？jQuery的jqXHR对象类似一个Promise对象，我们可以用链式写法来处理各种回调： 12345678910111213141516171819'use strict';function ajaxLog(s) &#123; var txt = $('#test-response-text'); txt.val(txt.val() + '\\n' + s);&#125;$('#test-response-text').val('');var jqxhr = $.ajax('/api/categories', &#123; dataType: 'json'&#125;).done(function (data) &#123; ajaxLog('成功, 收到的数据: ' + JSON.stringify(data));&#125;).fail(function (xhr, status) &#123; ajaxLog('失败: ' + xhr.status + ', 原因: ' + status);&#125;).always(function () &#123; ajaxLog('请求完成: 无论成功或失败都会调用');&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"jQuery-AJAX","slug":"技术/jQuery-AJAX","permalink":"http://yoursite.com/categories/技术/jQuery-AJAX/"}],"tags":[{"name":"jQuery-AJAX","slug":"jQuery-AJAX","permalink":"http://yoursite.com/tags/jQuery-AJAX/"}]},{"title":"JavaScript 基础知识总结","slug":"javaScript系列文章","date":"2018-06-23T09:31:49.547Z","updated":"2018-06-12T12:35:07.912Z","comments":true,"path":"2018/06/23/javaScript系列文章/","link":"","permalink":"http://yoursite.com/2018/06/23/javaScript系列文章/","excerpt":"本文主要是一些基础性的知识回顾，后续吧深入理解的东西发表出来。现在先学习基础性的东西吧。 下面是我总结的一些思维导图：","text":"本文主要是一些基础性的知识回顾，后续吧深入理解的东西发表出来。现在先学习基础性的东西吧。 下面是我总结的一些思维导图：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript系列文章","slug":"技术/JavaScript系列文章","permalink":"http://yoursite.com/categories/技术/JavaScript系列文章/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS布局知识","slug":"css布局","date":"2018-06-23T09:31:49.525Z","updated":"2018-06-20T00:10:13.244Z","comments":true,"path":"2018/06/23/css布局/","link":"","permalink":"http://yoursite.com/2018/06/23/css布局/","excerpt":"display设置元素的显示方式 display 默认宽度 可设置宽高 起始位置 block 父元素宽度 是 换行 inline 内容宽度 否 同行 inline-block 内容宽度 是 同行","text":"display设置元素的显示方式 display 默认宽度 可设置宽高 起始位置 block 父元素宽度 是 换行 inline 内容宽度 否 同行 inline-block 内容宽度 是 同行 display:block默认为block的元素：, , ~ , , display:inline默认为inline的元素：, , , , display:inline-block默认为inline-block的元素：&lt;input&gt;, &lt;textarea&gt;, &lt;select&gt;, &lt;button&gt; display:none设置元素不显示 display:none 与 visibility:hidden 的区别为 display:none 不显示且不占位，但 visibility:hidden 不显示但占位。 positionposition 用于设置定位的方式与top right bottom left z-index 则用于设置参照物位置（必须配合定位一同使用）。 三种定位形式 静态定位（static） 相对定位（relative） 绝对定位（absolute、fixed） position:relative相对定位的元素仍在文档流之中，并按照文档流中的顺序进行排列。参照物为元素本身的位置。 最常用的目的为改变元素层级和设置为绝对定位的参照物 position:absolute建立以包含块为基准的定位，其随即拥有偏移属性和 z-index 属性。 默认宽度为内容宽度 脱离文档流 参照物为第一个定位祖先或根元素（ 元素） position:fixed 默认宽度为内容宽度 脱离文档流 参照物为视窗 z-index其用于设置 Z 轴上得排序，默认值为 0 但可设置为负值。（如不做设置，则按照文档流的顺序排列。后面的元素将置于前面的元素之上） floatCSS 中规定的定位机制，其可实现块级元素同行显示并存在于文档流之中。浮动仅仅影响文档流中下一个紧邻的元素。 clearclear: both | left | right | none | inherit 应用于后续元素 应用于块级元素（block） 使用方法： 优先级自上而下 clearfix 于父元素 浮动后续空白元素 .emptyDiv {clear: both} 为受到影响的元素设置 width: 100% overflow: hidden 也可 块级元素可以使用 不建议使用，影响 HTML 结构 flex专门文章介绍了，在这里不做介绍。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"css布局","slug":"技术/css布局","permalink":"http://yoursite.com/categories/技术/css布局/"}],"tags":[{"name":"css布局","slug":"css布局","permalink":"http://yoursite.com/tags/css布局/"}]},{"title":"CSS 实现各种居中","slug":"CSS实现各种居中方法","date":"2018-06-23T09:31:49.501Z","updated":"2018-06-14T14:15:55.931Z","comments":true,"path":"2018/06/23/CSS实现各种居中方法/","link":"","permalink":"http://yoursite.com/2018/06/23/CSS实现各种居中方法/","excerpt":"一、水平居中1、行内元素居中 顾名思义，行内元素居中是只针对行内元素的，比如文本（text）、图片（img）、按钮等行内元素，可通过给父元素设置 text-align:center 来实现。另外，如果块状元素属性display 被设置为inline时，也是可以使用这种方法。但有个首要条件是子元素必须没有被float影响，否则一切都是无用功。 1234 .div1&#123; text-align:center; &#125;&lt;div class=\"div1\"&gt;Hello world&lt;/div&gt;","text":"一、水平居中1、行内元素居中 顾名思义，行内元素居中是只针对行内元素的，比如文本（text）、图片（img）、按钮等行内元素，可通过给父元素设置 text-align:center 来实现。另外，如果块状元素属性display 被设置为inline时，也是可以使用这种方法。但有个首要条件是子元素必须没有被float影响，否则一切都是无用功。 1234 .div1&#123; text-align:center; &#125;&lt;div class=\"div1\"&gt;Hello world&lt;/div&gt; 2、块状元素居中（1）、定宽块状元素居中 满足定宽（块状元素的宽度width为固定值）和块状两个条件的元素可以通过设置“左右margin”值为“auto”来实现居中。 123456 .div1&#123; width:200px; border:1px solid red; margin:0 auto; &#125;&lt;div class=\"div1\"&gt;Hello world&lt;/div&gt; （2）、不定宽块状元素居中在实际工作中我们会遇到需要为“不定宽度的块状元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。(不定宽块状元素：块状元素的宽度width不固定。) 有三种方法可以对不定宽块状元素进行居中： 方法1： 将要显示的元素加入到 table 标签当中，然后为 table 标签设置“左右margin”值为“auto”来实现居中； 或使用 display : table；然后设该元素“左右margin”值为“auto”来实现居中。后面的display:table; 方法会更简洁。 为什么加入table标签? 是利用table标签的长度自适应性—即不定义其长度也不默认父元素body的长度（table其长度根据其内文本长度决定），因此可以看做一个定宽度块元素，然后再利用定宽度块状居中的margin的方法，使其水平居中。 12345678910111213141516table&#123; margin:0 auto;&#125;&lt;div&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt; &lt;ul&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt; 123456789.wrap&#123; background:#ccc; display:table; margin:0 auto;&#125;&lt;div class=\"wrap\"&gt; Hello world &lt;/div&gt; 方法2： 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。 这种方法相比第一种方法的优势是不用增加无语义标签，但也存在着一些问题：它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值（变成inline-block就可以设置宽高）。 12345678910111213141516.container&#123; text-align:center; &#125;.container ul&#123; list-style:none; margin:0; padding:0; display:inline; //怎么这一句用不用都是一样效果的？ &#125;&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 方法3： 通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。 先设置父元素wrap清除浮动，然后左浮动。定位让wrap向右偏移50%。然后定义子元素相对于父元素向左偏移50%。脱离父元素。加个边框就可以明白一些了。另外用绝对定位也是可以的。123456789101112131415 .wrap&#123; float:left; position:relative; left:50%; clear:both;&#125;.wrap-center&#123; background:#ccc; position:relative; left:-50%;&#125;&lt;div class=\"wrap\"&gt; &lt;div class=\"wrap-center\"&gt;Hello world&lt;/div&gt;&lt;/div&gt; 二、垂直居中垂直居中可分为父元素高度确定的单行文本，以及父元素高度确定的多行文本。 1、父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高，指在文本中，行与行之间的 基线间的距离 )。 12345678910.wrap h2&#123; margin:0; height:100px; line-height:100px; background:#ccc;&#125;&lt;div class=\"wrap\"&gt; &lt;h2&gt;Hello world&lt;/h2&gt;&lt;/div&gt; 2、父元素高度确定的多行文本 有两种方法： 方法1：使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。 css12345678910111213141516171819.wrap&#123; height:300px; background:#ccc; vertical-align:middle; /* td 标签默认情况下就默认设置了 vertical-align 为 middle，可以不需要显式地设置 */&#125;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"wrap\"&gt; &lt;div&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 方法2： 设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性。但这种方法兼容性比较差， IE6、7 并不支持这个样式。 12345678910111213.wrap&#123; height:300px; background:#ccc; display:table-cell;/*IE8以上及Chrome、Firefox*/ vertical-align:middle;/*IE8以上及Chrome、Firefox*/&#125;&lt;div class=\"wrap\"&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt;&lt;/div&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"css","slug":"技术/前端基础知识/css","permalink":"http://yoursite.com/categories/技术/前端基础知识/css/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"居中","slug":"居中","permalink":"http://yoursite.com/tags/居中/"}]},{"title":"CSS3","slug":"CSS3","date":"2018-06-23T09:31:49.479Z","updated":"2018-06-19T02:54:14.788Z","comments":true,"path":"2018/06/23/CSS3/","link":"","permalink":"http://yoursite.com/2018/06/23/CSS3/","excerpt":"引入方式：1、内联方式 Inline Styles 这一行的字体颜色将显示为红色 2、内部样式块对象 Embedding a Style Block 12345&lt;style&gt; .test2 &#123; color: #000; &#125;&lt;/style&gt;","text":"引入方式：1、内联方式 Inline Styles 这一行的字体颜色将显示为红色 2、内部样式块对象 Embedding a Style Block 12345&lt;style&gt; .test2 &#123; color: #000; &#125;&lt;/style&gt; 3、外部样式表 Linking to a Style Sheet 你可以先建立外部样式表文件*.css，然后使用 HTML 的 link 对象。或者使用 @import 来引入。 示例代码： 1234567&lt;!-- Use link elements --&gt;&lt;link rel=\"stylesheet\" href=\"core.css\"&gt;&lt;!-- Use @imports --&gt;&lt;style&gt; @import url(\"more.css\");&lt;/style&gt; 二、选择器权重权重主要分为 4 个等级： 第一等：代表内联样式，如: style=””，权值为1000 第二等：代表ID选择器，如：#content，权值为100 第三等：代表类，伪类和属性选择器，如.content，权值为10 第四等：代表类型选择器和伪元素选择器，如div p，权值为1 动画CSS3 @keyframes 规则要创建CSS3动画，你将不得不了解@keyframes规则。@keyframes规则是用来创建动画。 @keyframes规则内指定一个 CSS样式和动画将逐步从目前的样式更改为新的样式。 CSS3 动画当在@keyframe创建动画，把它绑定到一个选择器，否则动画不会有任何效果。指定至少这两个 CSS3 的动画属性绑定向一个选择器： 规定动画的名称 规定动画的时长 例子： 12345#animated_div &#123; animation: animated_div 5s infinite; -moz-animation: animated_div 5s infinite; -webkit-animation: animated_div 5s infinite;&#125; 常用属性 第一部分：CSS Transition在CSS 3引入Transition（过渡）这个概念之前，CSS是没有时间轴的。也就是说，所有的状态变化，都是即时完成。 123456789img&#123; height:15px; width:15px;&#125;img:hover&#123; height: 450px; width: 450px;&#125; transition的作用在于，指定状态变化所需要的时间。 123img&#123; transition: 1s;&#125; 我们还可以指定transition适用的属性，比如只适用于height。 123img&#123; transition: 1s height;&#125; transition-delay在同一行transition语句中，可以分别指定多个属性。 123img&#123; transition: 1s height, 1s width;&#125; 我们希望，让height先发生变化，等结束以后，再让width发生变化。实现这一点很容易，就是为width指定一个delay参数。123img&#123; transition: 1s height, 1s 1s width;&#125; transition-timing-functionransition的状态变化速度（又称timing function），默认不是匀速的，而是逐渐放慢，这叫做ease。 除了ease以外，其他模式还包括: （1）linear：匀速 （2）ease-in：加速 （3）ease-out：减速 （4）cubic-bezier函数：自定义速度模式 transition的各项属性:transition的完整写法如下 123img&#123; transition: 1s 1s height ease;&#125; transition的局限transition的优点在于简单易用，但是它有几个很大的局限。 （1）transition需要事件触发，所以没法在网页加载时自动发生。 （2）transition是一次性的，不能重复发生，除非一再触发。 （3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 （4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 CSS Animation就是为了解决这些问题而提出的。 第二部分：CSS Animation首先，CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。123div:hover &#123; animation: 1s rainbow;&#125; 上面代码表示，当鼠标悬停在div元素上时，会产生名为rainbow的动画效果，持续时间为1秒。为此，我们还需要用keyframes关键字，定义rainbow效果。 12345@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 默认情况下，动画只播放一次。加入infinite关键字，可以让动画无限次播放。 123div:hover &#123; animation: 1s rainbow infinite;&#125; 也可以指定动画具体播放的次数，比如3次。 123div:hover &#123; animation: 1s rainbow 3;&#125; animation-fill-mode动画结束以后，会立即从结束状态跳回到起始状态。如果想让动画保持在结束状态，需要使用animation-fill-mode属性。123div:hover &#123; animation: 1s rainbow forwards;&#125; forwards表示让动画停留在结束状态，效果如下。 animation-fill-mode还可以使用下列值: （1）none：默认值，回到动画没开始时的状态。 （2）backwards：让动画回到第一帧的状态。 （3）both: 根据animation-direction（见后）轮流应用forwards和backwards规则。 animation-direction动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变这种行为。 下面看一个例子，来说明如何使用animation-direction。假定有一个动画是这样定义的。 1234@keyframes rainbow &#123; 0% &#123; background-color: yellow; &#125; 100% &#123; background: blue; &#125;&#125; 默认情况是，animation-direction等于normal。此外，还可以等于取alternate、reverse、alternate-reverse等值。它们的含义见下图（假定动画连续播放三次）。简单说，animation-direction指定了动画播放的方向，最常用的值是normal和reverse。浏览器对其他值的支持情况不佳，应该慎用。 animation的各项属性同transition一样，animation也是一个简写形式。 123div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125; 下面来介绍下边框：CSS3 Border（边框）主要有以下属性： border-radius box-shadow border-image border-radius （圆角边框） 1border-radius: 25px; box-shadow （边框阴影）1box-shadow: 15px 15px 5px #888245; border-image （边框图片） 1234-moz-border-image: url(/images/border.png) 30 30 round; /* Firefox */ -webkit-border-image: url(/images/border.png) 30 30 round; /* Safari and Chrome */ -o-border-image: url(/images/border.png) 30 30 round; /* Opera */ border-image: url(/images/border.png) 30 30 round; 接下来是背景知识：主要是2个背景属性： background-size background-origin background-size 该属性规定背景图片的尺寸。在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以规定背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。您能够以像素或百分比规定尺寸。如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。 background-origin 该属性指定了背景图像的位置区域。content-box, padding-box,和 border-box 区域内可以放置背景图像。 字体以前 CSS3 的版本，网页设计师不得不使用用户计算机上已经安装的字体。使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。您所选择的字体在新的 CSS3 版本有关于@font-face规则描述。您”自己的”的字体是在 CSS3 @font-face 规则中定义的。 在 @font-face 规则中，您必须首先定义字体的名称（比如 FontAwesome ），然后指向该字体文件 fontawesome-webfont.woff 。 1234@font-face &#123; font-family: 'FontAwesome'; src: url('fonts/fontawesome-webfont.woff');&#125; 文本效果SS3 文本效果是这样一个术语用来在正常的文本中实现一些额外的特性。主要是两个属性的 CSS3 文本效果,如下: text-shadow word-wrap text-shadow 文本阴影。 您指定了水平阴影，垂直阴影，模糊的距离，以及阴影的颜色：123.text-shadow &#123; text-shadow: 10px 10px 10px #6AAFCF;&#125; word-wrap换行。 CSS3中，自动换行属性允许您强制文本换行 - 即使这意味着分裂它中间的一个字： 12345.word-wrap &#123; word-wrap: break-word; width: 150px; border: 1px solid #ff0000;&#125; 2D 转换CSS3 2D转换，我们可以斜拉(skew)，缩放(scale)，旋转(rotate)以及位移(translate)元素。 常用 2D 变换方法： translate() rotate() scale() skew() matrix() translate()translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动 rotate()rotate()方法，在一个给定度数沿着元素中心顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。 123456.rotate&#123; transform:rotate(30deg); -ms-transform:rotate(30deg); /* IE 9 */ -webkit-transform:rotate(30deg); /* Safari and Chrome */&#125; scale()scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数：123456.scale&#123; transform: scale(2,4); -ms-transform: scale(2,4); /* IE 9 */ -webkit-transform: scale(2,4); /* Safari and Chrome */&#125; skew()skew()方法，该元素会根据横向（X轴）和垂直（Y轴）线参数给定角度：123456.skew&#123; transform:skew(30deg,20deg); -ms-transform:skew(30deg,20deg); /* IE 9 */ -webkit-transform:skew(30deg,20deg); /* Safari and Chrome */&#125; matrix()matrix()方法和2D变换方法合并成一个。matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。 3D 转换CSS3 3D Transform,用于 3 维动画或旋转。CSS3 3D 转换是一个属性,用于改变元素的实际形式。这个特性可以改变元素的形状、大小和位置。主要有下列方法： rotateX() rotateY() rotateZ() 注意：Internet Explorer 10 和 Firefox 支持 3D 转换； Chrome 和 Safari 必须添加前缀 -webkit-； Opera 还不支持 3D 转换(支持 2D 转换 ) rotateX()rotateX()方法，围绕其在一个给定度数X轴旋转的元素。1234.rotate-x &#123; transform: rotateX(60deg); -webkit-transform: rotateX(120deg); /* Safari and Chrome */&#125; y、z轴 类似。 rotate3d()otate3d(x,y,z,a)中取值说明： x：是一个0到１之间的数值，主要用来描述元素围绕X轴旋转的矢量值； y：是一个０到１之间的数值，主要用来描述元素围绕Y轴旋转的矢量值； z：是一个０到１之间的数值，主要用来描述元素围绕Z轴旋转的矢量值； a：是一个角度值，主要用来指定元素在3D空间旋转的角度，如果其值为正值，元素顺时针旋转，反之元素逆时针旋转。 面介绍的三个旋转函数功能等同： &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"css3","slug":"技术/前端基础知识/css3","permalink":"http://yoursite.com/categories/技术/前端基础知识/css3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"Chrome DevTools 技巧","slug":"Chrome DevTools技巧2","date":"2018-06-23T09:31:49.435Z","updated":"2018-06-21T02:00:14.982Z","comments":true,"path":"2018/06/23/Chrome DevTools技巧2/","link":"","permalink":"http://yoursite.com/2018/06/23/Chrome DevTools技巧2/","excerpt":"","text":"1、调试窗口切换： mac： command+alt+i win: F12 2、页面元素调试 保持住 hover 的状态，右键可以看到 hover: 单击选中即可。 3、元素状态改变的监控方法 右键 4、样式调试 盒模型调试 5、查看元素最终样式 选 computed 6、元素事件监听查看 event Listeners 7、console 8、如何查看被压缩 js css 的源码 点下面的{} format 9、查看整站加载的资源 sources 10、调试 JavaScript 的 call stack 堆栈 11、编辑源文件同步到本地文件里 source—-filesystem—+ ——添加本地文件 12、网络请求监控 network 13、监控页面重绘的方法 More tools—-Rendering—-paint flashing 14、如何监控并统计没有使用的脚本 More tools—-coverage —点小黑点变红 15、如何监控页面的动画变更 More tools—-Animation 16、网络条件与 user-Agent 的设置 More tools—-Network condition 17、快速以编辑状态查看一个站点加载的所有资源 scource—-ctr+p 18、调试 Android 设备的方法 More tools—Remote devices 19、如何让浏览器阻止请求某些资源 More tools–Request blocking 用正则的方法css 去掉包含css的文件 ad 去掉广告 20、如何对站点下所有的资源进行全部搜索 More tools–Search 21、如何在浏览器中模拟一些传感器数据 22、性能分析 Performance CPU设置 recoding 帧率fps 一秒改变多少 页面加载的过程中那部分比较卡 Call Tree 跳到源码里看看哪里比较耗时。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Chrome DevTools","slug":"技术/Chrome-DevTools","permalink":"http://yoursite.com/categories/技术/Chrome-DevTools/"}],"tags":[{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://yoursite.com/tags/Chrome-DevTools/"}]},{"title":"Chrome DevTools 技巧","slug":"Chrome DevTools技巧","date":"2018-06-23T09:31:49.384Z","updated":"2018-06-12T12:21:09.152Z","comments":true,"path":"2018/06/23/Chrome DevTools技巧/","link":"","permalink":"http://yoursite.com/2018/06/23/Chrome DevTools技巧/","excerpt":"1、拖拽面板中的元素","text":"1、拖拽面板中的元素 2、在控制台控制选中的元素 3、添加CSS并编辑元素的状态在元素面板有两个很好用的按钮add css: 4、找到css属性被定义在什么位置ctrl-click on Windows ctrl 键点击属性，可以定位","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Chrome DevTools","slug":"技术/Chrome-DevTools","permalink":"http://yoursite.com/categories/技术/Chrome-DevTools/"}],"tags":[{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://yoursite.com/tags/Chrome-DevTools/"}]},{"title":"CSS 媒体查询","slug":"前端基础知识整理6","date":"2018-06-11T13:08:25.000Z","updated":"2018-06-12T12:22:09.690Z","comments":true,"path":"2018/06/11/前端基础知识整理6/","link":"","permalink":"http://yoursite.com/2018/06/11/前端基础知识整理6/","excerpt":"&ensp; &ensp;所谓的媒体查询就是指，不同的条件使用不同的样式或样式集合。 @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式","text":"&ensp; &ensp;所谓的媒体查询就是指，不同的条件使用不同的样式或样式集合。 @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式 一、CSS 语法 device-width 和 width的区别： device-width表示的是设备的宽度，即屏幕的宽度。width所代表的是文档宽度，与屏幕大小没有关系，如果是在移动设备上，width表示的是布局视口的宽度。 必要的空格。 12//空格是有必要的，在某些情况下该样式永远不起作用。&lt;link rel=\"stylesheet\" media=\"(min-device-width:400px)【空格】and【空格】(max-device-width:900px)\" href=\"css/style1.css\"&gt; 语法示例： 12345678910&lt;!-- link元素中的CSS媒体查询 --&gt;&lt;link rel=\"stylesheet\" media=\"(max-width: 800px)\" href=\"example.css\" /&gt; //对什么状况下使用&lt;!-- 样式表中的CSS媒体查询 --&gt;&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 二、可供媒体查询检测的特性 width:视口宽度 height:视口高度 device-width:设备屏幕的宽度 device-height:设备屏幕的高度 orientation:检测设备处于横向还是纵向 aspect-radio:基于视口宽度和高度的宽高比 device-sapect-radio:基于设备渲染平面宽度和高度的宽高比 color:每种颜色的位数 color-index:设备的颜色索引表中的颜色数 monochrome:检测单色帧缓冲区中每像素所使用的位数 resolution:用来检测屏幕或打印机的分辨率， scan:电视机的烧苗方式，值可设为progressive(逐行扫描)或interlace(隔行扫描) 用来检测输出设备是网格设备还是位图设备 三、逻辑操作 and，且的关系，当所有的条件满足的时候返回true12345678//一个基本的媒体查询，即一个媒体属性和默认指定的all媒体类型@media (min-width:700px)&#123;&#125;//如果你只想再横屏时候应用,你可以使用and操作符合并媒体属性(min-width:700px)and(orientation:landscape)&#123;&#125;//如果你仅想在电视媒体上应用@media tv and (min-width:700px) and (orientation:landscape)&#123;&#125; 逗号分割列表，或的关系，只要有条件满足就返回ture not，类似于取反，最后参与运算的运算符 only，only关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"媒体查询","slug":"技术/前端基础知识/媒体查询","permalink":"http://yoursite.com/categories/技术/前端基础知识/媒体查询/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"媒体查询","slug":"媒体查询","permalink":"http://yoursite.com/tags/媒体查询/"}]},{"title":"CSS 弹性盒子Flexbox","slug":"前端基础知识整理5","date":"2018-06-11T13:08:25.000Z","updated":"2018-06-12T07:11:23.380Z","comments":true,"path":"2018/06/11/前端基础知识整理5/","link":"","permalink":"http://yoursite.com/2018/06/11/前端基础知识整理5/","excerpt":"&ensp; &ensp;布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 一、Flex 布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。","text":"&ensp; &ensp;布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 一、Flex 布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 ####二、基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 ####三、容器的属性 以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.flex-direction flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端 flex-flow column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 2.flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 4.justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5.align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6.align-content属性123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1.order属性123.item &#123; order: &lt;integer&gt;;&#125; 4.2.flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"Flexbox","slug":"技术/前端基础知识/Flexbox","permalink":"http://yoursite.com/categories/技术/前端基础知识/Flexbox/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Flexbox","slug":"Flexbox","permalink":"http://yoursite.com/tags/Flexbox/"}]}]}