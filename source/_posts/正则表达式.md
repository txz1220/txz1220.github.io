---
title: 正则表达式
categories:
- 技术
- js
- 正则表达式
tags:
- js
- 正则表达式
---

### 什么是正则

简单来说，正则就可以理解为一个规则，用来处理字符串的一个规则（正则就是用来处理字符串的），这里所说处理一般是包含匹配和捕获。

<!--more-->

- 匹配：判断一个字符串是否符合指定的规则，使用test方法：reg.test(str)

```js
var reg = /\d/; // 包含一个0~9之间的数字
console.log(reg.test('天')); // false
console.log(reg.test('1')); // true
console.log(reg.test('现在是2017')); // true，只要包含了数字就返回true
```

- 捕获：把字符串中符合指定的正则规则的内容捕获到，使用exec方法：reg.exec(str)

```js

var reg = /\d/;
console.log(reg.exec('天')); // null
console.log(reg.exec('1')); // ["1", index: 0, input: "1"]
console.log(reg.exec('现在是2017')); // ["2", index: 3, input: "现在是2017"]
```

### 如何创建正则


字面量方式
```js
var reg = /\d/;
```


实例方式

```js
var reg = new RegExp('/\d/');
```

### 正则的组成

从上面的内容中已经了解到，每一个正则表达式是包含在//中的，正则表达式就是匹配规则，正则的组成就是元字符和修饰符。

#### 元字符

具有特殊意义的元字符

- \：转义字符，转义后面字符所代表的含义
- ^：以某一个元字符开始
- $：以某一个元字符结束
- \n：匹配一个换行符
- .：除了\n以外的任意字符
- \w  匹配字母或数字或下划线或汉字
- \s  匹配任意的空白符
- \d  匹配数字
- \b  匹配单词的开始或结束



语法：

- \D  匹配任意非数字的字符
- \B  匹配不是单词开头或结束的位置
- [^x] 匹配除了x以外的任意字符
- [^aeiou] 匹配除了aeiou这几个字母以外的任意字符


如果就是想要匹配 . 或者?这样的字符呢？
转义字符 \
\.  \*  \?




```js

var reg = /^0.2$/; // 以0开头，以2结尾，中间可以是除了\n的任意字符
console.log(reg.test('0.2')); // true
console.log(reg.test('0-2')); // true

reg = /^0\.2$/; // 将"."转义
console.log(reg.test('0.2')); // true
console.log(reg.test('0-2')); // false
```


代表出现次数的量词元字符

- *：出现0到多次
- +：出现1到多次
- ?：出现0次或者1次
- {n}：出现n次
- {n,m}：出现n到m次

```js
var reg = /^\d+$/;
console.log(reg.test('2015')); // true
```


### 修饰符


- x|y：x或y中的一个   
- [xyz]：x或y或z中的一个
- [^xyz]：除了xyz以外的任意一个字符
- [a-z]：a-z之间的任何一个字符
- [^a-z]：除了a-z之间的任何一个字符
- \d：一个0~9之间的数字
- \D：除了0~9之间的数字以外的任何字符
- \b：一个边界符
- \w：数字、字母、下划线中的任意一个字符
- \s：匹配一个空白字符、空格
- ()：分组，把一个大正则本身划分成几个小的正则，例如：var reg = /^(\d+)zhufeng(\d+)$/;


### 分枝条件

- 用|把不同的规则分隔开
- 从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了
- 0\d{2}-\d{8}|0\d{3}-\d{7}





### 元字符的应用

[]的规律

在中括号中出现的所有的字符都是代表本身的意思的字符（没有特殊含义）  

```js
var reg = /^[.]$/;
  console.log(reg.test('1')); // false
  console.log(reg.test('.')); // true

  reg = /^[\w-]$/; // 数字、字母、下划线、- 中的一个
  console.log(reg.test('-')); // true
```


中括号不识别两位数

```js
var reg = /^[12]$/; // --> 1或者2中的一个（符合[xyz]）
var reg = /^[12-68]$/; // --> 1、2-6中的一个、8  三个中的一个
```

### ()的作用

分组的作用有很多，现在先讲其中的一个：改变x|y的默认的优先级，还有的在后面的内容会详细介绍。

```js
var reg = /^18|19$/; // 18、19、181、189、119、819、1819这些都符合
var reg = /^(18|19)$/; // 只能18或者19
```

### 应用一：有效数字的正则


有效数字可以是正数、负数、零、小数，所以其特点为：

- "."可以出现也可以不出现，一旦出现，后面必须跟着一位或多为数字；

- 最开始可能有“+/-”，也可以没有；

- 整数部分，一位数的情况可以是0-9中的一个，多位数的情况下不能以0开头

```js
var reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;
```


### 应用二：年龄介于18~65之间

年龄介于18~65之间的数字可以是18-19、20-59、60-65。

```js
var reg = /^1[8-9]|[2-5]\d|6[0-5]$/;
```

### 应用三：简单的邮箱验证

```js
var reg = /^[\w.-]+@[0-9a-zA-Z]+(\.[a-zA-Z]{2,4}){1,2}$/;
```

### 两种方式创建正则的区别

- 字面量方式中出现的一切都是元字符，不能进行变量值的拼接，而实例创建的方式可以；

- 字面量方式中直接写\d可以，而在实例中需要把它转义 \\d



### 正则的捕获及其贪婪性和懒惰性

在上面有介绍到正则的捕获使用exec方法。在每一次捕获的时候都是先进行默认的匹配，如果没有匹配成功，则捕获的结果是null。只有有匹配的内容，才能捕获到。

#### 懒惰性

定义正则及字符串：

```js
var reg = /\d+/;
var str = 'iceman2016learn2017';
```
reg默认有一个lastIndex字段，该字段是正则每一次捕获时，在字符串中开始查找的位置，默认的值是0。

现在先进行第一次捕获：

```js
console.log(reg.lastIndex); // 0，第一次捕获的时候，从字符串索引0处开始查找
var res = reg.exec(str);
console.log(res); // ["2016", index: 6, input: "iceman2016learn2017"]
```

从代码的输出可知，正则捕获的内容格式：捕获到的内容是一个数组

- 数组的第一项是当前大正则捕获的内容；
- 有一项是index：捕获内容在字符串中开始的索引位置；
- 有一项是input：捕获的原始字符串；



现在进行第二次捕获：

```js
console.log(reg.lastIndex); // 0  说明第二次捕获的时候，也要从字符串索引0处开始查找
// 第二次通过exec捕获的内容还是第一个"2016"
res = reg.exec(str);
console.log(res); //["2016", index: 6, input: "iceman2016learn2017"]
```

由上面的两次捕获可知，每次的捕获都是从字符串的索引0处开始查找的，这就是正则的懒惰型。


很明显正则的懒惰性是我们所要解决的问题，那么该如何解决懒惰性呢？ 答案就是在正则的末尾加一个修饰“g”（全局匹配），类似g这样的修饰符还有两个：i、m，这三者的作用是：

- global（g）：全局匹配

- ignoreCase（i）：忽略大小写

- multiline（m）：多行匹配


```js
var reg = /\d+/g;
var str = 'iceman2016learn2017';
console.log(reg.lastIndex); // 0
console.log(reg.exec(str)); // ["2016", index: 6, input: "iceman2016learn2017"]

console.log(reg.lastIndex); // 10
console.log(reg.exec(str)); // ["2017", index: 15, input: "iceman2016learn2017"]

console.log(reg.lastIndex); // 19
console.log(reg.exec(str)); // null
```



### 贪婪性


```js
var reg = /\d+/g; // 出现一到多个0~9之间的数字
var str = 'iceman2016learn2017javascript2018';
console.log(reg.exec(str)); // ["2016", index: 6, input: "iceman2016learn2017javascript2018"]
```


看到这段代码的时候不知道您有没有一些疑惑，正则的内容是/\d+/，是匹配1到多个数字，2016是符合正则的，那么2也是符合正则的啊，为什么默认就捕获了2016呢？ 这就是正则的贪婪性。


如何解决正则的贪婪性：在量词元字符后面添加一个"?"即可


```js
var reg = /\d+?/g; // 出现一到多个0~9之间的数字
var str = 'iceman2016learn2017javascript2018';
console.log(reg.exec(str)); // ["2", index: 6, input: "iceman2016learn2017javascript2018"]
var ary = [] , res = reg.exec(str);
while (res) {
    ary.push(res[0]);
    res = reg.exec(str)
}
console.log(ary); // ["0", "1", "6", "2", "0", "1", "7", "2", "0", "1", "8"]
```


"?"在正则中的作用：

- 放在一个普通的元字符后面，代表出现0~1次；

- 放在一个量词的元字符后面，取消捕获时候的贪婪性；


### 字符串中的match方法


match方法的作用是，把所有和正则匹配的字符都获取到。

```js
var reg = /\d+?/g;
var str = 'zhufeng2015peixun2016dasgdas2017';
var ary = str.match(reg);
console.log(ary); // ["2", "0", "1", "5", "2", "0", "1", "6", "2", "0", "1", "7"]
```

>虽然在当前的情况下，match比exec更加的简洁一些，但是match存在一些自己处理不了的问题：在分组捕获的情况下，match只能捕获到大正则，而对于小正则捕获的内容是无法获取的。


### 分组捕获

