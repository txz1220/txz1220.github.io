---
title: 正则表达式
categories:
- 技术
- js
- 正则表达式
tags:
- js
- 正则表达式
---

### 什么是正则

简单来说，正则就可以理解为一个规则，用来处理字符串的一个规则（正则就是用来处理字符串的），这里所说处理一般是包含匹配和捕获。

<!--more-->

- 匹配：判断一个字符串是否符合指定的规则，使用test方法：reg.test(str)

```js
var reg = /\d/; // 包含一个0~9之间的数字
console.log(reg.test('天')); // false
console.log(reg.test('1')); // true
console.log(reg.test('现在是2017')); // true，只要包含了数字就返回true
```

- 捕获：把字符串中符合指定的正则规则的内容捕获到，使用exec方法：reg.exec(str)

```js

var reg = /\d/;
console.log(reg.exec('天')); // null
console.log(reg.exec('1')); // ["1", index: 0, input: "1"]
console.log(reg.exec('现在是2017')); // ["2", index: 3, input: "现在是2017"]
```

### 如何创建正则


字面量方式
```js
var reg = /\d/;
```


实例方式

```js
var reg = new RegExp('/\d/');
```

### 正则的组成

从上面的内容中已经了解到，每一个正则表达式是包含在//中的，正则表达式就是匹配规则，正则的组成就是元字符和修饰符。

#### 元字符

具有特殊意义的元字符

- \：转义字符，转义后面字符所代表的含义
- ^：以某一个元字符开始
- $：以某一个元字符结束
- \n：匹配一个换行符
- .：除了\n以外的任意字符
- \w  匹配字母或数字或下划线或汉字
- \s  匹配任意的空白符
- \d  匹配数字
- \b  匹配单词的开始或结束



语法：

- \D  匹配任意非数字的字符
- \B  匹配不是单词开头或结束的位置
- [^x] 匹配除了x以外的任意字符
- [^aeiou] 匹配除了aeiou这几个字母以外的任意字符


如果就是想要匹配 . 或者?这样的字符呢？
转义字符 \
\.  \*  \?




```js

var reg = /^0.2$/; // 以0开头，以2结尾，中间可以是除了\n的任意字符
console.log(reg.test('0.2')); // true
console.log(reg.test('0-2')); // true

reg = /^0\.2$/; // 将"."转义
console.log(reg.test('0.2')); // true
console.log(reg.test('0-2')); // false
```


代表出现次数的量词元字符

- *：出现0到多次
- +：出现1到多次
- ?：出现0次或者1次
- {n}：出现n次
- {n,m}：出现n到m次

```js
var reg = /^\d+$/;
console.log(reg.test('2015')); // true
```


### 修饰符


- x|y：x或y中的一个   
- [xyz]：x或y或z中的一个
- [^xyz]：除了xyz以外的任意一个字符
- [a-z]：a-z之间的任何一个字符
- [^a-z]：除了a-z之间的任何一个字符
- \d：一个0~9之间的数字
- \D：除了0~9之间的数字以外的任何字符
- \b：一个边界符
- \w：数字、字母、下划线中的任意一个字符
- \s：匹配一个空白字符、空格
- ()：分组，把一个大正则本身划分成几个小的正则，例如：var reg = /^(\d+)zhufeng(\d+)$/;


### 分枝条件

- 用|把不同的规则分隔开
- 从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了
- 0\d{2}-\d{8}|0\d{3}-\d{7}





### 元字符的应用

[]的规律

在中括号中出现的所有的字符都是代表本身的意思的字符（没有特殊含义）  

```js
var reg = /^[.]$/;
  console.log(reg.test('1')); // false
  console.log(reg.test('.')); // true

  reg = /^[\w-]$/; // 数字、字母、下划线、- 中的一个
  console.log(reg.test('-')); // true
```


中括号不识别两位数

```js
var reg = /^[12]$/; // --> 1或者2中的一个（符合[xyz]）
var reg = /^[12-68]$/; // --> 1、2-6中的一个、8  三个中的一个
```

### ()的作用

分组的作用有很多，现在先讲其中的一个：改变x|y的默认的优先级，还有的在后面的内容会详细介绍。

```js
var reg = /^18|19$/; // 18、19、181、189、119、819、1819这些都符合
var reg = /^(18|19)$/; // 只能18或者19
```

### 应用一：有效数字的正则


有效数字可以是正数、负数、零、小数，所以其特点为：

- "."可以出现也可以不出现，一旦出现，后面必须跟着一位或多为数字；

- 最开始可能有“+/-”，也可以没有；

- 整数部分，一位数的情况可以是0-9中的一个，多位数的情况下不能以0开头

```js
var reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;
```


### 应用二：年龄介于18~65之间

年龄介于18~65之间的数字可以是18-19、20-59、60-65。

```js
var reg = /^1[8-9]|[2-5]\d|6[0-5]$/;
```

### 应用三：简单的邮箱验证

```js
var reg = /^[\w.-]+@[0-9a-zA-Z]+(\.[a-zA-Z]{2,4}){1,2}$/;
```

### 两种方式创建正则的区别

- 字面量方式中出现的一切都是元字符，不能进行变量值的拼接，而实例创建的方式可以；

- 字面量方式中直接写\d可以，而在实例中需要把它转义 \\d



### 正则的捕获及其贪婪性和懒惰性

在上面有介绍到正则的捕获使用exec方法。在每一次捕获的时候都是先进行默认的匹配，如果没有匹配成功，则捕获的结果是null。只有有匹配的内容，才能捕获到。

#### 懒惰性

定义正则及字符串：

```js
var reg = /\d+/;
var str = 'iceman2016learn2017';
```
reg默认有一个lastIndex字段，该字段是正则每一次捕获时，在字符串中开始查找的位置，默认的值是0。

现在先进行第一次捕获：

```js
console.log(reg.lastIndex); // 0，第一次捕获的时候，从字符串索引0处开始查找
var res = reg.exec(str);
console.log(res); // ["2016", index: 6, input: "iceman2016learn2017"]
```

从代码的输出可知，正则捕获的内容格式：捕获到的内容是一个数组

- 数组的第一项是当前大正则捕获的内容；
- 有一项是index：捕获内容在字符串中开始的索引位置；
- 有一项是input：捕获的原始字符串；



现在进行第二次捕获：

```js
console.log(reg.lastIndex); // 0  说明第二次捕获的时候，也要从字符串索引0处开始查找
// 第二次通过exec捕获的内容还是第一个"2016"
res = reg.exec(str);
console.log(res); //["2016", index: 6, input: "iceman2016learn2017"]
```

由上面的两次捕获可知，每次的捕获都是从字符串的索引0处开始查找的，这就是正则的懒惰型。


很明显正则的懒惰性是我们所要解决的问题，那么该如何解决懒惰性呢？ 答案就是在正则的末尾加一个修饰“g”（全局匹配），类似g这样的修饰符还有两个：i、m，这三者的作用是：

- global（g）：全局匹配

- ignoreCase（i）：忽略大小写

- multiline（m）：多行匹配


```js
var reg = /\d+/g;
var str = 'iceman2016learn2017';
console.log(reg.lastIndex); // 0
console.log(reg.exec(str)); // ["2016", index: 6, input: "iceman2016learn2017"]

console.log(reg.lastIndex); // 10
console.log(reg.exec(str)); // ["2017", index: 15, input: "iceman2016learn2017"]

console.log(reg.lastIndex); // 19
console.log(reg.exec(str)); // null
```



### 贪婪性


```js
var reg = /\d+/g; // 出现一到多个0~9之间的数字
var str = 'iceman2016learn2017javascript2018';
console.log(reg.exec(str)); // ["2016", index: 6, input: "iceman2016learn2017javascript2018"]
```


看到这段代码的时候不知道您有没有一些疑惑，正则的内容是/\d+/，是匹配1到多个数字，2016是符合正则的，那么2也是符合正则的啊，为什么默认就捕获了2016呢？ 这就是正则的贪婪性。


如何解决正则的贪婪性：在量词元字符后面添加一个"?"即可


```js
var reg = /\d+?/g; // 出现一到多个0~9之间的数字
var str = 'iceman2016learn2017javascript2018';
console.log(reg.exec(str)); // ["2", index: 6, input: "iceman2016learn2017javascript2018"]
var ary = [] , res = reg.exec(str);
while (res) {
    ary.push(res[0]);
    res = reg.exec(str)
}
console.log(ary); // ["0", "1", "6", "2", "0", "1", "7", "2", "0", "1", "8"]
```


"?"在正则中的作用：

- 放在一个普通的元字符后面，代表出现0~1次；

- 放在一个量词的元字符后面，取消捕获时候的贪婪性；


### 字符串中的match方法


match方法的作用是，把所有和正则匹配的字符都获取到。

```js
var reg = /\d+?/g;
var str = 'zhufeng2015peixun2016dasgdas2017';
var ary = str.match(reg);
console.log(ary); // ["2", "0", "1", "5", "2", "0", "1", "6", "2", "0", "1", "7"]
```

>虽然在当前的情况下，match比exec更加的简洁一些，但是match存在一些自己处理不了的问题：在分组捕获的情况下，match只能捕获到大正则，而对于小正则捕获的内容是无法获取的。


### 分组捕获

#### 正则分组



正则分组的两个作用：

- 改变优先级

- 分组引用

\2代表和第二个分组出现一模一样（和对应的分组中的内容和值都要一样）的内容，\1代表和第一个分组出现一模一样的内容；

```js
var reg = /^(\w)(\w)\1\2$/;
console.log(reg.test("icic")); // true
console.log(reg.test("r0g_")); // false
```





正则在捕获的时候，不仅仅把大正则匹配的内容捕获到，而且还可以把小分组匹配的内容捕获到。


身份证中的数字都有意义的，比如开头的两位代表省，中间的四位代表...所以对于一个身份中，有必要对其中的数字按照其意义进行分组捕获。

```js
var reg = /^(\d{2})(\d{4})(\d{4})(\d{2})(\d{2})(?:\d{2})(\d)(?:\d|X)$/;
var str = "350324202904190216";
console.log(reg.exec(str));

```

>注意：(?:) 在分组中?:的意思是只匹配不捕获

输出的内容为：["350324200904190216", "35", "0324", "2009", "04", "19", "1", index: 0, input: "350324200904190216"]


### replace基础

```js
var str = 'iceman2016iceman2017';
```

在上面定义的字符串中，现在需要将iceman替换成shoushou，我们知道字符串提供了一个replace方法，那么我们用replace来做一次：

```js
str = str.replace('iceman','shoushou');
console.log(str); // shoushou2016iceman2017
```

从打印的结果可知，并没有实现我们想要的效果，只替换了第一个iceman字符串，看MDN中对于replace方法的定义：

>str.replace(regexp|substr, newSubStr|function)
replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。

由replace的定义可知，匹配模式可以是一个正则的，所以我们用正则试一次：

```js
str = str.replace(/iceman/g, 'shoushou');
console.log(str); // shoushou2016shoushou2017

```


再看replace函数的定义，第二个参数可以是一个函数：

```js
var str = 'iceman2016iceman2017';
str = str.replace(/iceman/g, function () {
    // 第一次执行匿名函数输出arguments的结果：["iceman", 0, "iceman2016iceman2017"]
    // 第二次执行匿名函数输出arguments的结果：["iceman", 10, "iceman2016iceman2017"]
    console.log(arguments);
    return 'shoushou';
});
console.log(str); // shoushou2016shoushou2017
```

从打印结果可知：

- 先按照正则指定的规则，到字符串中把正则匹配的内容捕获到，然后在每一次捕获到之后，都把捕获的内容替换成新的内容；

- 匿名函数执行多少次，取决于正则能在字符串中捕获多少次，在这里正则捕获两次，所以匿名函数也执行两次；

- 每一次执行匿名函数，里面传递的参数值arguments和自己通过exec捕获到的结果是一样的（每一次执行匿名函数，和单独执行exec捕获的内容一致）；

- 小分组捕获的内容，在这里同样可以获取到（所以说，replace和exec原理是一模一样的，比match要强大）

- return的结果是什么，就相当于把当前这一次大正则捕获的内容替换成返回的内容。如果不写return，默认使用undefined来进行替换，如果不想实现替换的话，我们可以把捕获的内容再返回回去 return arguments[0]；


```js
var str = 'iceman2015iceman2016';
var reg = /iceman(\d+)/g;
str = str.replace(reg, function () {
    // 第一次捕获arguments的值：["iceman2015", "2015", 0, "iceman2015iceman2016"]
    // 第二次捕获arguments的值：["iceman2016", "2016", 10, "iceman2015iceman2016"]
     console.log(arguments);
});
```

### replace实战

从上面的介绍中已经知道，正则的捕获有三种方式：正则的exec方法、字符串的match方法、字符串的replace方法。

其中replace是将原有的字符串替换成我们想要的新的字符串，在不适用正则的情况下，执行一次replace只能替换字符串中的一个，而使用正则的话，可以一次批量的把所有的正则匹配的内容都替换掉。



#### 实战一：小写数字替换成大写数字

```js
var str = '今年是2017年'; //
var ary = ['零', '壹', '贰', '叁', '肆', '伍', '陆','柒', '捌', '玖', '拾'];
// 实现替换的话，需要捕获到数字，并且把数字当作ary的索引获取对应的汉字进行替换
str = str.replace(/\d/g, function () {
    /*
     * 第一次执行：大正则捕获的是2，返回的是ary[2] --> '贰'
     * 第二次执行：大正则捕获的是0，返回的是ary[0] --> '零'
     * .....
     */
    return ary[arguments[0]];
});
console.log(str);
```

