{"meta":{"title":"KAIGE","subtitle":null,"description":null,"author":"KAIGE","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"网页响应式开发3","slug":"响应式开发3","date":"2018-06-13T11:16:29.393Z","updated":"2018-06-13T11:24:51.049Z","comments":true,"path":"2018/06/13/响应式开发3/","link":"","permalink":"http://yoursite.com/2018/06/13/响应式开发3/","excerpt":"1、不使用绝对宽度由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。 具体说，CSS代码不能指定像素宽度： 1width: xx%; 或者1width:auto;","text":"1、不使用绝对宽度由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。 具体说，CSS代码不能指定像素宽度： 1width: xx%; 或者1width:auto; 2、相对大小的字体3、设置 box-sizing: border-box字体也不能使用绝对大小（px），而只能使用相对大小（em）。123body &#123; font: normal 100% Helvetica, Arial, sans-serif; &#125; 123h1 &#123; font-size: 1.5em; &#125; 4、流动布局（fluid grid）“流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。 12345678910.main &#123; float: right; width: 70%; &#125; .leftBar &#123; float: left; width: 25%; &#125; float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。 另外，绝对定位（position: absolute）的使用，也要非常小心。 5、选择加载CSS“自适应网页设计”的核心，就是CSS3引入的Media Query模块。 它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 123&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-device-width: 400px)\" href=\"tinyScreen.css\" /&gt; 上面的代码意思是，如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。 6、CSS的@media规则同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 123456789101112@media screen and (max-device-width: 400px) &#123; .column &#123; float: none; width:auto; &#125; #sidebar &#123; display:none; &#125; &#125; 上面的代码意思是，如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）。 7、图片的自适应（fluid image）除了布局和文本，”自适应网页设计”还必须实现图片的自动缩放。 这只要一行CSS代码： 1img &#123; max-width: 100%;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"http://yoursite.com/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"http://yoursite.com/tags/响应式开发/"}]},{"title":"网页响应式开发2","slug":"响应式开发2","date":"2018-06-13T08:32:06.648Z","updated":"2018-06-13T11:25:15.986Z","comments":true,"path":"2018/06/13/响应式开发2/","link":"","permalink":"http://yoursite.com/2018/06/13/响应式开发2/","excerpt":"遵循的一些准则和基础1、在 Viewport 里加 Meta 标签在你 HTML 的&lt;head&gt; 代码里添加 Meta 标签。它可以使 media queries 在不同设备上起作用 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;","text":"遵循的一些准则和基础1、在 Viewport 里加 Meta 标签在你 HTML 的&lt;head&gt; 代码里添加 Meta 标签。它可以使 media queries 在不同设备上起作用 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 2、理解CSS盒模型 3、设置 box-sizing: border-box在 CSS 文件最顶端设置 box-sizing。运用 * 通用选择器使其应用到页面的每个元素上。12345*, *:before, *:after &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;&#125; 4、创建容器一个容器将包含页面所有标签，并控制页面最大宽度. 运用容器，让我们的响应式设计更进了一步！ 5、创建列在移动优先里，列默认均是 block 级别的（可以占满整行的宽度）。不需要额外的样式！ 12345&lt;div class=\"container\"&gt; &lt;div class=\"column\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt;&lt;/div&gt; 6、创建列宽在大屏中，用 float: left 将列水平排列。然后运用 padding 设置相邻两列之间的间隙，忘掉传统的margin吧。 7、创建行列应该包裹在行内，以避免其他元素堆放在其旁边造成布局混乱。否则就会出现广为人知的 clearing 问题。出现之后可以使用由 Nicolas Gallagher 发明的 clearfix 解决。 12345678910111213141516171819&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213.clearfix:before,.clearfix:after &#123; content: \" \"; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 8、相对流（ Flow Opposite ）给你想让它在移动端优先显示，而在大屏幕中右侧显示的列，添加 .flow-opposite 类。 12345678910&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half flow-opposite\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123@media (min-width: 40rem) &#123; .column.flow-opposite &#123; float: right; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"http://yoursite.com/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"http://yoursite.com/tags/响应式开发/"}]},{"title":"Sass学习2","slug":"Sass.1","date":"2018-06-13T04:50:07.856Z","updated":"2018-06-13T07:07:34.096Z","comments":true,"path":"2018/06/13/Sass.1/","link":"","permalink":"http://yoursite.com/2018/06/13/Sass.1/","excerpt":"一、Sass的基本特性 上图非常清楚告诉了大家，Sass 的变量包括三个部分： 1.声明变量的符号“$”2.变量名称3.赋予变量的值","text":"一、Sass的基本特性 上图非常清楚告诉了大家，Sass 的变量包括三个部分： 1.声明变量的符号“$”2.变量名称3.赋予变量的值 1.1普通变量和默认变量：1、普通变量定义之后可以在全局范围内使用。 2、默认变量sass 的默认变量仅需要在值后面加上 !default 即可。 sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。12345$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight; &#125; 1.2变量的调用1.3 全局比那里和局部变量1234567891011121314//SCSS$color: orange !default;//定义全局变量(在选择器、函数、混合宏...的外面定义的变量为全局变量).block &#123; color: $color;//调用全局变量&#125;em &#123; $color: red;//定义局部变量 a &#123; color: $color;//调用局部变量 &#125;&#125;span &#123; color: $color;//调用全局变量&#125; 什么时候声明变量？ 我的建议，创建变量只适用于感觉确有必要的情况下。不要为了某些骇客行为而声明新变量，这丝毫没有作用。只有满足所有下述标准时方可创建新变量： 该值至少重复出现了两次； 该值至少可能会被更新一次； 该值所有的表现都与变量有关（非巧合）。基本上，没有理由声明一个永远不需要更新或者只在单一地方使用变量。 嵌套-选择器嵌套 Sass 中还提供了选择器嵌套功能，但这也并不意味着你在 Sass 中的嵌套是无节制的，因为你嵌套的层级越深，编译出来的 CSS 代码的选择器层级将越深，这往往是大家不愿意看到的一点。这个特性现在正被众多开发者滥用。 Sass 的嵌套分为三种： 选择器嵌套 属性嵌套 伪类嵌套 选择器嵌套假设我们有一段这样的结构：1234567&lt;header&gt;&lt;nav&gt; &lt;a href=“##”&gt;Home&lt;/a&gt; &lt;a href=“##”&gt;About&lt;/a&gt; &lt;a href=“##”&gt;Blog&lt;/a&gt;&lt;/nav&gt;&lt;header&gt; 想选中 header 中的 a 标签，在 Sass 中，就可以使用选择器的嵌套来实现：123456789nav &#123; a &#123; color: red; header &amp; &#123; color:green; &#125; &#125; &#125; 属性嵌套Sass 中还提供属性嵌套，CSS 有一些属性前缀相同，只是后缀不一样，比如：border-top/border-right，与这个类似的还有 margin、padding、font 等属性。假设你的样式中用到了： 1234.box &#123; border-top: 1px solid red; border-bottom: 1px solid green;&#125; 在 Sass 中我们可以这样写：123456.box &#123; border: &#123; top: 1px solid red; bottom: 1px solid green; &#125;&#125; 伪类嵌套1234567891011.clearfix&#123;&amp;:before,&amp;:after &#123; content:\"\"; display: table; &#125;&amp;:after &#123; clear:both; overflow: hidden; &#125;&#125; 避免选择器嵌套： 选择器嵌套最大的问题是将使最终的代码难以阅读。开发者需要花费巨大精力计算不同缩进级别下的选择器具体的表现效果。选择器越具体则声明语句越冗长，而且对最近选择器的引用(&amp;)也越频繁。在某些时候，出现混淆选择器路径和探索下一级选择器的错误率很高，这非常不值得。 混合宏-声明混合宏如果你的整个网站中有几处小样式类似，比如颜色，字体等，在 Sass 可以使用变量来统一处理，那么这种选择还是不错的。但当你的样式变得越来越复杂，需要重复使用大段的样式时，使用变量就无法达到我们目了。这个时候 Sass 中的混合宏就会变得非常有意义。 1、声明混合宏 不带参数混合宏： 在 Sass 中，使用“@mixin”来声明一个混合宏。如： 1234@mixin border-radius&#123; -webkit-border-radius: 5px; border-radius: 5px;&#125; 其中 @mixin 是用来声明混合宏的关键词，有点类似 CSS 中的 @media、@font-face 一样。border-radius 是混合宏的名称。大括号里面是复用的样式代码。 带参数混合宏： 除了声明一个不带参数的混合宏之外，还可以在定义混合宏时带有参数，如：1234@mixin border-radius($radius:5px)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 复杂的混合宏： 上面是一个简单的定义混合宏的方法，当然， Sass 中的混合宏还提供更为复杂的，你可以在大括号里面写上带有逻辑关系，帮助更好的做你想做的事情,如：12345678@mixin box-shadow($shadow...) &#123; @if length($shadow) &gt;= 1 &#123; @include prefixer(box-shadow, $shadow); &#125; @else&#123; $shadow:0 0 4px rgba(0,0,0,.3); @include prefixer(box-shadow, $shadow); &#125;&#125; 混合宏-调用混合宏在 Sass 中通过 @mixin 关键词声明了一个混合宏，那么在实际调用中，其匹配了一个关键词“@include”来调用声明好的混合宏。例如在你的样式中定义了一个圆角的混合宏“border-radius”: 1234@mixin border-radius&#123; -webkit-border-radius: 3px; border-radius: 3px;&#125; 在一个按钮中要调用定义好的混合宏“border-radius”，可以这样使用: 123button &#123; @include border-radius;&#125; 混合宏的参数–传一个不带值的参数1234@mixin border-radius($radius)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 在混合宏“border-radius”中定义了一个不带任何值的参数“$radius”。 在调用的时候可以给这个混合宏传一个参数值：123.box &#123; @include border-radius(3px);&#125; 混合宏的参数–传一个带值的参数Sass 混合宏除了能传一个参数之外，还可以传多个参数，如：123456789@mixin center($width,$height)&#123; width: $width; height: $height; position: absolute; top: 50%; left: 50%; margin-top: -($height) / 2; margin-left: -($width) / 2;&#125; 有一个特别的参数“…”。当混合宏传的参数过多之时，可以使用参数来替代，如： 12345678910@mixin box-shadow($shadows...)&#123; @if length($shadows) &gt;= 1 &#123; -webkit-box-shadow: $shadows; box-shadow: $shadows; &#125; @else &#123; $shadows: 0 0 2px rgba(#000,.25); -webkit-box-shadow: $shadow; box-shadow: $shadow; &#125;&#125; 继承在 Sass 中是通过关键词 “@extend”来继承已存在的类样式块，从而实现代码的继承。如下所示： 123456789101112131415161718//SCSS.btn &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff; @extend .btn;&#125;.btn-second &#123; background-color: orange; color: #fff; @extend .btn;&#125; 占位符 （重点）Sass 中的占位符 %placeholder 功能是一个很强大，很实用的一个功能，这也是我非常喜欢的功能。他可以取代以前 CSS 中的基类造成的代码冗余的情形。因为 %placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码。来看一个演示： 123456%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125; 这段代码没有被 @extend 调用，他并没有产生任何代码块，只是静静的躺在你的某个 SCSS 文件中。只有通过 @extend 调用才会产生代码： 1234567891011121314151617181920//SCSS%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125;.btn &#123; @extend %mt5; @extend %pt5;&#125;.block &#123; @extend %mt5; span &#123; @extend %pt5; &#125;&#125; 混合宏 VS 继承 VS 占位符a) Sass 中的混合宏使用 编译出来的 CSS 清晰告诉了大家，他不会自动合并相同的样式代码，如果在样式文件中调用同一个混合宏，会产生多个对应的样式代码，造成代码的冗余，这也是 CSSer 无法忍受的一件事情。不过他并不是一无事处，他可以传参数。 个人建议：如果你的代码块中涉及到变量，建议使用混合宏来创建相同的代码块。 b) Sass 中继承 总结：使用继承后，编译出来的 CSS 会将使用继承的代码块合并到一起，通过组合选择器的方式向大家展现，比如 .mt, .block, .block span, .header, .header span。这样编译出来的代码相对于混合宏来说要干净的多，也是 CSSer 期望看到。但是他不能传变量参数。 个人建议：如果你的代码块不需要专任何变量参数，而且有一个基类已在文件中存在，那么建议使用 Sass 的继承。 c) 占位符 总结：编译出来的 CSS 代码和使用继承基本上是相同，只是不会在代码中生成占位符 mt 的选择器。那么占位符和继承的主要区别的，“占位符是独立定义，不调用的时候是不会在 CSS 中产生任何代码；继承是首先有一个基类存在，不管调用与不调用，基类的样式都将会出现在编译出来的 CSS 代码中。” [Sass]插值#{}123456789$properties: (margin, padding);@mixin set-value($side, $value) &#123; @each $prop in $properties &#123; #&#123;$prop&#125;-#&#123;$side&#125;: $value; &#125;&#125;.login-box &#123; @include set-value(top, 14px);&#125; 它可以让变量和属性工作的很完美，上面的代码编译成 CSS： 12345.login-box &#123; margin-top: 14px; padding-top: 14px;&#125; Sass的基本特性-运算[Sass运算]加法加法运算是 Sass 中运算中的一种，在变量或属性中都可以做加法运算。如： 123.box &#123; width: 20px + 8in;&#125; 编译出来的 CSS:123.box &#123; width: 788px;&#125; 但对于携带不同类型的单位时，在 Sass 中计算会报错，如下例所示：123.box &#123; width: 20px + 1em;&#125; [Sass运算]减法Sass 的减法运算和加法运算类似，我们通过一个简单的示例来做阐述： 123456$full-width: 960px;$sidebar-width: 200px;.content &#123; width: $full-width - $sidebar-width;&#125; [Sass运算]乘法Sass 中的乘法运算和前面介绍的加法与减法运算还略有不同。虽然他也能够支持多种单位（比如 em ,px , %），但当一个单位同时声明两个值时会有问题。比如下面的示例： 123.box &#123; width:10px * 2px; &#125; 如果进行乘法运算时，两个值单位相同时，只需要为一个数值提供单位即可。上面的示例可以修改成： 123.box &#123; width: 10px * 2;&#125; [Sass运算]除法Sass 的乘法运算规则也适用于除法运算。不过除法运算还有一个特殊之处。众所周知“/”符号在 CSS 中已做为一种符号使用。因此在 Sass 中做除法运算时，直接使用“/”符号做为除号时，将不会生效，编译时既得不到我们需要的效果，也不会报错。一起先来看一个简单的示例： 123.box &#123; width: 100px / 2; &#125; 这样的结果对于大家来说没有任何意义。要修正这个问题，只需要给运算的外面添加一个小括号( )即可： 123.box &#123; width: (100px / 2); &#125; 除了上面情况带有小括号，“/”符号会当作除法运算符之外，如果“/”符号在已有的数学表达式中时，也会被认作除法符号。如下面示例： 123.box &#123; width: 100px / 2 + 2in; &#125; 另外，在 Sass 除法运算中，当用变量进行除法运算时，“/”符号也会自动被识别成除法，如下例所示： 12345678910$width: 1000px;$nums: 10;.item &#123; width: $width / 10; &#125;.list &#123; width: $width / $nums;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Sass","slug":"技术/Sass","permalink":"http://yoursite.com/categories/技术/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"}]},{"title":"Sass学习","slug":"Sass","date":"2018-06-13T04:01:24.520Z","updated":"2018-06-13T04:50:45.923Z","comments":true,"path":"2018/06/13/Sass/","link":"","permalink":"http://yoursite.com/2018/06/13/Sass/","excerpt":"一、安装由于Sass是基于ruby的，所以先安装ruby。 Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板：Start Command Prompt with Ruby 1、通过命令安装 Sass 1gem install sass 使用国内淘宝镜像gem。第一步：gem sources –remove https://rubygems.org/ 删除自带gem第二步：gem sources -a https://ruby.taobao.org/ 添加国内淘宝镜像gem第三步：gem sources 显示下载的gem信息 查看版本sass -v 更新：gem update sass 删除gem uninstall sass 后缀sass 和scss 的区别： sass 不用{} 包裹， 而scss可以包裹。建议使用scss。 示例： 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125;","text":"一、安装由于Sass是基于ruby的，所以先安装ruby。 Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板：Start Command Prompt with Ruby 1、通过命令安装 Sass 1gem install sass 使用国内淘宝镜像gem。第一步：gem sources –remove https://rubygems.org/ 删除自带gem第二步：gem sources -a https://ruby.taobao.org/ 添加国内淘宝镜像gem第三步：gem sources 显示下载的gem信息 查看版本sass -v 更新：gem update sass 删除gem uninstall sass 后缀sass 和scss 的区别： sass 不用{} 包裹， 而scss可以包裹。建议使用scss。 示例： 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 二、Sass编译 命令编译 GUI工具编译 自动化编译 1、命令编译单文件编译： sass &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css 多文件编译： sass sass/:css/ 上面的命令表示将项目中“sass”文件夹中所有“.scss”(“.sass”)文件编译成“.css”文件，并且将这些 CSS 文件都放在项目中“css”文件夹中。 2、GUI 界面工具编译就推荐Koala 其他就不介绍了。 3、自动化编译 Grunt Gulp 具体配置自行查看文档 三、常见错误： 最为常见的一个错误就是字符编译引起的。在Sass的编译的过程中，是不是支持“GBK”编码的。所以在创建 Sass 文件时，就需要将文件编码设置为“utf-8”。 另外一个错误就是路径中的中文字符引起的。建议在项目中文件命名或者文件目录命名不要使用中文字符。而至于人为失误造成的编译失败，在编译过程中都会有具体的说明，大家可以根据编译器提供的错误信息进行对应的修改。 四、不同样式风格的输出方法 嵌套输出方式 nested 展开输出方式 expanded 紧凑输出方式 compact 压缩输出方式 compressed 4.1嵌套输出方式 nested语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style nested”:sass –watch test.scss:test.css –style nested 编译出来的 CSS 样式风格：12345678910nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; 4.2 展开输出方式 expanded语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style expanded”: sass –watch test.scss:test.css –style expanded 这个输出的 CSS 样式风格和 nested 类似，只是大括号在另起一行，同样上面的代码，编译出来：12345678910111213nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 4.3 紧凑输出方式 compact语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style compact”: sass –watch test.scss:test.css –style compact 该方式适合那些喜欢单行 CSS 样式格式的朋友，编译后的代码如下： 123nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; 4.4 压缩输出方式 compressed在编译的时候带上参数“ –style compressed”: sass –watch test.scss:test.css –style compressed 压缩输出方式会去掉标准的 Sass 和 CSS 注释及空格。也就是压缩好的 CSS 代码样式风格：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Sass","slug":"技术/Sass","permalink":"http://yoursite.com/categories/技术/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"}]},{"title":"网页响应式开发","slug":"响应式开发","date":"2018-06-12T13:30:53.358Z","updated":"2018-06-13T04:02:41.247Z","comments":true,"path":"2018/06/12/响应式开发/","link":"","permalink":"http://yoursite.com/2018/06/12/响应式开发/","excerpt":"一、原理定义最小宽度： // Extra small devices (portrait phones, less than 576px)// No media query since this is the default in Bootstrap // Small devices (landscape phones, 576px and up)@media (min-width: 576px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … }","text":"一、原理定义最小宽度： // Extra small devices (portrait phones, less than 576px)// No media query since this is the default in Bootstrap // Small devices (landscape phones, 576px and up)@media (min-width: 576px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … } 定义最大宽度：// Extra small devices (portrait phones, less than 576px)@media (max-width: 575.98px) { … } // Small devices (landscape phones, less than 768px)@media (max-width: 767.98px) { … } // Medium devices (tablets, less than 992px)@media (max-width: 991.98px) { … } // Large devices (desktops, less than 1200px)@media (max-width: 1199.98px) { … } // Extra large devices (large desktops)// No media query since the extra-large breakpoint has no upper bound on its width 使用逻辑混用：// Extra small devices (portrait phones, less than 576px)@media (max-width: 575.98px) { … } // Small devices (landscape phones, 576px and up)@media (min-width: 576px) and (max-width: 767.98px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) and (max-width: 991.98px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) and (max-width: 1199.98px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … } 提取模板：(用的 bootstrap)12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css\" integrity=\"sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Hello, world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.2.1.slim.min.js\" integrity=\"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js\" integrity=\"sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js\" integrity=\"sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 响应式框架介绍1、bootstrap如何安装？ 建议使用npm来安装：命令如下：12npm install bootstrap 也可以用CDN安装： CSS only 1&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\" integrity=\"sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB\" crossorigin=\"anonymous\"&gt; JS, Popper.js, and jQuery 123&lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js\" integrity=\"sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; 2、Foundation模板快速开发具体的模板，可以看bootstrap,不做详细介绍了。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"http://yoursite.com/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"http://yoursite.com/tags/响应式开发/"}]},{"title":"JavaScript-高级函数","slug":"高阶函数","date":"2018-06-12T12:35:30.955Z","updated":"2018-06-12T13:15:03.173Z","comments":true,"path":"2018/06/12/高阶函数/","link":"","permalink":"http://yoursite.com/2018/06/12/高阶函数/","excerpt":"一、什么是JavaScript的高级函数通俗一点讲就是：函数作为参数的行为 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 123function add(x, y, f) &#123; return f(x) + f(y);&#125; 当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为： x = -5;y = 6;f = Math.abs;f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;return 11;","text":"一、什么是JavaScript的高级函数通俗一点讲就是：函数作为参数的行为 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 123function add(x, y, f) &#123; return f(x) + f(y);&#125; 当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为： x = -5;y = 6;f = Math.abs;f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;return 11; map举例说明，比如我们有一个函数$$ f(x)=x^2 $$要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下： 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果： 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results); map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串： 12var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)比方说对一个Array求和，就可以用reduce实现：1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25 filter filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] 把一个Array中的空字符串删掉，可以这么写： 12345var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);r; // ['A', 'B', 'C'] 可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。 注：trim()方法返回调用字符串对象的一个副本,但是所有起始和结尾的空格都被删除了 利用filter，可以巧妙地去除Array的重复元素： 123456789'use strict';var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;);console.log(r.toString()); // 把数组转化为字符串； sort:排序算法: 排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。 JavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊： 看上去正常的结果:1[&apos;Google&apos;, &apos;Apple&apos;, &apos;Microsoft&apos;].sort(); // [&apos;Apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;]; apple排在了最后:1[&apos;Google&apos;, &apos;apple&apos;, &apos;Microsoft&apos;].sort(); // [&apos;Google&apos;, &apos;Microsoft&quot;, &apos;apple&apos;] 无法理解的结果:1[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。 第三个排序结果是什么鬼？简单的数字排序都能错？ 这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果’10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小。 幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 要按数字大小排序，我们可以这么写： 12345678910111213'use strict';var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20] 如果要倒序排序，我们可以把大的数放前面： 12345678910var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return 1; &#125; if (x &gt; y) &#123; return -1; &#125; return 0;&#125;); // [20, 10, 2, 1] 默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：123456789101112var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) &#123; x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) &#123; return -1; &#125; if (x1 &gt; x2) &#123; return 1; &#125; return 0;&#125;); // ['apple', 'Google', 'Microsoft'] &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"高级函数","slug":"技术/JavaScript/高级函数","permalink":"http://yoursite.com/categories/技术/JavaScript/高级函数/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}]},{"title":"JavaScript 基础知识总结","slug":"javaScript系列文章","date":"2018-06-12T12:30:49.438Z","updated":"2018-06-12T12:35:07.912Z","comments":true,"path":"2018/06/12/javaScript系列文章/","link":"","permalink":"http://yoursite.com/2018/06/12/javaScript系列文章/","excerpt":"本文主要是一些基础性的知识回顾，后续吧深入理解的东西发表出来。现在先学习基础性的东西吧。 下面是我总结的一些思维导图：","text":"本文主要是一些基础性的知识回顾，后续吧深入理解的东西发表出来。现在先学习基础性的东西吧。 下面是我总结的一些思维导图：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript系列文章","slug":"技术/JavaScript系列文章","permalink":"http://yoursite.com/categories/技术/JavaScript系列文章/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Chrome DevTools 技巧","slug":"Chrome DevTools技巧","date":"2018-06-12T11:39:19.344Z","updated":"2018-06-12T12:21:09.152Z","comments":true,"path":"2018/06/12/Chrome DevTools技巧/","link":"","permalink":"http://yoursite.com/2018/06/12/Chrome DevTools技巧/","excerpt":"1、拖拽面板中的元素","text":"1、拖拽面板中的元素 2、在控制台控制选中的元素 3、添加CSS并编辑元素的状态在元素面板有两个很好用的按钮add css: 4、找到css属性被定义在什么位置ctrl-click on Windows ctrl 键点击属性，可以定位","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Chrome DevTools","slug":"技术/Chrome-DevTools","permalink":"http://yoursite.com/categories/技术/Chrome-DevTools/"}],"tags":[{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://yoursite.com/tags/Chrome-DevTools/"}]},{"title":"CSS 弹性盒子Flexbox","slug":"前端基础知识整理5","date":"2018-06-11T13:08:25.000Z","updated":"2018-06-12T07:11:23.380Z","comments":true,"path":"2018/06/11/前端基础知识整理5/","link":"","permalink":"http://yoursite.com/2018/06/11/前端基础知识整理5/","excerpt":"&ensp; &ensp;布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 一、Flex 布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。","text":"&ensp; &ensp;布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 一、Flex 布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 ####二、基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 ####三、容器的属性 以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.flex-direction flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端 flex-flow column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 2.flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 4.justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5.align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6.align-content属性123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1.order属性123.item &#123; order: &lt;integer&gt;;&#125; 4.2.flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"Flexbox","slug":"技术/前端基础知识/Flexbox","permalink":"http://yoursite.com/categories/技术/前端基础知识/Flexbox/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Flexbox","slug":"Flexbox","permalink":"http://yoursite.com/tags/Flexbox/"}]},{"title":"CSS 媒体查询","slug":"前端基础知识整理6","date":"2018-06-11T13:08:25.000Z","updated":"2018-06-12T12:22:09.690Z","comments":true,"path":"2018/06/11/前端基础知识整理6/","link":"","permalink":"http://yoursite.com/2018/06/11/前端基础知识整理6/","excerpt":"&ensp; &ensp;所谓的媒体查询就是指，不同的条件使用不同的样式或样式集合。 @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式","text":"&ensp; &ensp;所谓的媒体查询就是指，不同的条件使用不同的样式或样式集合。 @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式 一、CSS 语法 device-width 和 width的区别： device-width表示的是设备的宽度，即屏幕的宽度。width所代表的是文档宽度，与屏幕大小没有关系，如果是在移动设备上，width表示的是布局视口的宽度。 必要的空格。 12//空格是有必要的，在某些情况下该样式永远不起作用。&lt;link rel=\"stylesheet\" media=\"(min-device-width:400px)【空格】and【空格】(max-device-width:900px)\" href=\"css/style1.css\"&gt; 语法示例： 12345678910&lt;!-- link元素中的CSS媒体查询 --&gt;&lt;link rel=\"stylesheet\" media=\"(max-width: 800px)\" href=\"example.css\" /&gt; //对什么状况下使用&lt;!-- 样式表中的CSS媒体查询 --&gt;&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 二、可供媒体查询检测的特性 width:视口宽度 height:视口高度 device-width:设备屏幕的宽度 device-height:设备屏幕的高度 orientation:检测设备处于横向还是纵向 aspect-radio:基于视口宽度和高度的宽高比 device-sapect-radio:基于设备渲染平面宽度和高度的宽高比 color:每种颜色的位数 color-index:设备的颜色索引表中的颜色数 monochrome:检测单色帧缓冲区中每像素所使用的位数 resolution:用来检测屏幕或打印机的分辨率， scan:电视机的烧苗方式，值可设为progressive(逐行扫描)或interlace(隔行扫描) 用来检测输出设备是网格设备还是位图设备 三、逻辑操作 and，且的关系，当所有的条件满足的时候返回true12345678//一个基本的媒体查询，即一个媒体属性和默认指定的all媒体类型@media (min-width:700px)&#123;&#125;//如果你只想再横屏时候应用,你可以使用and操作符合并媒体属性(min-width:700px)and(orientation:landscape)&#123;&#125;//如果你仅想在电视媒体上应用@media tv and (min-width:700px) and (orientation:landscape)&#123;&#125; 逗号分割列表，或的关系，只要有条件满足就返回ture not，类似于取反，最后参与运算的运算符 only，only关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"媒体查询","slug":"技术/前端基础知识/媒体查询","permalink":"http://yoursite.com/categories/技术/前端基础知识/媒体查询/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"媒体查询","slug":"媒体查询","permalink":"http://yoursite.com/tags/媒体查询/"}]},{"title":"CSS 网格布局知识2","slug":"前端基础知识整理4","date":"2018-06-11T08:19:01.252Z","updated":"2018-06-11T12:57:59.131Z","comments":true,"path":"2018/06/11/前端基础知识整理4/","link":"","permalink":"http://yoursite.com/2018/06/11/前端基础知识整理4/","excerpt":"定义一个网格：Grid(网格) 模块为 display 属性提供了一个新的值：grid。当你将任何元素的 display 属性设置为 grid 时，那么这个元素就是一个 网格容器(grid container)，它的所有直接子元素就成了 网格项(grid items)。 让我们创建创建一个 3×3 的布局，做一个 Tic-Tac-Toe (井字游戏) 棋盘。 首先，我们将写一些 HTML： 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;","text":"定义一个网格：Grid(网格) 模块为 display 属性提供了一个新的值：grid。当你将任何元素的 display 属性设置为 grid 时，那么这个元素就是一个 网格容器(grid container)，它的所有直接子元素就成了 网格项(grid items)。 让我们创建创建一个 3×3 的布局，做一个 Tic-Tac-Toe (井字游戏) 棋盘。 首先，我们将写一些 HTML： 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt; .game-board div 是网格容器，而 .box div 是网格项。现在我们将通过 Grid 布局来实现 3×3 布局。 123456.game-board &#123; display: grid; grid-template-rows: 200px 200px 200px; grid-template-columns: 200px 200px 200px; &#125; grid-template-rows 属性允许我们指定网格中的行数及行的高度。那么你应该猜到另一个属性是干什么的了。 grid-template-columns 属性允许我们指定网格中的列数及列的宽度。 fr 单位(等分)fr 是为网格布局定义的一个新单位。它可以帮助你摆脱计算百分比，并将可用空间等分。 例如，如果在网格容器中设置这个规则：grid-template-rows: 2fr 3fr，那么你的网格容器将首先被分成 2 行。然后将数字部分加在一起，这里总和为 5， 即 5 等分。 就是说，我们将有 2 行：第一排占据垂直空间的 2/5 。 第二排占垂直空间的 3/5 。 回到我们的 Tic-Tac-Toe 例子，我们使用 fr 代替 px。我们想要的是，应该有3行3列。所以，我们只需要用 3 个 1fr 替换 3 个 200px 即可： 123456.game-board &#123; display: grid; grid-template-rows: 1fr 1fr 1fr; grid-template-columns: 1fr 1fr 1fr; &#125; 这里特别需要注意的是： fr 单位是等分可用空间，或者说剩余空间。看个例子: 123456789.game-board &#123; grid-gap:2px; display: grid; width:300px; height:200px; grid-template-rows: 100px 1fr 1fr; grid-template-columns: 1fr 50px 1fr; &#125; 你会看到 fr 单位是将 总的尺寸 减去 单元格明确尺寸后，在等分剩余空间。 grid-gap 是间隔。 repeat() 函数在某些情况下，我们可能有很多的列和行。在 grid-template 属性中指定每一个值可能会很乏味。幸运的是，有一个 repeat 函数，就像任何一个循环重复多少次输出某个给定值。它有两个参数。第一个是迭代次数，第二个是要重复的值。我们用 repeat 函数重写上面的例子。 123456.game-board &#123; display: grid; grid-template-rows: repeat(3, 1fr); grid-template-columns: repeat(3, 1fr); &#125; grid-template 属性grid-template 属性是 grid-template-rows 和 grid-template-columns 的简写语法。 这是它的语法： grid-template: ro ws / co lu mns; 我们上面的例子使用这个简写语法后，看起来非常整齐。 12345.game-board &#123; display: grid; grid-template: repeat(3, 1fr) / repeat(3, 1fr); &#125; 下面是具体创建的例子了：HTML 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt;&lt;/div&gt; CSS 12345678910111213141516171819202122232425.game-board&#123; width: 600px; height: 600px; margin: 0 auto; background-color: #34495e; color: #fff; border: 6px solid #2c3e50; border-radius: 10px; display: grid; grid-template: repeat(3, 1fr) / repeat(3, 1fr);&#125;.box&#123; border: 6px solid #2c3e50; border-radius: 2px; font-family: Helvetica; font-weight: bold; font-size: 4em; display: flex; justify-content: center; align-items: center;&#125; 网格线编号,网格单元格，网格轨道网格线是存在于列和行每一侧的线。一组垂直线将空间垂直划分成列，而另一组水平线将空间水平划分成行。这意味着在我们之前的例子中，有四条垂直线和四条水平线包含它们之间的行和列。 在将网格项从一个位置跨越到另一个位置时，网格线变得非常有用。 网格轨道是两条线之间的空间。 网格轨道可以是一行或一列。 网格单元格很像表格单元，是两条相邻垂直线和两条相邻水平线之间的空间。 这是网格中最小的单位。 定位网格项采取了前面的例子的网格，并用数字从1到9标记每个单元格，而不是X或O，下面是它的样子： 假设我想将第 6 个框移到第 2 个框的位置。 我们使用网格模块，改变网格中网格项的位置是一件轻而易举的事情。 要将第6个框移到第2个框的位置，我们必须确切知道第2个框在哪里。通过网格线编号的帮助，我们可以很容易地找到这个位置。第二个方框位于第2条列网格线之后，第3条列网格线之前，第1条行网格线之下，第2条行网格线之上。现在我们可以使用以下属性将这些网格线编号分配到第6个框中： grid-column-start grid-column-end grid-row-start grid-row-end 前两个属性对应于垂直网格线，也就是列网格线的开始和结束。 最后两个属性是指水平网格线，也就是行网格线的开始和结束。 让我们分配正确的网格线编号来移动第 6 个框。 1234567.box:nth-child(6) &#123; grid-row-start: 1; grid-row-end: 2; grid-column-start: 2; grid-column-end: 3; &#125; 还有两个简写属性用于将行和列的开始网格线和结束网格线设置在一起。 12345.box:nth-child(6) &#123; grid-row: 1 / 2; grid-column: 2 / 3; &#125; 此外，还有一个grid-area属性是所有四个上述属性的简写属性。 它按以下顺序取值： grid-area: / / / ; 现在我们的例子可以写成这样: 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / 3; &#125; 如果我们想要第6个框跨越两个框的区域呢？ 这很容易通过将 column-end 值加 1 的办法来完成。 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / 4; &#125; 您也可以使用 span 关键字和占据的 轨道数量，来代替指定 grid-row-end 和 grid-column-end 的结束网格线编号。 在这种情况下，第6个框是跨越 2 列和 1 行。 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / span 2; &#125; 网格区域命名grid-area 属性也可以用来命名网格的某一个部分，然后我们可以用 grid-template-areas 属性来定位。让我们创建一个简单的 bread-and-butter 布局，顶部有一个 top, nav，中间有 main 和 aside，下面是 footer。这是所需的HTML： 1234567&lt;div class=\"container\"&gt; &lt;header&gt;&lt;/header&gt; &lt;nav&gt;&lt;/nav&gt; &lt;main&gt;&lt;/main&gt; &lt;aside&gt;&lt;/aside&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/div&gt; 我们需要使用 grid-area 属性来命名每个区域： 1234567891011121314151617181920212223242526272829header &#123; grid-area: header; background-color: #9b59b6; &#125; nav &#123; grid-area: nav; background-color: #3498db; &#125; main &#123; grid-area: main; background-color: #2ecc71; &#125; aside &#123; grid-area: aside; background-color: #f1c40f; &#125; footer &#123; grid-area: footer; background-color: #1abc9c; &#125; 现在我们将使用 grid-template-areas 属性来指定每个网格区域所占据的行和列。 以下是我们如何做到的： 1234567891011.container &#123; display: grid; grid-template-rows: 1fr 5fr 1fr; grid-template-columns: 2fr 5fr 3fr; grid-template-areas: \"header header header\" \"nav main aside\" \"footer footer footer\"; grid-gap: .75em; &#125; 请注意，header 和 footer 单词重复三次。 这表明，header 和 footer 横跨 3 列的宽度。 你可以把它全部写在一行中，但是把每一行写在一个单独的行上很好，很干净。 你可以看到我在这里使用了一个新的属性 grid-gap。 它所做的只是在两个网格区域之间添加一个间距。 你也可以使用 grid-row-gap 和 grid-column-gap 来为行和列指定不同的间距值。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"网格布局","slug":"技术/前端基础知识/网格布局","permalink":"http://yoursite.com/categories/技术/前端基础知识/网格布局/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"网格布局","slug":"网格布局","permalink":"http://yoursite.com/tags/网格布局/"}]},{"title":"CSS 网格布局知识1","slug":"前端基础知识整理3","date":"2018-06-11T08:16:54.016Z","updated":"2018-06-11T12:33:13.612Z","comments":true,"path":"2018/06/11/前端基础知识整理3/","link":"","permalink":"http://yoursite.com/2018/06/11/前端基础知识整理3/","excerpt":"2.1 网格布局知识 CSS Grid(网格) 布局使我们能够比以往任何时候都可以更灵活构建和控制自定义网格。 Grid(网格) 布局使我们能够将网页分成具有简单属性的行和列。它还能使我们在不改变任何HTML的情况下，使用 CSS 来定位和调整网格内的每个元素。它允许 HTML 纯粹作为内容的容器。HTML 结构不再受限于样式表现，比如不要为了实现某种布局而多次嵌套，现在这些都可以让 CSS 来完成。 浏览器兼容性 对于大多数布局，我们会使用下面的query特性来让老的浏览器对他们理解的特性也能工作： 12345@supports (display: grid) &#123; .grid &#123; display: grid; &#125;&#125; 不支持浏览器@supports或网格的浏览器将不会生效。","text":"2.1 网格布局知识 CSS Grid(网格) 布局使我们能够比以往任何时候都可以更灵活构建和控制自定义网格。 Grid(网格) 布局使我们能够将网页分成具有简单属性的行和列。它还能使我们在不改变任何HTML的情况下，使用 CSS 来定位和调整网格内的每个元素。它允许 HTML 纯粹作为内容的容器。HTML 结构不再受限于样式表现，比如不要为了实现某种布局而多次嵌套，现在这些都可以让 CSS 来完成。 浏览器兼容性 对于大多数布局，我们会使用下面的query特性来让老的浏览器对他们理解的特性也能工作： 12345@supports (display: grid) &#123; .grid &#123; display: grid; &#125;&#125; 不支持浏览器@supports或网格的浏览器将不会生效。 创建带有间距（gutter）的两列（column）网格 [使用grid-template-columns 和 grid-gap创建带间距的两列布局] 为了创建上述网格布局，我们需要使用grid-template-columns和grid-gap。grid-template-columns表示网格中的列是如何布局的，它的值是一连串以空格分割的的值，这些值标识每列的大小，值的个数表示列的数目。 例如，四列250px宽度的网格布局可以这样表示： 1grid-template-columns: 250px 250px 250px 250px; 也可以使用repeat关键字表示：1grid-template-columns: repeat(4, 250px); 定义间距grid-gap定义了网格布局的间距大小，接收一个或两个值，如果定义两个值则表示列（column）和行（row）的间距大小。 在两列布局示例中，我们可以如下使用： 12345.grid &#123; display: grid; grid-template-columns: 50vw 50vw; grid-gap: 1rem;&#125; 不幸的是，这个间距将会占用容器元素的整体宽度，计算出来就是100vw + 1rem，最终这个布局会导致出现水平滚动条。 为了解决这个空间溢出问题，我们需要些不同的方法来处理，需要用分数单位或者说是FR。 分数单位标识占用可用空间的份额，如果900px是可用空间，其中的一个元素占有1份，另外的元素占有2份——那么第一个元素的宽度会是900px的1/3，另外的元素是900px的2/3。修改后用分数代替view-port单位的新代码如下： 12345.grid &#123; display: grid; grid-template-columns: 1fr 1fr; grid-gap: 1rem;&#125; 内容对齐为了对齐示例中的内容，我们在子元素上使用grid布局，并加上对齐属性来定位他们到指定轨道(track)，轨道就是一个网格的列或行的某个位置的常见的名称。网格跟Flex布局一样，有一系列对齐的属性——共有四种值——start, center, end, 和stretch，分别对应其子元素所在的轨道。stretch跟其他不太一样，它会将元素从所在轨道的头拉伸到尾。 [align-items 和 justify-content] 例子中我们要将内容水平和垂直居中，可以通过在容器上设置下面这些属性：12345.center-content &#123; display: grid; align-items: center; justify-content: center;&#125; 通过CSS网格实现内边距（Negative Space）网格布局允许你通过grid-column-start属性指定列开始的位置，所以就有了可以在网格内创建内边距的可能性。[使用grid-template-columns和grid-column-start创建内边距] 在上面的内边距示例中，html结构中用一个div包裹另外一个div：123&lt;div class=\"grid\"&gt; &lt;div class=\"child\"&gt;&lt;!-- 内容 --&gt;&lt;/div&gt;&lt;/div 网格像这样设置： 123.child &#123; grid-column-start: 2;&#125; 创建行如果我们想分割布局为四份，我们目前所了解的关于列的布局方式对行同样有效： 12345.grid &#123; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 250px 250px;&#125; 理想情况下这个示例是没问题的。因为此时每个网格项的内容足够少而不会撑开每行。但随着内容的变化，一切都不一样了。当示例中的内容超出指定行的大小后，看下会发生什么： [内容超出声明的行高] 我们创建了250px高的两行，如果内容超过每行的高度，将会打破布局并和后面的行的内容重叠。并不是一个我们想要的结果。 灵活的设置最小值我们在该场景下需要的是设置最小尺寸的能力，但又要允许尺寸可以根据内容弹性变化。这里我们通过上面旧浏览器示例中的minmax关键字实现。 123.grid &#123; grid-template-rows: minmax(250px, auto) minmax(250px, auto);&#125; 现在我们已经了解了创建带有内容的行的基础方法，我们开始来创建水平和垂直交错的更复杂网格布局。 [使用grid-column-start和span关键字创建复杂网格布局Unsplash] 123.span-column-3 &#123; grid-column-start: span 3;&#125; 不需要媒体查询（media queries）的弹性网格虽然上面说到的例子能在可用空间内适应变化，但是没有一个是专门为空间变化设计的。网格有两个非常有用的特性来适应可用空间的变化。这两个属性叫‘auto-fit’和‘auto-fill’，像下面这样结合repeat function和minmax function使用： 1grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); auto-fill的表现跟auto-fit类似，但是任何的空白空间都会自动收缩，同时这一行的元素也会被拉升——类似flexbox的效果，列会随着可用空间变小发生折叠。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"网格布局","slug":"技术/前端基础知识/网格布局","permalink":"http://yoursite.com/categories/技术/前端基础知识/网格布局/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"网格布局","slug":"网格布局","permalink":"http://yoursite.com/tags/网格布局/"}]},{"title":"CSS 基础知识整理","slug":"前端基础知识整理2","date":"2018-06-11T06:36:25.619Z","updated":"2018-06-11T08:17:38.481Z","comments":true,"path":"2018/06/11/前端基础知识整理2/","link":"","permalink":"http://yoursite.com/2018/06/11/前端基础知识整理2/","excerpt":"1、CSS基础知识亲自做的思维导图：方便学习查看","text":"1、CSS基础知识亲自做的思维导图：方便学习查看 2、CSS 布局知识亲自做的思维导图：方便学习查看","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML 基础知识整理","slug":"前端基础知识整理1","date":"2018-06-11T05:20:37.334Z","updated":"2018-06-11T06:43:26.675Z","comments":true,"path":"2018/06/11/前端基础知识整理1/","link":"","permalink":"http://yoursite.com/2018/06/11/前端基础知识整理1/","excerpt":"把很久之前学习的基础知识整理一遍：1、HTML基础元素亲自做的思维导图：方便学习查看","text":"把很久之前学习的基础知识整理一遍：1、HTML基础元素亲自做的思维导图：方便学习查看 1.2 HTML表单元素亲自做的思维导图：方便学习查看 2、DOM文档对象模型 根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 亲自做的思维导图：方便学习查看 上面两个图标明了其属性，下面看看具体的方法： 1、创建 HTML 内容1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=\"p1\"&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById(\"p1\").innerHTML=\"New text!\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、改变 HTML 样式1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=\"p2\"&gt;Hello world!&lt;/p&gt;&lt;script&gt;document.getElementById(\"p2\").style.color=\"blue\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、创建新的 HTML 元素 将新元素作为父元素的最后一个子元素进行添加。 12345678910111213&lt;&lt;div id=\"d1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var element=document.getElementById(\"d1\");element.appendChild(para);&lt;/script&gt; 插在前面1234567891011121314&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var element=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");element.insertBefore(para,child);&lt;/script&gt; 4、删除已有的 HTML 元素 如需删除 HTML 元素，您必须清楚该元素的父元素： 12345678910&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var parent=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");parent.removeChild(child);&lt;/script&gt;&lt;/html&gt; 6、替换 HTML 元素 如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法： 1234567891011121314&lt;&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var parent=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");parent.replaceChild(para,child);&lt;/script&gt; 7、使用事件：123456789101112131415&lt;html&gt;&lt;body&gt;&lt;script&gt;function ChangeBackground()&#123;document.body.style.backgroundColor=\"lavender\";&#125;&lt;/script&gt;&lt;input type=\"button\" onclick=\"ChangeBackground()\"value=\"Change background color\" /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"}]},{"title":"webpack使用技术详情","slug":"webpack系列文章7","date":"2018-06-10T05:51:27.511Z","updated":"2018-06-10T12:13:50.341Z","comments":true,"path":"2018/06/10/webpack系列文章7/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章7/","excerpt":"本文主要步骤：1、创建文件 mkdir mywebpack2、npm init -y // 用来创建webpack的配置文件3、安装webpack npm install webpack –save-dev4、安装组件 npm install html-webpack-plugin –save-dev //具体的index等文件自己创建就好了5、webpack.config.js 的使用 //这个之前基础都学习过了","text":"本文主要步骤：1、创建文件 mkdir mywebpack2、npm init -y // 用来创建webpack的配置文件3、安装webpack npm install webpack –save-dev4、安装组件 npm install html-webpack-plugin –save-dev //具体的index等文件自己创建就好了5、webpack.config.js 的使用 //这个之前基础都学习过了 5、处理js文件需要用的依赖包： 12npm install --save-dev babel-loader babel-core npm install --save-dev babel-preset-env //转义ES6 为防止浏览器不支持 Promise/Object.assign/Array.from等还有性能问题,我们引入两个包: babel-polyfill babel-plugin-transform-runtime 1npm install --save-dev babel-polyfill babel-plugin-transform-runtime 引入生产版本依赖 npm install –save babel-runtime 通过 .babelrc 添加配置: 12345678&#123; \"presets\": [ \"env\" ], \"plugins\": [ \"transform-runtime\" ]&#125; 将 babel-polyfill 加到你的 entry 数组中使用，配置js文件要经过babel转义： 12345678910111213141516171819202122232425const path = require('path');module.exports = &#123; //entry为入口,webpack从这里开始编译 entry: [ \"babel-polyfill\", path.join(__dirname, './src/index.js') ], //output为输出 path代表路径 filename代表文件名称 output: &#123; path: path.join(__dirname, './bundle'), filename: 'bundle.js' &#125;, //module是配置所有模块要经过什么处理 //test:处理什么类型的文件,use:用什么,include:处理这里的,exclude:不处理这里的 module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], include: path.join(__dirname , 'src'), exclude: /node_modules/ &#125; ] &#125;,&#125;; 6、打包： 直接执行命令webpack7、看看日志说明：8、使用快捷方式进行编译： 可以在项目package.json里面来配置 ： 123456789101112131415161718192021&#123; \"name\": \"05-01\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" \"build\":\"webpack\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"babel-preset-es2015\": \"^6.14.0\", \"babel-preset-react\": \"^6.11.1\", \"babelify\": \"^7.3.0\", \"react\": \"^15.3.2\", \"react-dom\": \"^15.3.2\", \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.1\" &#125;&#125; 下面你可以使用命令： 1npm run build 9、怎样自动加载： 首先安装webpack-dev-server 执行命令：1npm install webpack-dev-serve --save-dev 下面就可以执行如下命令了1webpack-dev-server --contentbase -src --inline 注意： 这里版本很重要，要匹配。 如果安装其他版本，可以在名称后面加@跟上版本号就可以了。 10、配置端口号 webpakc.config.js 里面配置 12345 devServer: &#123; contentBase: path.join(__dirname, \"dist\"), compress: true, port: 9000&#125; 接下来以管理员身份执行命令 1npm run start 11、配置ESLint 实现代码规范化自动化测试 安装： npm install eslint --save-dev 配置： package.json 里面的配置： { \"name\": \"05-01\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" \"build\":\"webpack\" \"lintjs\":\"eslint app/ webpack.*.js --cache\" //这是我们需要配置的 }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"babel-preset-es2015\": \"^6.14.0\", \"babel-preset-react\": \"^6.11.1\", \"babelify\": \"^7.3.0\", \"react\": \"^15.3.2\", \"react-dom\": \"^15.3.2\", \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.1\" } } eslintrc.js 里面的配置： 具体的规则可以去官网查看。 执行如下命令即可： npm run lintjs 如果有错误：会相应的提示。 怎样修复呢：执行命令： npm run lintjs -- --fix 如何自动测试 在webpack 中集成： 首先进行安装： npm install eslint-loader –save-dev 然后在webpack.config.js 里面进行配置： 具体配置可以查看官方文档。 12、webpack中加载CSS的相关配置 需要安装两个插件： npm insatall css-loader style-loader --save-dev webpack.config.js进行配置： const ExtractTextPlugin = require('extract-text-webpack-plugin'); ... module: { rules: [ ... { test: /\\.less$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: ['css-loader', 'style-loader','postcss-loader', 'less-loader'] //进行配置 }) } ] }, plugins: [ ... new ExtractTextPlugin({ filename: 'index.css' }), ], 13、webpack中加载图片 在 webpack 里，负责图片翻译的是 file-loader： npm install file-loader --save-dev 在webpack.config.js里面进行配置： }, { test: /\\.(png|jpg|gif)$/, use: [ { loader: 'file-loader', options: {} } ] } ] 至于我们怎样在js文件里配置： 我们需要一张图片，我从 unsplash 找来了一张玫瑰，放到 src/img/rose.jpg 位置。 我们在 src/index.js 中 import 它： import ReactDOM from 'react-dom' import Rose from './img/rose.jpg' class App extends React.Component { render () { return ( &lt;div&gt;&lt;img src={Rose} alt='玫瑰' /&gt;&lt;/div&gt; ) } } ReactDOM.render(&lt;App /&gt;, document.body) 14、打包： 在完成项目开发后，我们需要输出文件给生产环境部署，只要执行： npx webpack --mode production 14、部署： 部署时，拷贝 dist 目录即可。 15、清理 dist 随着某些文件的增删，我们的 dist 目录下会产生一些不再使用的文件，我们不想这些文件也部署到生产环境上占用空间，所以 webpack 在打包前最好能删除 dist 目录。 我们来试试 clean-webpack-plugin。 首先是安装： npm i -D clean-webpack-plugin 然后在 webpack.config.js 中调用： const path = require('path') const CleanWebpackPlugin = require('clean-webpack-plugin') module.exports = { mode: 'development', devServer: { contentBase: path.resolve(__dirname, 'dist') }, plugins: [ new CleanWebpackPlugin(['dist']) //需要实例化 ], module: { 再执行 npx webpack –mode production，webpack 确实会在打包前清空 dist 目录，但我们的 index.html 也一起被清空了。 下面我们使用 html-webpack-plugin 来自动生成 index.html： 首先是安装： npm i --save-dev html-webpack-plugin 调整 webpack.config.js： const CleanWebpackPlugin = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', devServer: { contentBase: path.resolve(__dirname, 'dist') }, plugins: [ new CleanWebpackPlugin(['dist']) new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin() ], 再运行 npx webpack –mode production，dist 下已经自动生成 index.html，再 title 却是 Webpack App，我们需要再调整一下 webpack.config.js： plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin() new HtmlWebpackPlugin({ title: 'webpack 教程' }) ], 至此，我们大致的教程算是完结了，但是这样比较麻烦，如果开发一个特定类型的项目，我们可以采用脚手架的方式直接生成： 比较有名的有： create-react-app react 官方出品的一套，只适用开发 react.js 项目； neutrino.js 这是 Mozilla 出品的一套解决方案，Web、React、Node.js 等方案均有；","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-配置","slug":"webpack系列文章6","date":"2018-06-10T05:33:06.854Z","updated":"2018-06-10T05:36:38.888Z","comments":true,"path":"2018/06/10/webpack系列文章6/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章6/","excerpt":"12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ &#125;,","text":"12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ &#125;, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157 module: &#123; // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: &#123; test, include, exclude &#125;, // issuer 条件（导入源） enforce: \"pre\", enforce: \"post\", // 标识应用这些规则，即使规则覆盖（高级选项） loader: \"babel-loader\", // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: &#123; presets: [\"es2015\"] &#125;, // loader 的可选项 &#125;, &#123; test: /\\.html$/, test: \"\\.html$\" use: [ // 应用多个 loader 和选项 \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // 只使用这些嵌套规则之一 &#123; rules: [ /* rules */ ] &#125;, // 使用所有这些嵌套规则（合并可用条件） &#123; resource: &#123; and: [ /* 条件 */ ] &#125; &#125;, // 仅当所有条件都匹配时才匹配 &#123; resource: &#123; or: [ /* 条件 */ ] &#125; &#125;, &#123; resource: [ /* 条件 */ ] &#125;, // 任意条件匹配时匹配（默认为数组） &#123; resource: &#123; not: /* 条件 */ &#125; &#125; // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ &#125;, resolve: &#123; // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ \"node_modules\", path.resolve(__dirname, \"app\") ], // 用于查找模块的目录 extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 使用的扩展名 alias: &#123; // 模块别名列表 \"module\": \"new-module\", // 起别名：\"module\" -&gt; \"new-module\" 和 \"module/path/file\" -&gt; \"new-module/path/file\" \"only-module$\": \"new-module\", // 起别名 \"only-module\" -&gt; \"new-module\"，但不匹配 \"only-module/path/file\" -&gt; \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // 起别名 \"module\" -&gt; \"./app/third/module.js\" 和 \"module/file\" 会导致错误 // 模块别名相对于当前上下文导入 &#125;, /* 可供选择的别名语法（点击展示） */ /* 高级解析选项（点击展示） */ &#125;, performance: &#123; hints: \"warning\", // 枚举 maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // enum // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map' 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: \"web\", // 枚举 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: [\"react\", /^@angular\\//], // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: \"errors-only\", // 精确控制要显示的 bundle 信息 devServer: &#123; proxy: &#123; // proxy URLs to backend development server '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... &#125;, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-插件","slug":"webpack系列文章5","date":"2018-06-10T05:27:05.856Z","updated":"2018-06-10T05:32:59.393Z","comments":true,"path":"2018/06/10/webpack系列文章5/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章5/","excerpt":"插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。","text":"插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。 用法由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。 根据你的 webpack 用法，这里有多种方式使用插件： 12345678910111213141516171819202122232425const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, use: 'babel-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-loader","slug":"webpack系列文章4","date":"2018-06-10T05:19:28.972Z","updated":"2018-06-10T05:26:58.187Z","comments":true,"path":"2018/06/10/webpack系列文章4/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章4/","excerpt":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;;","text":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;; loader的使用方式 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 //不推荐就不作介绍了 CLI：在 shell 命令中指定它们。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-出口","slug":"webpack系列文章3","date":"2018-06-10T05:10:47.824Z","updated":"2018-06-10T05:17:33.215Z","comments":true,"path":"2018/06/10/webpack系列文章3/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章3/","excerpt":"配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 单个出口用法在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config;","text":"配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 单个出口用法在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config; 多个出口如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 123456789101112&#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' &#125;&#125;// 写入到硬盘：./dist/app.js, ./dist/search.js","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-入口起点","slug":"webpack系列文章2","date":"2018-06-10T04:53:45.007Z","updated":"2018-06-10T05:08:39.152Z","comments":true,"path":"2018/06/10/webpack系列文章2/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章2/","excerpt":"单个入口单个入口在上一章其实已经看到了，下面，我们主要学习下多个入口怎样创建。","text":"单个入口单个入口在上一章其实已经看到了，下面，我们主要学习下多个入口怎样创建。 多个入口1、分离 应用程序(app) 和 第三方库(vendor) 入口123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 从表面上看，这告诉我们 webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。 2、多页面应用程序1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; webpack 需要 3 个独立分离的依赖图（如上面的示例）。在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事： 使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习","slug":"webpack系列文章1","date":"2018-06-10T03:57:44.279Z","updated":"2018-06-10T04:51:28.443Z","comments":true,"path":"2018/06/10/webpack系列文章1/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章1/","excerpt":"简介webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 核心概念的理解1.入口(entry)2.输出(output)3.loader4.插件(plugins)","text":"简介webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 核心概念的理解1.入口(entry)2.输出(output)3.loader4.插件(plugins) 1、入口入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中.可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。接下来我们看一个 entry 配置的最简单例子： 123456789module.exports = &#123; context: path.join(dirname), devtool: debug ? “inline-sourcemap” : null, entry: “./src/js/index.js”, output: &#123; path: dirname, filename: “./src/bundle.js” &#125;,&#125;; 2、出口output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： 1234567891011121314 var debug = process.env.NODE_ENV !== “production”; var webpack = require(‘webpack’); var path = require(‘path’);module.exports = &#123; context: path.join(dirname), devtool: debug ? “inline-sourcemap” : null, entry: “./src/js/index.js”, output: &#123; path: dirname, filename: “./src/bundle.js” &#125;,&#125;; 3、loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在更高层面，在 webpack 的配置中 loader 有两个目标：1、test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。2、use 属性，表示进行转换时，应该使用哪个 loader。 123456789101112131415const path = require(‘path’);const config = &#123; output: &#123; filename: ‘my-first-webpack.bundle.js’ &#125;, module: &#123; rules: [ &#123; test: /.txt$/, use: ‘raw-loader’ &#125; // 也可以改成.js?$/ ] &#125;&#125;;module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。” 4、插件loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 1234567891011121314151617const HtmlWebpackPlugin = require(‘html-webpack-plugin’); // 通过 npm 安装const webpack = require(‘webpack’); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /.txt$/, use: ‘raw-loader’ &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: ‘./src/index.html’&#125;) ]&#125;;module.exports = config; 5、模式通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 123module.exports = &#123; mode: ‘production’&#125;; 以上是对webpack 作了一个简短的介绍，后面详细学习之！","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"React4-React事件与数据的双向绑定","slug":"React系列文章6","date":"2018-06-10T02:36:02.541Z","updated":"2018-06-10T02:42:32.388Z","comments":true,"path":"2018/06/10/React系列文章6/","link":"","permalink":"http://yoursite.com/2018/06/10/React系列文章6/","excerpt":"事件的绑定 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: \"IMOOC\",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"提交\" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125;","text":"事件的绑定 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: \"IMOOC\",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"提交\" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125; Props 属性： props 对于模块属于外来属性 传递参数： 在被引入模块中添加{this.props.userid} 这里面的userid就是你引用的一个参数，然后你就可以在引入该模块的文件中给这个userid进行赋值了：&lt;’被引入的模块’ userid={1220}/&gt;，这样就可以顺利的传递参数了。 模块中接受参数：this.props.username 被引入模块的示例代码：123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : \"Parry\", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 引入模块文件的示例代码：1234567891011121314151617var React = require('react');var ReactDOM = require('react-dom');import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;\"nick\"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React4-React 属性与事件","slug":"React系列文章5","date":"2018-06-10T01:55:40.442Z","updated":"2018-06-10T02:31:27.249Z","comments":true,"path":"2018/06/10/React系列文章5/","link":"","permalink":"http://yoursite.com/2018/06/10/React系列文章5/","excerpt":"State属性 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\", age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;","text":"State属性 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\", age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; Props 属性： props 对于模块属于外来属性 传递参数： 在被引入模块中添加{this.props.userid} 这里面的userid就是你引用的一个参数，然后你就可以在引入该模块的文件中给这个userid进行赋值了：&lt;’被引入的模块’ userid={1220}/&gt;，这样就可以顺利的传递参数了。 模块中接受参数：this.props.username 被引入模块的示例代码：123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : \"Parry\", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 引入模块文件的示例代码：1234567891011121314151617var React = require('react');var ReactDOM = require('react-dom');import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;\"nick\"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React4-React生命周期","slug":"React系列文章4","date":"2018-06-09T07:20:23.219Z","updated":"2018-06-12T00:25:56.288Z","comments":true,"path":"2018/06/09/React系列文章4/","link":"","permalink":"http://yoursite.com/2018/06/09/React系列文章4/","excerpt":"React生命周期官方文档React生命周期图例：","text":"React生命周期官方文档React生命周期图例： React生命周期代码示例：12345678910111213141516171819202122232425262728293031import React from 'react';export default class BodyIndex extends React.Component&#123;//定义页面将要加载 componentWillMount()&#123; //定义你的逻辑即可 console.log(\"BodyIndex - componentWillMount\"); &#125;//定义页面加载完成 componentDidMount()&#123; console.log(\"BodyIndex - componentDidMount\"); &#125; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React3-React内置表达式","slug":"React系列文章3","date":"2018-06-09T06:44:17.938Z","updated":"2018-06-12T00:30:36.755Z","comments":true,"path":"2018/06/09/React系列文章3/","link":"","permalink":"http://yoursite.com/2018/06/09/React系列文章3/","excerpt":"三元表达式：12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component&#123; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125;","text":"三元表达式：12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component&#123; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125; React 三元表达式 {window.userName == ‘’ ? ‘默认用户名’ : ‘用户名： ‘ + userName} 注意是== ， 而不是”=” React 传参 disabled={boolInput} 不要用”” 而是用{}; React注释如何来写 如果在代码块里面： {/注释/} 在代码块外面： //comments React如果要显示html里面的空格 HTML 要显示可以进行 Unicode 转码","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React2-React组件化","slug":"React系列文章2","date":"2018-06-09T01:20:02.116Z","updated":"2018-06-09T07:01:36.714Z","comments":true,"path":"2018/06/09/React系列文章2/","link":"","permalink":"http://yoursite.com/2018/06/09/React系列文章2/","excerpt":"React 机制","text":"React 机制 React 组件 组件是 React 的一个主要特性 组件对于模块化开发的重要性 组件的 return 函数里返回的 HTML 节点必须是一个 可以给外部使用的组件定义：export default class ComponentHeader extends React.Component{} 入口的定义：ReactDOM.render(, document.getElementById(‘example’)); 组件return 函数返回Html的节点必须是一个 index.js 里面代码示例:12345678910111213141516import React from 'react';import PCHeader from './pc_header';import PCFooter from './pc_footer';import PCNewsContainer from './pc_newscontainer';export default class PCIndex extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;PCHeader&gt;&lt;/PCHeader&gt; &lt;PCNewsContainer&gt;&lt;/PCNewsContainer&gt; &lt;PCFooter&gt;&lt;/PCFooter&gt; &lt;/div&gt; ); &#125;;&#125; pc_header.js 里面代码示例:1234567891011import React from 'react';import &#123;Row, Col&#125; from 'antd';import &#123;Router, Route, Link, browserHistory&#125; from 'react-router'class PCHeader extends React.Component &#123;render()&#123; return( &lt;h1&gt;这是页头&lt;/h1&gt; );&#125; &#125; React 多组件嵌套通过上面的示例我们可以看到：组件也可以通过参数的形式传递。把pc_header.js 组件作为一个参数传递到index.js里面。 这样我们可以分别开发页面不同的部分，非常方便。 需要注意的有两点： 命名的规范化。 项目搭建的规范化。 这里我们需要注意一个项目怎么去搭建项目的结构，下面是示例图片，可以参考下：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React1-react简介及安装","slug":"react系列1","date":"2018-06-05T13:19:48.562Z","updated":"2018-06-09T06:40:55.284Z","comments":true,"path":"2018/06/05/react系列1/","link":"","permalink":"http://yoursite.com/2018/06/05/react系列1/","excerpt":"本文主要讲述使用react创建一个新闻站点的技术教程，本文主要技术来源于：慕课网。如果你感兴趣，可以跟着一起来完成。 React的简介 Facebook 内部用来开发Instagram JavaScript MVC框架 React 开源网址：React github React 中文文档：React中文文档","text":"本文主要讲述使用react创建一个新闻站点的技术教程，本文主要技术来源于：慕课网。如果你感兴趣，可以跟着一起来完成。 React的简介 Facebook 内部用来开发Instagram JavaScript MVC框架 React 开源网址：React github React 中文文档：React中文文档 学习React需要掌握的知识 JS ES5/Es6 ——会使用babel ——&gt; 中文文档：babel NodeJS CSS HTML React 安装及管理 确保先安装了node.js —-最新的node.js包已经包含了npm 怎么查看是否安装？ node -v npm -v npm 换镜像源 （用淘宝的源就可以） 这样下载就比较快了 最好采用npm 安装管理 （官方推荐方式） 用npm 安装React 项目初始化 1npm init 通过初始化就建立了一个react的配置文件，下面再进行安装react需要的其他依赖包。 安装依赖包可以有两种方式：1、先在配置文件里加入需要安装的文件包名和版本，然后通过npm install 来进行安装2、直接用npm来安装 方式如下：npm install babel-preset-es2015@版本号 –save 这样你安装的包就可以把安装依赖的信息存储到配置文件里了 这里我们需要安装的依赖包有babel-preset-es2015 、babelify、babel-preset-react、react、react-dom 等 其他需要的依赖包可以在后续不断加入 注： 如果要全局安装的话可以这样 npm install -g react 至此，我们还不能实现react的正常输出，我们还需要通过webpack来打包。 webpack 的安装 在安装webpack之前，先了解下react的写作流程：先在项目文件里建立一个src文件夹在里面建一个index.js文件 这个文件要传到外面的文件index.html。index.js里这样写： 12345678910var React = require(\"react\");var ReactDOM = require(\"react-dom\");class Index extends React.Component &#123; render() &#123; return( &lt;h1&gt;hello world&lt;/h1&gt; document.getElementById('example') ); &#125;&#125; index.html里这样写：12&lt;div id=\"example\"&gt;123&lt;/div&gt;&lt;script src=\"./src/bundle.js\"&gt;&lt;/script&gt; 这里引入的bundle.js 就是webpack 生成的，他是把我们之前写的index.js生成了浏览器能识别的js文件，这样才能被浏览器识别。 webpack正式安装首先定义一个webpack的配置文件：webpack config.js 通过官方文档来配置。安装：全局安装一下：12npm install -g webpacknpm install -g webpack-dev-server //服务器 项目目录里安装一下：12npm install webpack --savenpm install webpack-dev-server --save //服务器 注： 一定要注意版本的问题，要和react等合适，如果都是最新的应该没问题。 下面来运行： webpack //在命令行执行就会把我们的index.js生成可识别的js文件了。 怎样自动加载呢： webpack-dev-server --contentbase -src --inline //执行后就可以自动加载了","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]}]}