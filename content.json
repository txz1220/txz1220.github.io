{"meta":{"title":"KAIGE","subtitle":null,"description":null,"author":"KAIGE","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"webpack基础知识学习-配置","slug":"webpack系列文章6","date":"2018-06-10T05:33:06.854Z","updated":"2018-06-10T05:36:38.888Z","comments":true,"path":"2018/06/10/webpack系列文章6/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章6/","excerpt":"12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ &#125;,","text":"12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ &#125;, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157 module: &#123; // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: &#123; test, include, exclude &#125;, // issuer 条件（导入源） enforce: \"pre\", enforce: \"post\", // 标识应用这些规则，即使规则覆盖（高级选项） loader: \"babel-loader\", // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: &#123; presets: [\"es2015\"] &#125;, // loader 的可选项 &#125;, &#123; test: /\\.html$/, test: \"\\.html$\" use: [ // 应用多个 loader 和选项 \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // 只使用这些嵌套规则之一 &#123; rules: [ /* rules */ ] &#125;, // 使用所有这些嵌套规则（合并可用条件） &#123; resource: &#123; and: [ /* 条件 */ ] &#125; &#125;, // 仅当所有条件都匹配时才匹配 &#123; resource: &#123; or: [ /* 条件 */ ] &#125; &#125;, &#123; resource: [ /* 条件 */ ] &#125;, // 任意条件匹配时匹配（默认为数组） &#123; resource: &#123; not: /* 条件 */ &#125; &#125; // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ &#125;, resolve: &#123; // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ \"node_modules\", path.resolve(__dirname, \"app\") ], // 用于查找模块的目录 extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 使用的扩展名 alias: &#123; // 模块别名列表 \"module\": \"new-module\", // 起别名：\"module\" -&gt; \"new-module\" 和 \"module/path/file\" -&gt; \"new-module/path/file\" \"only-module$\": \"new-module\", // 起别名 \"only-module\" -&gt; \"new-module\"，但不匹配 \"only-module/path/file\" -&gt; \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // 起别名 \"module\" -&gt; \"./app/third/module.js\" 和 \"module/file\" 会导致错误 // 模块别名相对于当前上下文导入 &#125;, /* 可供选择的别名语法（点击展示） */ /* 高级解析选项（点击展示） */ &#125;, performance: &#123; hints: \"warning\", // 枚举 maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // enum // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map' 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: \"web\", // 枚举 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: [\"react\", /^@angular\\//], // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: \"errors-only\", // 精确控制要显示的 bundle 信息 devServer: &#123; proxy: &#123; // proxy URLs to backend development server '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... &#125;, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-插件","slug":"webpack系列文章5","date":"2018-06-10T05:27:05.856Z","updated":"2018-06-10T05:32:59.393Z","comments":true,"path":"2018/06/10/webpack系列文章5/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章5/","excerpt":"插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。","text":"插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。 用法由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。 根据你的 webpack 用法，这里有多种方式使用插件： 12345678910111213141516171819202122232425const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, use: 'babel-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-loader","slug":"webpack系列文章4","date":"2018-06-10T05:19:28.972Z","updated":"2018-06-10T05:26:58.187Z","comments":true,"path":"2018/06/10/webpack系列文章4/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章4/","excerpt":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;;","text":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;; loader的使用方式 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 //不推荐就不作介绍了 CLI：在 shell 命令中指定它们。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-出口","slug":"webpack系列文章3","date":"2018-06-10T05:10:47.824Z","updated":"2018-06-10T05:17:33.215Z","comments":true,"path":"2018/06/10/webpack系列文章3/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章3/","excerpt":"配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 单个出口用法在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config;","text":"配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 单个出口用法在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config; 多个出口如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 123456789101112&#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' &#125;&#125;// 写入到硬盘：./dist/app.js, ./dist/search.js","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-入口起点","slug":"webpack系列文章2","date":"2018-06-10T04:53:45.007Z","updated":"2018-06-10T05:08:39.152Z","comments":true,"path":"2018/06/10/webpack系列文章2/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章2/","excerpt":"单个入口单个入口在上一章其实已经看到了，下面，我们主要学习下多个入口怎样创建。","text":"单个入口单个入口在上一章其实已经看到了，下面，我们主要学习下多个入口怎样创建。 多个入口1、分离 应用程序(app) 和 第三方库(vendor) 入口123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 从表面上看，这告诉我们 webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。 2、多页面应用程序1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; webpack 需要 3 个独立分离的依赖图（如上面的示例）。在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事： 使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习","slug":"webpack系列文章1","date":"2018-06-10T03:57:44.279Z","updated":"2018-06-10T04:51:28.443Z","comments":true,"path":"2018/06/10/webpack系列文章1/","link":"","permalink":"http://yoursite.com/2018/06/10/webpack系列文章1/","excerpt":"简介webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 核心概念的理解1.入口(entry)2.输出(output)3.loader4.插件(plugins)","text":"简介webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 核心概念的理解1.入口(entry)2.输出(output)3.loader4.插件(plugins) 1、入口入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中.可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。接下来我们看一个 entry 配置的最简单例子： 123456789module.exports = &#123; context: path.join(dirname), devtool: debug ? “inline-sourcemap” : null, entry: “./src/js/index.js”, output: &#123; path: dirname, filename: “./src/bundle.js” &#125;,&#125;; 2、出口output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： 1234567891011121314 var debug = process.env.NODE_ENV !== “production”; var webpack = require(‘webpack’); var path = require(‘path’);module.exports = &#123; context: path.join(dirname), devtool: debug ? “inline-sourcemap” : null, entry: “./src/js/index.js”, output: &#123; path: dirname, filename: “./src/bundle.js” &#125;,&#125;; 3、loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在更高层面，在 webpack 的配置中 loader 有两个目标：1、test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。2、use 属性，表示进行转换时，应该使用哪个 loader。 123456789101112131415const path = require(‘path’);const config = &#123; output: &#123; filename: ‘my-first-webpack.bundle.js’ &#125;, module: &#123; rules: [ &#123; test: /.txt$/, use: ‘raw-loader’ &#125; // 也可以改成.js?$/ ] &#125;&#125;;module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。” 4、插件loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 1234567891011121314151617const HtmlWebpackPlugin = require(‘html-webpack-plugin’); // 通过 npm 安装const webpack = require(‘webpack’); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /.txt$/, use: ‘raw-loader’ &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: ‘./src/index.html’&#125;) ]&#125;;module.exports = config; 5、模式通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 123module.exports = &#123; mode: ‘production’&#125;; 以上是对webpack 作了一个简短的介绍，后面详细学习之！","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"React4-React事件与数据的双向绑定","slug":"React系列文章6","date":"2018-06-10T02:36:02.541Z","updated":"2018-06-10T02:42:32.388Z","comments":true,"path":"2018/06/10/React系列文章6/","link":"","permalink":"http://yoursite.com/2018/06/10/React系列文章6/","excerpt":"事件的绑定 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: \"IMOOC\",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"提交\" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125;","text":"事件的绑定 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: \"IMOOC\",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"提交\" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125; Props 属性： props 对于模块属于外来属性 传递参数： 在被引入模块中添加{this.props.userid} 这里面的userid就是你引用的一个参数，然后你就可以在引入该模块的文件中给这个userid进行赋值了：&lt;’被引入的模块’ userid={1220}/&gt;，这样就可以顺利的传递参数了。 模块中接受参数：this.props.username 被引入模块的示例代码：123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : \"Parry\", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 引入模块文件的示例代码：1234567891011121314151617var React = require('react');var ReactDOM = require('react-dom');import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;\"nick\"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React4-React 属性与事件","slug":"React系列文章5","date":"2018-06-10T01:55:40.442Z","updated":"2018-06-10T02:31:27.249Z","comments":true,"path":"2018/06/10/React系列文章5/","link":"","permalink":"http://yoursite.com/2018/06/10/React系列文章5/","excerpt":"State属性 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\", age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;","text":"State属性 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\", age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; Props 属性： props 对于模块属于外来属性 传递参数： 在被引入模块中添加{this.props.userid} 这里面的userid就是你引用的一个参数，然后你就可以在引入该模块的文件中给这个userid进行赋值了：&lt;’被引入的模块’ userid={1220}/&gt;，这样就可以顺利的传递参数了。 模块中接受参数：this.props.username 被引入模块的示例代码：123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : \"Parry\", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 引入模块文件的示例代码：1234567891011121314151617var React = require('react');var ReactDOM = require('react-dom');import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;\"nick\"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React4-React生命周期","slug":"React系列文章4","date":"2018-06-09T07:20:23.219Z","updated":"2018-06-09T07:37:13.779Z","comments":true,"path":"2018/06/09/React系列文章4/","link":"","permalink":"http://yoursite.com/2018/06/09/React系列文章4/","excerpt":"React生命周期官方文档React生命周期图例：","text":"React生命周期官方文档React生命周期图例： React生命周期代码示例：12345678910111213141516171819202122232425262728293031import React from 'react';export default class BodyIndex extends React.Component&#123;//定义页面将要加载 componentWillMount()&#123; //定义你的逻辑即可 console.log(\"BodyIndex - componentWillMount\"); &#125;//定义页面加载完成 componentDidMount()&#123; console.log(\"BodyIndex - componentDidMount\"); &#125; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React3-React内置表达式","slug":"React系列文章3","date":"2018-06-09T06:44:17.938Z","updated":"2018-06-09T07:24:11.690Z","comments":true,"path":"2018/06/09/React系列文章3/","link":"","permalink":"http://yoursite.com/2018/06/09/React系列文章3/","excerpt":"三元表达式：12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component&#123; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125;","text":"三元表达式：12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component&#123; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125; React 三元表达式 {window.userName == ‘’ ? ‘默认用户名’ : ‘用户名： ‘ + userName} 注意是== ， 而不是”=” React 传参 disabled={boolInput} 不要用”” 而是用{}; React注释如何来写 如果在代码块里面： {/注释/} 在代码块外面： //comments React如果要显示html里面的空格 HTML 要显示可以进行 Unicode 转码","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React2-React组件化","slug":"React系列文章2","date":"2018-06-09T01:20:02.116Z","updated":"2018-06-09T07:01:36.714Z","comments":true,"path":"2018/06/09/React系列文章2/","link":"","permalink":"http://yoursite.com/2018/06/09/React系列文章2/","excerpt":"React 机制","text":"React 机制 React 组件 组件是 React 的一个主要特性 组件对于模块化开发的重要性 组件的 return 函数里返回的 HTML 节点必须是一个 可以给外部使用的组件定义：export default class ComponentHeader extends React.Component{} 入口的定义：ReactDOM.render(, document.getElementById(‘example’)); 组件return 函数返回Html的节点必须是一个 index.js 里面代码示例:12345678910111213141516import React from 'react';import PCHeader from './pc_header';import PCFooter from './pc_footer';import PCNewsContainer from './pc_newscontainer';export default class PCIndex extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;PCHeader&gt;&lt;/PCHeader&gt; &lt;PCNewsContainer&gt;&lt;/PCNewsContainer&gt; &lt;PCFooter&gt;&lt;/PCFooter&gt; &lt;/div&gt; ); &#125;;&#125; pc_header.js 里面代码示例:1234567891011import React from 'react';import &#123;Row, Col&#125; from 'antd';import &#123;Router, Route, Link, browserHistory&#125; from 'react-router'class PCHeader extends React.Component &#123;render()&#123; return( &lt;h1&gt;这是页头&lt;/h1&gt; );&#125; &#125; React 多组件嵌套通过上面的示例我们可以看到：组件也可以通过参数的形式传递。把pc_header.js 组件作为一个参数传递到index.js里面。 这样我们可以分别开发页面不同的部分，非常方便。 需要注意的有两点： 命名的规范化。 项目搭建的规范化。 这里我们需要注意一个项目怎么去搭建项目的结构，下面是示例图片，可以参考下：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React1-react简介及安装","slug":"react系列1","date":"2018-06-05T13:19:48.562Z","updated":"2018-06-09T06:40:55.284Z","comments":true,"path":"2018/06/05/react系列1/","link":"","permalink":"http://yoursite.com/2018/06/05/react系列1/","excerpt":"本文主要讲述使用react创建一个新闻站点的技术教程，本文主要技术来源于：慕课网。如果你感兴趣，可以跟着一起来完成。 React的简介 Facebook 内部用来开发Instagram JavaScript MVC框架 React 开源网址：React github React 中文文档：React中文文档","text":"本文主要讲述使用react创建一个新闻站点的技术教程，本文主要技术来源于：慕课网。如果你感兴趣，可以跟着一起来完成。 React的简介 Facebook 内部用来开发Instagram JavaScript MVC框架 React 开源网址：React github React 中文文档：React中文文档 学习React需要掌握的知识 JS ES5/Es6 ——会使用babel ——&gt; 中文文档：babel NodeJS CSS HTML React 安装及管理 确保先安装了node.js —-最新的node.js包已经包含了npm 怎么查看是否安装？ node -v npm -v npm 换镜像源 （用淘宝的源就可以） 这样下载就比较快了 最好采用npm 安装管理 （官方推荐方式） 用npm 安装React 项目初始化 1npm init 通过初始化就建立了一个react的配置文件，下面再进行安装react需要的其他依赖包。 安装依赖包可以有两种方式：1、先在配置文件里加入需要安装的文件包名和版本，然后通过npm install 来进行安装2、直接用npm来安装 方式如下：npm install babel-preset-es2015@版本号 –save 这样你安装的包就可以把安装依赖的信息存储到配置文件里了 这里我们需要安装的依赖包有babel-preset-es2015 、babelify、babel-preset-react、react、react-dom 等 其他需要的依赖包可以在后续不断加入 注： 如果要全局安装的话可以这样 npm install -g react 至此，我们还不能实现react的正常输出，我们还需要通过webpack来打包。 webpack 的安装 在安装webpack之前，先了解下react的写作流程：先在项目文件里建立一个src文件夹在里面建一个index.js文件 这个文件要传到外面的文件index.html。index.js里这样写： 12345678910var React = require(\"react\");var ReactDOM = require(\"react-dom\");class Index extends React.Component &#123; render() &#123; return( &lt;h1&gt;hello world&lt;/h1&gt; document.getElementById('example') ); &#125;&#125; index.html里这样写：12&lt;div id=\"example\"&gt;123&lt;/div&gt;&lt;script src=\"./src/bundle.js\"&gt;&lt;/script&gt; 这里引入的bundle.js 就是webpack 生成的，他是把我们之前写的index.js生成了浏览器能识别的js文件，这样才能被浏览器识别。 webpack正式安装首先定义一个webpack的配置文件：webpack config.js 通过官方文档来配置。安装：全局安装一下：12npm install -g webpacknpm install -g webpack-dev-server //服务器 项目目录里安装一下：12npm install webpack --savenpm install webpack-dev-server --save //服务器 注： 一定要注意版本的问题，要和react等合适，如果都是最新的应该没问题。 下面来运行： webpack //在命令行执行就会把我们的index.js生成可识别的js文件了。 怎样自动加载呢： webpack-dev-server --contentbase -src --inline //执行后就可以自动加载了","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]}]}