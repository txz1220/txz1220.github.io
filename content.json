{"meta":{"title":"KAIGE","subtitle":null,"description":null,"author":"KAIGE","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"node 文件压缩","slug":"node学习文件压缩","date":"2018-07-03T01:48:48.425Z","updated":"2018-07-03T02:39:51.245Z","comments":true,"path":"2018/07/03/node学习文件压缩/","link":"","permalink":"http://yoursite.com/2018/07/03/node学习文件压缩/","excerpt":"","text":"简单的压/解压缩压缩在nodejs里，是如何对资源进行压缩的呢——Zlib模块。 1234567891011var fs = require ('fs');var zlib = require('zlib');var gzip = zlib.createGzip();var inFile = fs.createReadStream('./extra/fileForCompress.txt')var out = fs.createWriteStream(./extra/fileForCompress.txt.gz;)inFile.pipe(gzip).pipe(out); 解压的例子反向操作： 123456789var fs = require('fs');var zlib = require('zlib');var gunzip = zlib.createGunzip();var inFile = fs.createReadStream('./extra/fileForCompress.txt.gz');var outFile = fs.createWriteStream('./extra/fileForCompress1.txt');inFile.pipe(gunzip).pipe(outFile); 服务端gzip压缩首先判断 是否包含 accept-encoding 首部，且值为gzip。 否：返回未压缩的文件。 是：返回gzip压缩后的文件。 123456789101112131415161718192021var http = require('http');var zlib = require('zlib');var fs = require('fs');var filepath = './extra/fileForGzip.html'var server = http.createServer(function(req,res)&#123; var acceptEncoding = req.headers['accept-encoding']; var gzip; if(acceptEncoding.indexOf('gzip')!=-1)&#123; gzip = zlib.createGzip(); res.writeHead(200,&#123; 'Content-Encoding' : 'gzip' &#125;); fs.createReadStream(filepath).pipe(gzip).pipe(res); &#125;else&#123; fs.createReadStream(filepath).pipe(res); &#125;&#125;)server.listen('3000'); 服务端字符串gzip压缩代码跟前面例子大同小异。这里采用了slib.gzipSync(str)对字符串进行gzip压缩。 12345678910111213141516171819var http = require('http');var zlib = require('zlib');var responseText = 'hello world';var server = http.createServer(function(req, res)&#123; var acceptEncoding = req.headers['accept-encoding']; if(acceptEncoding.indexOf('gzip')!=-1)&#123; res.writeHead(200, &#123; 'content-encoding': 'gzip' &#125;); res.end( zlib.gzipSync(responseText) ); &#125;else&#123; res.end(responseText); &#125;&#125;);server.listen('3000'); 学习来源","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"http://yoursite.com/categories/技术/node-js/"},{"name":"文件压缩","slug":"技术/node-js/文件压缩","permalink":"http://yoursite.com/categories/技术/node-js/文件压缩/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"文件压缩","slug":"文件压缩","permalink":"http://yoursite.com/tags/文件压缩/"}]},{"title":"CSS专业技巧","slug":"css专业技巧","date":"2018-07-01T09:58:07.008Z","updated":"2018-07-01T10:35:12.443Z","comments":true,"path":"2018/07/01/css专业技巧/","link":"","permalink":"http://yoursite.com/2018/07/01/css专业技巧/","excerpt":"","text":"使用CSS复位CSS复位可以在不同的浏览器上保持一致的样式风格。您可以使用CSS reset 库normalize等，也可以使用一个更简化的复位方法： 12345* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125; 注意：如果你遵循接下来继承 box-sizing讲解的这个技巧, 你不需要在以上代码中添加 box-sizing 属性。 继承 box-sizing从 html 元素继承 box-sizing ： 123456789html &#123; box-sizing: border-box;&#125;*,*::before,*::after &#123; box-sizing: inherit;&#125; 使用unset而不是重置所有属性重置元素的属性时，不需要重置每个单独的属性： 123button &#123; all: unset;&#125; 所有速记在IE11中不被支持，目前正在考虑Edge的支持。 IE11不支持unset。 使用 :not() 选择器来决定表单是否显示边框先为元素添加边框 1234/* 添加边框 */.nav li &#123; border-right: 1px solid #666;&#125; 然后，为最后一个元素去除边框 1234/* 去掉边框 */.nav li:last-child &#123; border-right: none;&#125; 不过不要这么做，使用 :not() 伪类来达到同样的效果： 123.nav li:not(:last-child) &#123; border-right: 1px solid #666;&#125; 为 body 元素添加行高不必为每一个 ，&lt;h*&gt; 元素逐一添加 line-height，直接添加到 body 元素：123body &#123; line-height: 1.5;&#125; 文本元素可以很容易地继承 body 的样式。 垂直居中任何元素12345678910111213html,body &#123; height: 100%; margin: 0;&#125;body &#123; -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex;&#125; 逗号分隔列表使列表的每项都由逗号分隔： 123ul &gt; li:not(:last-child)::after &#123; content: \",\";&#125; 这一技巧对于无障碍，特别是屏幕阅读器而言并不理想。而且复制粘贴并不会带走CSS生成的内容,需要注意。 使用负的 nth-child 来选择元素使用负的 nth-child 可以选择 1 至 n 个元素。 12345678li &#123; display: none;&#125;/* 选择第 1 至第 3 个元素并显示出来 */li:nth-child(-n+3) &#123; display: block;&#125; 使用 “形似猫头鹰” 的选择器这个名字可能比较陌生，不过通用选择器 (*) 和 相邻兄弟选择器 (+) 一起使用，效果非凡： 123* + * &#123; margin-top: 1.5em;&#125; 在此示例中，文档流中的所有的相邻兄弟元素将都将设置 margin-top: 1.5em 的样式。 使用 max-height 来建立纯 CSS 的滑块12345678910.slider &#123; max-height: 200px; overflow-y: hidden; width: 300px;&#125;.slider:hover &#123; max-height: 600px; overflow-y: scroll;&#125; 创造格子等宽的表格table-layout: fixed 可以让每个格子保持等宽： 123.calendar &#123; table-layout: fixed;&#125; 利用 Flexbox 去除多余的外边距与其使用 nth-， first-， 和 last-child 去除列之间多余的间隙，不如使用 flexbox 的 space-between 属性： 12345678.list &#123; display: flex; justify-content: space-between;&#125;.list .person &#123; flex-basis: 23%;&#125; 利用属性选择器来选择空链接当 &lt;a&gt;元素没有文本内容，但有 href 属性的时候，显示它的 href 属性： 123a[href^=\"http\"]:empty::before &#123; content: attr(href);&#125; 给 “默认” 链接定义样式给 “默认” 链接定义样式： 1234a[href]:not([class]) &#123; color: #008000; text-decoration: underline;&#125; 一致垂直节奏通用选择器 (*) 跟元素一起使用，可以保持一致的垂直节奏： 123.intro &gt; * &#123; margin-bottom: 1.25rem;&#125; 固定比例盒子要创建具有固定比例的一个盒子，所有你需要做的就是给 div 设置一个 padding： 1234567891011121314.container &#123; height: 0; padding-bottom: 20%; position: relative;&#125;.container div &#123; border: 2px dashed #ddd; height: 100%; left: 0; position: absolute; top: 0; width: 100%;&#125; 使用20％的padding-bottom使得框等于其宽度的20％的高度。与视口宽度无关，子元素的div将保持其宽高比（100％/ 20％= 5:1）。 为破碎图象定义样式只要一点CSS就可以美化破碎的图象： 1234567891011img::before &#123; content: \"We're sorry, the image below is broken :(\"; display: block; margin-bottom: 10px;&#125;img::after &#123; content: \"(url: \" attr(src) \")\"; display: block; font-size: 12px;&#125; 用 rem 来调整全局大小；用 em 来调整局部大小在根元素设置基本字体大小后 (html { font-size: 100%; }), 使用 em 设置文本元素的字体大小: 1234567h2 &#123; font-size: 2em;&#125;p &#123; font-size: 1em;&#125; 然后设置模块的字体大小为 rem: 1234567article &#123; font-size: 1.25rem;&#125;aside .module &#123; font-size: .9rem;&#125; 现在，每个模块变得独立，更容易、灵活的样式便于维护。rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。 使用选择器:root来控制字体弹性在响应式布局中，字体大小应需要根据不同的视口进行调整。你可以计算字体大小根据视口高度的字体大小和宽度，这时需要用到:root:123:root &#123; font-size: calc(1vw + 1vh + .5vmin);&#125; 现在，您可以使用 root em 123body &#123; font: 1rem/1.6 sans-serif;&#125; 使用指针事件來控制鼠标事件指针事件允許您指定鼠标如何与其触摸的元素进行交互。 要禁用按钮上的默认指针事件，例如： 1234.button-disabled &#123; opacity: .5; pointer-events: none;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"css","slug":"技术/css","permalink":"http://yoursite.com/categories/技术/css/"},{"name":"CSS专业技巧","slug":"技术/css/CSS专业技巧","permalink":"http://yoursite.com/categories/技术/css/CSS专业技巧/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"CSS专业技巧","slug":"CSS专业技巧","permalink":"http://yoursite.com/tags/CSS专业技巧/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2018-07-01T08:33:46.578Z","updated":"2018-07-03T06:22:39.644Z","comments":true,"path":"2018/07/01/正则表达式/","link":"","permalink":"http://yoursite.com/2018/07/01/正则表达式/","excerpt":"","text":"什么是正则简单来说，正则就可以理解为一个规则，用来处理字符串的一个规则（正则就是用来处理字符串的），这里所说处理一般是包含匹配和捕获。 匹配：判断一个字符串是否符合指定的规则，使用test方法：reg.test(str) 1234var reg = /\\d/; // 包含一个0~9之间的数字console.log(reg.test('天')); // falseconsole.log(reg.test('1')); // trueconsole.log(reg.test('现在是2017')); // true，只要包含了数字就返回true 捕获：把字符串中符合指定的正则规则的内容捕获到，使用exec方法：reg.exec(str) 12345var reg = /\\d/;console.log(reg.exec('天')); // nullconsole.log(reg.exec('1')); // [\"1\", index: 0, input: \"1\"]console.log(reg.exec('现在是2017')); // [\"2\", index: 3, input: \"现在是2017\"] 如何创建正则字面量方式1var reg = /\\d/; 实例方式 1var reg = new RegExp('/\\d/'); 正则的组成从上面的内容中已经了解到，每一个正则表达式是包含在//中的，正则表达式就是匹配规则，正则的组成就是元字符和修饰符。 元字符具有特殊意义的元字符 \\：转义字符，转义后面字符所代表的含义 ^：以某一个元字符开始 $：以某一个元字符结束 \\n：匹配一个换行符 .：除了\\n以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 语法： \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 如果就是想要匹配 . 或者?这样的字符呢？转义字符 \\. * \\? 12345678var reg = /^0.2$/; // 以0开头，以2结尾，中间可以是除了\\n的任意字符console.log(reg.test('0.2')); // trueconsole.log(reg.test('0-2')); // truereg = /^0\\.2$/; // 将\".\"转义console.log(reg.test('0.2')); // trueconsole.log(reg.test('0-2')); // false 代表出现次数的量词元字符 *：出现0到多次 +：出现1到多次 ?：出现0次或者1次 {n}：出现n次 {n,m}：出现n到m次 12var reg = /^\\d+$/;console.log(reg.test('2015')); // true 修饰符 x|y：x或y中的一个 [xyz]：x或y或z中的一个 [^xyz]：除了xyz以外的任意一个字符 [a-z]：a-z之间的任何一个字符 [^a-z]：除了a-z之间的任何一个字符 \\d：一个0~9之间的数字 \\D：除了0~9之间的数字以外的任何字符 \\b：一个边界符 \\w：数字、字母、下划线中的任意一个字符 \\s：匹配一个空白字符、空格 ()：分组，把一个大正则本身划分成几个小的正则，例如：var reg = /^(\\d+)zhufeng(\\d+)$/; 分枝条件 用|把不同的规则分隔开 从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了 0\\d{2}-\\d{8}|0\\d{3}-\\d{7} 元字符的应用[]的规律 在中括号中出现的所有的字符都是代表本身的意思的字符（没有特殊含义） 123456var reg = /^[.]$/; console.log(reg.test('1')); // false console.log(reg.test('.')); // true reg = /^[\\w-]$/; // 数字、字母、下划线、- 中的一个 console.log(reg.test('-')); // true 中括号不识别两位数 12var reg = /^[12]$/; // --&gt; 1或者2中的一个（符合[xyz]）var reg = /^[12-68]$/; // --&gt; 1、2-6中的一个、8 三个中的一个 ()的作用分组的作用有很多，现在先讲其中的一个：改变x|y的默认的优先级，还有的在后面的内容会详细介绍。 12var reg = /^18|19$/; // 18、19、181、189、119、819、1819这些都符合var reg = /^(18|19)$/; // 只能18或者19 应用一：有效数字的正则有效数字可以是正数、负数、零、小数，所以其特点为： “.”可以出现也可以不出现，一旦出现，后面必须跟着一位或多为数字； 最开始可能有“+/-”，也可以没有； 整数部分，一位数的情况可以是0-9中的一个，多位数的情况下不能以0开头 1var reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/; 应用二：年龄介于18~65之间年龄介于18~65之间的数字可以是18-19、20-59、60-65。 1var reg = /^1[8-9]|[2-5]\\d|6[0-5]$/; 应用三：简单的邮箱验证1var reg = /^[\\w.-]+@[0-9a-zA-Z]+(\\.[a-zA-Z]&#123;2,4&#125;)&#123;1,2&#125;$/; 两种方式创建正则的区别 字面量方式中出现的一切都是元字符，不能进行变量值的拼接，而实例创建的方式可以； 字面量方式中直接写\\d可以，而在实例中需要把它转义 \\d 正则的捕获及其贪婪性和懒惰性在上面有介绍到正则的捕获使用exec方法。在每一次捕获的时候都是先进行默认的匹配，如果没有匹配成功，则捕获的结果是null。只有有匹配的内容，才能捕获到。 懒惰性定义正则及字符串： 12var reg = /\\d+/;var str = 'iceman2016learn2017'; reg默认有一个lastIndex字段，该字段是正则每一次捕获时，在字符串中开始查找的位置，默认的值是0。 现在先进行第一次捕获： 123console.log(reg.lastIndex); // 0，第一次捕获的时候，从字符串索引0处开始查找var res = reg.exec(str);console.log(res); // [\"2016\", index: 6, input: \"iceman2016learn2017\"] 从代码的输出可知，正则捕获的内容格式：捕获到的内容是一个数组 数组的第一项是当前大正则捕获的内容； 有一项是index：捕获内容在字符串中开始的索引位置； 有一项是input：捕获的原始字符串； 现在进行第二次捕获： 1234console.log(reg.lastIndex); // 0 说明第二次捕获的时候，也要从字符串索引0处开始查找// 第二次通过exec捕获的内容还是第一个\"2016\"res = reg.exec(str);console.log(res); //[\"2016\", index: 6, input: \"iceman2016learn2017\"] 由上面的两次捕获可知，每次的捕获都是从字符串的索引0处开始查找的，这就是正则的懒惰型。 很明显正则的懒惰性是我们所要解决的问题，那么该如何解决懒惰性呢？ 答案就是在正则的末尾加一个修饰“g”（全局匹配），类似g这样的修饰符还有两个：i、m，这三者的作用是： global（g）：全局匹配 ignoreCase（i）：忽略大小写 multiline（m）：多行匹配 12345678910var reg = /\\d+/g;var str = 'iceman2016learn2017';console.log(reg.lastIndex); // 0console.log(reg.exec(str)); // [\"2016\", index: 6, input: \"iceman2016learn2017\"]console.log(reg.lastIndex); // 10console.log(reg.exec(str)); // [\"2017\", index: 15, input: \"iceman2016learn2017\"]console.log(reg.lastIndex); // 19console.log(reg.exec(str)); // null 贪婪性123var reg = /\\d+/g; // 出现一到多个0~9之间的数字var str = 'iceman2016learn2017javascript2018';console.log(reg.exec(str)); // [\"2016\", index: 6, input: \"iceman2016learn2017javascript2018\"] 看到这段代码的时候不知道您有没有一些疑惑，正则的内容是/\\d+/，是匹配1到多个数字，2016是符合正则的，那么2也是符合正则的啊，为什么默认就捕获了2016呢？ 这就是正则的贪婪性。 如何解决正则的贪婪性：在量词元字符后面添加一个”?”即可 123456789var reg = /\\d+?/g; // 出现一到多个0~9之间的数字var str = 'iceman2016learn2017javascript2018';console.log(reg.exec(str)); // [\"2\", index: 6, input: \"iceman2016learn2017javascript2018\"]var ary = [] , res = reg.exec(str);while (res) &#123; ary.push(res[0]); res = reg.exec(str)&#125;console.log(ary); // [\"0\", \"1\", \"6\", \"2\", \"0\", \"1\", \"7\", \"2\", \"0\", \"1\", \"8\"] “?”在正则中的作用： 放在一个普通的元字符后面，代表出现0~1次； 放在一个量词的元字符后面，取消捕获时候的贪婪性； 字符串中的match方法match方法的作用是，把所有和正则匹配的字符都获取到。 1234var reg = /\\d+?/g;var str = 'zhufeng2015peixun2016dasgdas2017';var ary = str.match(reg);console.log(ary); // [\"2\", \"0\", \"1\", \"5\", \"2\", \"0\", \"1\", \"6\", \"2\", \"0\", \"1\", \"7\"] 虽然在当前的情况下，match比exec更加的简洁一些，但是match存在一些自己处理不了的问题：在分组捕获的情况下，match只能捕获到大正则，而对于小正则捕获的内容是无法获取的。 分组捕获","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"js","slug":"技术/js","permalink":"http://yoursite.com/categories/技术/js/"},{"name":"正则表达式","slug":"技术/js/正则表达式","permalink":"http://yoursite.com/categories/技术/js/正则表达式/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"CSS 各种用法","slug":"css巧用方法","date":"2018-07-01T02:47:10.432Z","updated":"2018-07-01T07:16:40.468Z","comments":true,"path":"2018/07/01/css巧用方法/","link":"","permalink":"http://yoursite.com/2018/07/01/css巧用方法/","excerpt":"","text":"一、CSS写自适应大小的正方形12345678910111213141516171819202122232425262728293031&lt;style type=\"text/css\"&gt;/* 以图片为例background 写法 */ .img&#123; width: 100%; height: 0; padding-bottom: 100%; //关键所在 overflow: hidden; background:url(../res/images/haha.png) center/100% 100% no-repeat; &#125; .img img&#123; width: 100%; &#125;/* img 写法 */ .img&#123; position: relative; width: 100%; height: 0; padding-bottom: 100%; //关键所在 overflow: hidden; &#125; .img img&#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; &#125;&lt;/style&gt;&lt;div class=\"img\"&gt;&lt;/div&gt; 二、多列等高代码： 123456789101112131415161718192021&lt;style type=\"text/css\"&gt; .web_width&#123; width: 100%; overflow: hidden; //关键所在 &#125; .left&#123; float: left; width: 20%; min-height: 10em; background: #66afe9; padding-bottom: 2000px; //关键所在 margin-bottom: -2000px; //关键所在 &#125; .right&#123; float: right; width: 80%; height: 20em; background: #f00; &#125;&lt;/style&gt; padding补偿法 在高度小的元素上加一个数值为正padding-bottom和一个数值为负margin-bottom，再在父级加上overflow: hidden隐藏子元素超出的padding-bottom padding-bottom、margin-bottom之和要等于0（建议值不要太大，够用就行） 三、绘制三角形代码 123456789&lt;style type=\"text/css\"&gt;.demo &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 50px solid red;&#125;&lt;/style&gt; 利用盒模型中的border属性当盒模型的width/height为 0 时，border 边的形状是一个三角形，通过只设置三条边的 border ，并将所绘制的三角形相邻两边的 border 的颜色设置为 transparent, 最后通过调整border-width的比例绘制自己所需要的三角形","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"css 各种用法","slug":"技术/前端基础知识/css-各种用法","permalink":"http://yoursite.com/categories/技术/前端基础知识/css-各种用法/"}],"tags":[{"name":"CSS 各种用法","slug":"CSS-各种用法","permalink":"http://yoursite.com/tags/CSS-各种用法/"}]},{"title":"动画","slug":"动画","date":"2018-07-01T02:10:30.444Z","updated":"2018-07-01T02:45:40.449Z","comments":true,"path":"2018/07/01/动画/","link":"","permalink":"http://yoursite.com/2018/07/01/动画/","excerpt":"","text":"transition 与 animation 的选用元素一旦绑定 transition 之后，会对下个 Event Loop 中变更的样式（如异步 hover 或通过 js 变更 style/class），给予过度效果。要想更细颗粒度定制动画，可为元素添加诸如 animation: keyframeName 1s 的样式，animation 在绑定时立即执行动画。 两者有一些异同之处： transition 需在绑定后的下一个 Event Loop 中实现动画，而 animation 在当时立即执行，因此，transition 常用于反复执行的场合，如 hover、toggle 等 animation 在绑定时候立即执行，执行完会默认恢复到原态，所以在 0% 帧和 100% 帧处可能有跳变，如果加上 animation-fill-mode: forwards 属性，会保持 100% 帧的，像 transition 动画那样。因此在串联执行多个 animation 动画时，常用 forwards 来保持连贯，避免每次都要“重头再来”。 两者都可在后续的 Event Loop 中修改样式，触发动画 animation 中省略样式的帧animation 在时间粒度上的操控更灵活，可以通过 % 来定义特定时间帧。我们先来看一个案例，其中 color 样式并未在 0% 帧定义。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"css","slug":"技术/css","permalink":"http://yoursite.com/categories/技术/css/"},{"name":"动画","slug":"技术/css/动画","permalink":"http://yoursite.com/categories/技术/css/动画/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}]},{"title":"promise","slug":"promise理解","date":"2018-06-30T12:54:39.177Z","updated":"2018-06-30T12:55:36.645Z","comments":true,"path":"2018/06/30/promise理解/","link":"","permalink":"http://yoursite.com/2018/06/30/promise理解/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"js","slug":"技术/js","permalink":"http://yoursite.com/categories/技术/js/"},{"name":"promise","slug":"技术/js/promise","permalink":"http://yoursite.com/categories/技术/js/promise/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"}]},{"title":"编码规范","slug":"编码规范","date":"2018-06-30T03:44:40.091Z","updated":"2018-06-30T12:13:12.836Z","comments":true,"path":"2018/06/30/编码规范/","link":"","permalink":"http://yoursite.com/2018/06/30/编码规范/","excerpt":"一定要培养自己好的编码习惯！","text":"一定要培养自己好的编码习惯！ 一、命名规范项目命名全部采用小写方式， 以下划线分隔。 例：my_project_name 目录命名参照项目命名规则； 有复数结构时，要采用复数命名法。 例：scripts, styles, images, data_models JS文件命名参照项目命名规则。 例：account_model.js CSS, SCSS文件命名参照项目命名规则。 例：retina_sprites.scss HTML文件命名参照项目命名规则。 例：error_report.html 二、html语法语法 缩进使用soft tab（4个空格）； 嵌套的节点应该缩进； 在属性上，使用双引号，不要使用单引号； 属性名全小写，用中划线做分隔符； 不要在自动闭合标签结尾处使用斜线（HTML5 规范 指出他们是可选的）； 不要忽略可选的关闭标签，例：&lt;/li&gt; 和 &lt;/body&gt;。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Page title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"images/company_logo.png\" alt=\"Company\"&gt; &lt;h1 class=\"hello-world\"&gt;Hello, world!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; HTML5 doctype在页面开头使用这个简单地doctype来启用标准模式，使其在每个浏览器中尽可能一致的展现； 虽然doctype不区分大小写，但是按照惯例，doctype大写 1234&lt;!DOCTYPE html&gt;&lt;html&gt; ...&lt;/html&gt; lang属性根据HTML5规范： 应在html标签上加上lang属性。这会给语音工具和翻译工具帮助，告诉它们应当怎么去发音和翻译。 1234&lt;!DOCTYPE html&gt;&lt;html lang=\"en-us\"&gt; ...&lt;/html&gt; 字符编码通过声明一个明确的字符编码，让浏览器轻松、快速的确定适合网页内容的渲染方式，通常指定为’UTF-8’。 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; ...&lt;/html&gt; IE兼容模式用 &lt;meta&gt; 标签可以指定页面应该用什么版本的IE来渲染； 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt; &lt;/head&gt; ...&lt;/html&gt; 引入CSS, JS根据HTML5规范, 通常在引入CSS和JS时不需要指明 type，因为 text/css 和 text/javascript 分别是他们的默认值。 属性顺序属性应该按照特定的顺序出现以保证易读性； classidnamedata-src, for, type, href, value , max-length, max, min, patternplaceholder, title, altaria-, rolerequired, readonly, disabledclass是为高可复用组件设计的，所以应处在第一位； id更加具体且应该尽量少使用，所以将它放在第二位。 减少标签数量在编写HTML代码时，需要尽量避免多余的父节点； 很多时候，需要通过迭代和重构来使HTML变得更少。 1234567&lt;!-- Not well --&gt;&lt;span class=\"avatar\"&gt; &lt;img src=\"...\"&gt;&lt;/span&gt;&lt;!-- Better --&gt;&lt;img class=\"avatar\" src=\"...\"&gt; 三、css scss缩进使用soft tab（4个空格）。 123456789.element &#123; position: absolute; top: 10px; left: 10px; border-radius: 10px; width: 50px; height: 50px;&#125; 分号每个属性声明末尾都要加分号。 空格以下几种情况不需要空格： 属性名后多个规则的分隔符’,’前!important ‘!’后属性值中’(‘后和’)’前行末不要有多余的空格以下几种情况需要空格： 属性值前选择器’&gt;’, ‘+’, ‘~’前后‘{‘前!important ‘!’前@else 前后属性值中的’,’后注释’/‘后和’/‘前 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* not good */.element &#123; color :red! important; background-color: rgba(0,0,0,.5);&#125;/* good */.element &#123; color: red !important; background-color: rgba(0, 0, 0, .5);&#125;/* not good */.element ,.dialog&#123; ...&#125;/* good */.element,.dialog &#123;&#125;/* not good */.element&gt;.dialog&#123; ...&#125;/* good */.element &gt; .dialog&#123; ...&#125;/* not good */.element&#123; ...&#125;/* good */.element &#123; ...&#125;/* not good */@if&#123; ...&#125;@else&#123; ...&#125;/* good */@if &#123; ...&#125; @else &#123; ...&#125; 空行以下几种情况需要空行： 文件最后保留一个空行‘}’后最好跟一个空行，包括scss中嵌套的规则属性之间需要适当的空行，具体见属性声明顺序 1234567891011121314151617181920212223/* not good */.element &#123; ...&#125;.dialog &#123; color: red; &amp;:after &#123; ... &#125;&#125;/* good */.element &#123; ...&#125;.dialog &#123; color: red; &amp;:after &#123; ... &#125;&#125; 换行以下几种情况不需要换行： ‘{‘前以下几种情况需要换行： ‘{‘后和’}’前每个属性独占一行多个规则的分隔符’,’后 123456789101112131415161718192021/* not good */.element&#123;color: red; background-color: black;&#125;/* good */.element &#123; color: red; background-color: black;&#125;/* not good */.element, .dialog &#123; ...&#125;/* good */.element,.dialog &#123; ...&#125; 注释注释统一用’/ /‘（scss中也不要用’//‘），具体参照右边的写法； 缩进与下一行代码保持一致； 可位于一个代码行的末尾，与代码间隔一个空格。 12345678910111213141516171819/* Modal header */.modal-header &#123; ...&#125;/* * Modal header */.modal-header &#123; ...&#125;.modal-header &#123; /* 50px */ width: 50px; color: red; /* color red */&#125; 引号最外层统一使用双引号； url的内容要用引号； 属性选择器中的属性值需要引号。 123456789.element:after &#123; content: \"\"; background-image: url(\"logo.png\");&#125;li[data-type=\"single\"] &#123; ...&#125; 命名类名使用小写字母，以中划线分隔id采用驼峰式命名scss中的变量、函数、混合、placeholder采用驼峰式命名 123456789101112131415161718192021222324252627/* class */.element-content &#123; ...&#125;/* id */#myDialog &#123; ...&#125;/* 变量 */$colorBlack: #000;/* 函数 */@function pxToRem($px) &#123; ...&#125;/* 混合 */@mixin centerBlock &#123; ...&#125;/* placeholder */%myDialog &#123; ...&#125; 属性声明顺序相关的属性声明按右边的顺序做分组处理，组之间需要有一个空行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331.declaration-order &#123; display: block; float: right; position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; border: 1px solid #e5e5e5; border-radius: 3px; width: 100px; height: 100px; font: normal 13px \"Helvetica Neue\", sans-serif; line-height: 1.5; text-align: center; color: #333; background-color: #f5f5f5; opacity: 1;&#125;// 下面是推荐的属性的顺序[ [ \"display\", \"visibility\", \"float\", \"clear\", \"overflow\", \"overflow-x\", \"overflow-y\", \"clip\", \"zoom\" ], [ \"table-layout\", \"empty-cells\", \"caption-side\", \"border-spacing\", \"border-collapse\", \"list-style\", \"list-style-position\", \"list-style-type\", \"list-style-image\" ], [ \"-webkit-box-orient\", \"-webkit-box-direction\", \"-webkit-box-decoration-break\", \"-webkit-box-pack\", \"-webkit-box-align\", \"-webkit-box-flex\" ], [ \"position\", \"top\", \"right\", \"bottom\", \"left\", \"z-index\" ], [ \"margin\", \"margin-top\", \"margin-right\", \"margin-bottom\", \"margin-left\", \"-webkit-box-sizing\", \"-moz-box-sizing\", \"box-sizing\", \"border\", \"border-width\", \"border-style\", \"border-color\", \"border-top\", \"border-top-width\", \"border-top-style\", \"border-top-color\", \"border-right\", \"border-right-width\", \"border-right-style\", \"border-right-color\", \"border-bottom\", \"border-bottom-width\", \"border-bottom-style\", \"border-bottom-color\", \"border-left\", \"border-left-width\", \"border-left-style\", \"border-left-color\", \"-webkit-border-radius\", \"-moz-border-radius\", \"border-radius\", \"-webkit-border-top-left-radius\", \"-moz-border-radius-topleft\", \"border-top-left-radius\", \"-webkit-border-top-right-radius\", \"-moz-border-radius-topright\", \"border-top-right-radius\", \"-webkit-border-bottom-right-radius\", \"-moz-border-radius-bottomright\", \"border-bottom-right-radius\", \"-webkit-border-bottom-left-radius\", \"-moz-border-radius-bottomleft\", \"border-bottom-left-radius\", \"-webkit-border-image\", \"-moz-border-image\", \"-o-border-image\", \"border-image\", \"-webkit-border-image-source\", \"-moz-border-image-source\", \"-o-border-image-source\", \"border-image-source\", \"-webkit-border-image-slice\", \"-moz-border-image-slice\", \"-o-border-image-slice\", \"border-image-slice\", \"-webkit-border-image-width\", \"-moz-border-image-width\", \"-o-border-image-width\", \"border-image-width\", \"-webkit-border-image-outset\", \"-moz-border-image-outset\", \"-o-border-image-outset\", \"border-image-outset\", \"-webkit-border-image-repeat\", \"-moz-border-image-repeat\", \"-o-border-image-repeat\", \"border-image-repeat\", \"padding\", \"padding-top\", \"padding-right\", \"padding-bottom\", \"padding-left\", \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\" ], [ \"font\", \"font-family\", \"font-size\", \"font-weight\", \"font-style\", \"font-variant\", \"font-size-adjust\", \"font-stretch\", \"font-effect\", \"font-emphasize\", \"font-emphasize-position\", \"font-emphasize-style\", \"font-smooth\", \"line-height\", \"text-align\", \"-webkit-text-align-last\", \"-moz-text-align-last\", \"-ms-text-align-last\", \"text-align-last\", \"vertical-align\", \"white-space\", \"text-decoration\", \"text-emphasis\", \"text-emphasis-color\", \"text-emphasis-style\", \"text-emphasis-position\", \"text-indent\", \"-ms-text-justify\", \"text-justify\", \"letter-spacing\", \"word-spacing\", \"-ms-writing-mode\", \"text-outline\", \"text-transform\", \"text-wrap\", \"-ms-text-overflow\", \"text-overflow\", \"text-overflow-ellipsis\", \"text-overflow-mode\", \"-ms-word-wrap\", \"word-wrap\", \"-ms-word-break\", \"word-break\" ], [ \"color\", \"background\", \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader\", \"background-color\", \"background-image\", \"background-repeat\", \"background-attachment\", \"background-position\", \"-ms-background-position-x\", \"background-position-x\", \"-ms-background-position-y\", \"background-position-y\", \"-webkit-background-clip\", \"-moz-background-clip\", \"background-clip\", \"background-origin\", \"-webkit-background-size\", \"-moz-background-size\", \"-o-background-size\", \"background-size\" ], [ \"outline\", \"outline-width\", \"outline-style\", \"outline-color\", \"outline-offset\", \"opacity\", \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity\", \"-ms-filter:\\\\'progid:DXImageTransform.Microsoft.Alpha\", \"-ms-interpolation-mode\", \"-webkit-box-shadow\", \"-moz-box-shadow\", \"box-shadow\", \"filter:progid:DXImageTransform.Microsoft.gradient\", \"-ms-filter:\\\\'progid:DXImageTransform.Microsoft.gradient\", \"text-shadow\" ], [ \"-webkit-transition\", \"-moz-transition\", \"-ms-transition\", \"-o-transition\", \"transition\", \"-webkit-transition-delay\", \"-moz-transition-delay\", \"-ms-transition-delay\", \"-o-transition-delay\", \"transition-delay\", \"-webkit-transition-timing-function\", \"-moz-transition-timing-function\", \"-ms-transition-timing-function\", \"-o-transition-timing-function\", \"transition-timing-function\", \"-webkit-transition-duration\", \"-moz-transition-duration\", \"-ms-transition-duration\", \"-o-transition-duration\", \"transition-duration\", \"-webkit-transition-property\", \"-moz-transition-property\", \"-ms-transition-property\", \"-o-transition-property\", \"transition-property\", \"-webkit-transform\", \"-moz-transform\", \"-ms-transform\", \"-o-transform\", \"transform\", \"-webkit-transform-origin\", \"-moz-transform-origin\", \"-ms-transform-origin\", \"-o-transform-origin\", \"transform-origin\", \"-webkit-animation\", \"-moz-animation\", \"-ms-animation\", \"-o-animation\", \"animation\", \"-webkit-animation-name\", \"-moz-animation-name\", \"-ms-animation-name\", \"-o-animation-name\", \"animation-name\", \"-webkit-animation-duration\", \"-moz-animation-duration\", \"-ms-animation-duration\", \"-o-animation-duration\", \"animation-duration\", \"-webkit-animation-play-state\", \"-moz-animation-play-state\", \"-ms-animation-play-state\", \"-o-animation-play-state\", \"animation-play-state\", \"-webkit-animation-timing-function\", \"-moz-animation-timing-function\", \"-ms-animation-timing-function\", \"-o-animation-timing-function\", \"animation-timing-function\", \"-webkit-animation-delay\", \"-moz-animation-delay\", \"-ms-animation-delay\", \"-o-animation-delay\", \"animation-delay\", \"-webkit-animation-iteration-count\", \"-moz-animation-iteration-count\", \"-ms-animation-iteration-count\", \"-o-animation-iteration-count\", \"animation-iteration-count\", \"-webkit-animation-direction\", \"-moz-animation-direction\", \"-ms-animation-direction\", \"-o-animation-direction\", \"animation-direction\" ], [ \"content\", \"quotes\", \"counter-reset\", \"counter-increment\", \"resize\", \"cursor\", \"-webkit-user-select\", \"-moz-user-select\", \"-ms-user-select\", \"user-select\", \"nav-index\", \"nav-up\", \"nav-right\", \"nav-down\", \"nav-left\", \"-moz-tab-size\", \"-o-tab-size\", \"tab-size\", \"-webkit-hyphens\", \"-moz-hyphens\", \"hyphens\", \"pointer-events\" ]] 颜色颜色16进制用小写字母； 颜色16进制尽量用简写。 123456789101112/* not good */.element &#123; color: #ABCDEF; background-color: #001122;&#125;/* good */.element &#123; color: #abcdef; background-color: #012;&#125; 属性简写属性简写需要你非常清楚属性值的正确顺序，而且在大多数情况下并不需要设置属性简写中包含的所有值，所以建议尽量分开声明会更加清晰； margin 和 padding 相反，需要使用简写； 常见的属性简写包括： font background transition animation 媒体查询尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部，这样做只会让大家以后更容易忘记他们。 1234567891011121314151617.element &#123; ...&#125;.element-avatar&#123; ...&#125;@media (min-width: 480px) &#123; .element &#123; ... &#125; .element-avatar &#123; ... &#125;&#125; 杂项 不允许有空的规则； 元素选择器用小写字母； 去掉小数点前面的0； 去掉数字中不必要的小数点和末尾的0； 属性值’0’后面不要加单位； 同个属性不同前缀的写法需要在垂直方向保持对齐，具体参照右边的写法； 无前缀的标准属性应该写在有前缀的属性后面； 不要在同个规则里出现重复的属性，如果重复的属性是连续的则没关系； 不要在一个文件里出现两个相同的规则； 用 border: 0; 代替 border: none;； 选择器不要超过4层（在scss中如果超过4层应该考虑用嵌套的方式来写）； 发布的代码中不要有 @import； 尽量少用’*’选择器。 JavaScript缩进使用soft tab（4个空格）。 123456789var x = 1, y = 1;if (x &lt; y) &#123; x += 10;&#125; else &#123; x += 1;&#125; 分号以下几种情况后需加分号： 变量声明 表达式 return throw break continue do-while 12345678910/* var declaration */var x = 1;/* expression statement */x++;/* do-while */do &#123; x++;&#125; while (x &lt; 10); 空格以下几种情况不需要空格： 对象的属性名后 前缀一元运算符后 后缀一元运算符前 函数调用括号前 无论是函数声明还是函数表达式，’(‘前不要空格 数组的’[‘后和’]’前 对象的’{‘后和’}’前 运算符’(‘后和’)’前 以下几种情况需要空格： 二元运算符前后 三元运算符’?:’前后 代码块’{‘前 下列关键字前：else, while, catch, finally 下列关键字后：if, else, for, while, do, switch, case, try, catch, finally, with, return, typeof 单行注释’//‘后（若单行注释和代码同行，则’//‘前也需要），多行注释’*’后 对象的属性值前 for循环，分号后留有一个空格，前置条件如果有多个，逗号后留一个空格 无论是函数声明还是函数表达式，’{‘前一定要有空格 函数的参数之间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// not goodvar a = &#123; b :1&#125;;// goodvar a = &#123; b: 1&#125;;// not good++ x;y ++;z = x?1:2;// good++x;y++;z = x ? 1 : 2;// not goodvar a = [ 1, 2 ];// goodvar a = [1, 2];// not goodvar a = ( 1+2 )*3;// goodvar a = (1 + 2) * 3;// no space before '(', one space before '&#123;', one space between function parametersvar doSomething = function(a, b, c) &#123; // do something&#125;;// no space before '('doSomething(item);// not goodfor(i=0;i&lt;6;i++)&#123; x++;&#125;// goodfor (i = 0; i &lt; 6; i++) &#123; x++;&#125; 空行以下几种情况需要空行： 变量声明后（当变量声明在代码块的最后一行时，则无需空行） 注释前（当注释在代码块的第一行时，则无需空行） 代码块后（在函数调用、数组、对象中则无需空行） 文件最后保留一个空行 换行换行的地方，行末必须有’,’或者运算符； 以下几种情况不需要换行： 下列关键字后：else, catch, finally代码块’{‘前以下几种情况需要换行： 代码块’{‘后和’}’前变量赋值后 单行注释双斜线后，必须跟一个空格； 缩进与下一行代码保持一致； 可位于一个代码行的末尾，与代码间隔一个空格 多行注释最少三行, ‘*’后跟一个空格，具体参照右边的写法； 建议在以下情况下使用： 难于理解的代码段可能存在错误的代码段浏览器特殊的HACK代码业务逻辑强相关的代码 1234/* * one space after '*' */var x = 1; 引号最外层统一使用单引号。 123456// not goodvar x = \"test\";// goodvar y = 'foo', z = '&lt;div id=\"test\"&gt;&lt;/div&gt;'; 变量命名标准变量采用驼峰式命名（除了对象的属性外，主要是考虑到cgi返回的数据） ‘ID’在变量名中全大写 ‘URL’在变量名中全大写 ‘Android’在变量名中大写第一个字母 ‘iOS’在变量名中小写第一个，大写后两个字母 常量全大写，用下划线连接 构造函数，大写第一个字母 jquery对象必须以’$’开头命名 123456789101112131415161718192021var thisIsMyName;var goodID;var reportURL;var AndroidVersion;var iOSVersion;var MAX_COUNT = 10;function Person(name) &#123; this.name = name;&#125;// not goodvar body = $('body');// goodvar $body = $('body'); 变量声明一个函数作用域中所有的变量声明尽量提到函数首部，用一个var声明，不允许出现两个连续的var声明。 1234567891011function doSomethingWithItems(items) &#123; // use one var var value = 10, result = value + 10, i, len; for (i = 0, len = items.length; i &lt; len; i++) &#123; result += 10; &#125;&#125; 函数无论是函数声明还是函数表达式，’(‘前不要空格，但’{‘前一定要有空格； 函数调用括号前不需要空格； 立即执行函数外必须包一层括号； 不要给inline function命名； 参数之间用’, ‘分隔，注意逗号后有一个空格。 数组、对象对象属性名不需要加引号； 对象以缩进的形式书写，不要写在一行； 数组、对象最后不要有逗号。 1234567891011121314151617// not goodvar a = &#123; 'b': 1&#125;;var a = &#123;b: 1&#125;;var a = &#123; b: 1, c: 2,&#125;;// goodvar a = &#123; b: 1, c: 2&#125;; 括号下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。 null适用场景： 初始化一个将来可能被赋值为对象的变量 与已经初始化的变量做比较 作为一个参数为对象的函数的调用传参 作为一个返回对象的函数的返回值 不适用场景： 不要用null来判断函数调用时有无传参 不要与未初始化的变量做比较 undefined永远不要直接使用undefined进行变量判断； 使用typeof和字符串’undefined’对变量进行判断。 123456789// not goodif (person === undefined) &#123; ...&#125;// goodif (typeof person === 'undefined') &#123; ...&#125; jshint用’===’, ‘!==’代替’==’, ‘!=’； for-in里一定要有hasOwnProperty的判断； 不要在内置对象的原型上添加方法，如Array, Date； 不要在内层作用域的代码里声明了变量，之后却访问到了外层作用域的同名变量； 变量不要先使用后声明； 不要在一句代码中单单使用构造函数，记得将其赋值给某个变量； 不要在同个作用域下声明同名变量； 不要在一些不需要的地方加括号，例：delete(a.b)； 不要使用未声明的变量（全局变量需要加到.jshintrc文件的globals属性里面）； 不要声明了变量却不使用； 不要在应该做比较的地方做赋值； debugger不要出现在提交的代码里； 数组中不要存在空元素； 不要在循环内部声明函数； 不要像这样使用构造函数，例：new function () { … }, new Object； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// not goodif (a == 1) &#123; a++;&#125;// goodif (a === 1) &#123; a++;&#125;// goodfor (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // be sure that obj[key] belongs to the object and was not inherited console.log(obj[key]); &#125;&#125;// not goodArray.prototype.count = function(value) &#123; return 4;&#125;;// not goodvar x = 1;function test() &#123; if (true) &#123; var x = 0; &#125; x += 1;&#125;// not goodfunction test() &#123; console.log(x); var x = 1;&#125;// not goodnew Person();// goodvar person = new Person();// not gooddelete(obj.attr);// gooddelete obj.attr;// not goodif (a = 10) &#123; a++;&#125;// not goodvar a = [1, , , 2, 3];// not goodvar nums = [];for (var i = 0; i &lt; 10; i++) &#123; (function(i) &#123; nums[i] = function(j) &#123; return i + j; &#125;; &#125;(i));&#125;// not goodvar singleton = new function() &#123; var privateVar; this.publicMethod = function() &#123; privateVar = 1; &#125;; this.publicMethod2 = function() &#123; privateVar = 2; &#125;;&#125;; 杂项不要混用tab和space； 不要在一处使用多个tab或space； 换行符统一用’LF’； 对上下文this的引用只能使用’_this’, ‘that’, ‘self’其中一个来命名； 行尾不要有空白字符； switch的falling through和no default的情况一定要有注释特别说明； 不允许有空的代码块。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"编码规范","slug":"技术/编码规范","permalink":"http://yoursite.com/categories/技术/编码规范/"}],"tags":[{"name":"编码规范","slug":"编码规范","permalink":"http://yoursite.com/tags/编码规范/"}]},{"title":"javascript基础知识整理","slug":"js学习系列","date":"2018-06-28T05:18:11.903Z","updated":"2018-06-30T03:05:51.476Z","comments":true,"path":"2018/06/28/js学习系列/","link":"","permalink":"http://yoursite.com/2018/06/28/js学习系列/","excerpt":"一、基础语法：变量标示符变量的命名var _name = null;var $name = null;var name0 = null; 关键字与保留字JavaScript 在语言定义中保留的字段，这些字段在语言使用中存在特殊意义或功能，在程序编写的过程中不可以当做变量或函数名称使用。无需记忆，报错修改即可。 字符敏感字符串的大小写是有所区分的，不同字符指代不同的变量。","text":"一、基础语法：变量标示符变量的命名var _name = null;var $name = null;var name0 = null; 关键字与保留字JavaScript 在语言定义中保留的字段，这些字段在语言使用中存在特殊意义或功能，在程序编写的过程中不可以当做变量或函数名称使用。无需记忆，报错修改即可。 字符敏感字符串的大小写是有所区分的，不同字符指代不同的变量。 严格模式使用方法1234567891011&lt;!-- 全局使用 严格 模式 --&gt;\"use strict\";(function()&#123; console.log('&gt;&gt;&gt; Hello, world!');&#125;)()&lt;!-- 或者在函数内部声明使用 严格 模式 --&gt;(function()&#123; \"use strict\"; console.log('&gt;&gt;&gt; Hello, world!');&#125;)() 类型系统javascript 类型系统可以分为标准类型和对象类型，进一步标准类型又可以分为原始类型和引用类型，而对象类型又可以分为内置对象类型、普通对象类型、自定义对象类型。 标准类型标准类型共包括了6个分别是： 原始类型（值类型）： Undefined undefined Null null Boolean true String ‘hello’ Number 123 引用类型（对象类型）：Object 123456var obj = &#123;&#125;;&lt;!-- 原始类型变量的包装类型如下 --&gt;var bool = new Boolean(true);var str = new String(\"hello\");var num = new Number(1);var obj0 = new Object(); 原始类型和引用类型的区别： 原始类型储存在栈（Stack）中储存变量的值，而引用类型在栈中保存的是所引用内容储存在堆（Heap）中的值。类似于指针的概念，引用类型并非储存变量真实数值而是地址，所以对已引用类型的复制其实只是复制了相同的地址而非实际的变量值。 Undefined 值：undefined 出现场景： 以声明为赋值的变量 var obj; 获取对象不存在的属性 var obj = {x: 0}; obj.y; 无返回值函数的执行结果 function f(){}; var obj = f(); 函数参数没有传入 function f(i){console.log(i)}; f(); void(expression) Null 值：null 出现场景： 获取不存在的对象 document.getElementById(‘not-exist-element’) Boolean 值：true, false 出现场景： 条件语句导致的系统执行的隐式类型转换 if(隐式转换){} 字面量或变量定义 var bool = true; String 值：字符串 出现场景： var str = ‘Hello, world!’; Number 值：整型直接量，八进制直接量（0-），十六进制直接量（0x-)，浮点型直接量 出现场景： 1026 3.14 1.2e5 0x10 Object 值：属性集合 出现场景： var obj = {name: ‘Xinyang’}; 类型识别 typeof Object.prototype.toString constructor instanceof typeof：可以是标准类型（Null 除外）不可识别具体的对象类型（Function 除外） Object.prototype.toString：可识别标准类型及内置对象类型（例如，Object, Date, Array）不能识别自定义对象类型 constructor：可以识别标准类型（Undefined/Null 除外）可识别内置对象类型可识别自定义对象类型 1234function getConstructiorName(obj) &#123; return obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor.toString().match(/function\\s*([^(]*)/)[1];&#125;getConstructiorName([]) === \"Array\"; // true instanceof：不可判别原始类型可判别内置对象类型可判别自定义对象类型 类型判断avaScript的数据类型可以分为：标准类型和对象类型。标准类型有：undefined Null Boolean Date Number Object对象类型（构造器类型）：Boolean Date Number Object Array Date Error Function RegExp 下面我们写一个HTML来检验一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&lt;html&gt;&lt;head&gt; &lt;title&gt;JavaScript类型判断&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style type=\"text/css\"&gt; .red&#123; background-color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; /* Standard Type */ var a; //undefined var b = document.getElementById(\"no_exist_element\"); //null var c = true; //Boolean var d = 1; //Number var e = \"str\"; //String var f = &#123;name : \"Tom\"&#125;; //Object /* Object Type */ var g = new Boolean(true); //Boolean Object var h = new Number(1); //Number Object var i = new String(\"str\"); //String Object var j = new Object(&#123;name : \"Tom\"&#125;); //Object Object var k = new Array([1, 2, 3, 4]); //Array Object var l = new Date(); //Date Object var m = new Error(); var n = new Function(); var o = new RegExp(\"\\\\d\"); /* Self-Defined Object Type */ function Point(x, y) &#123; this.x = x; this.y = y; &#125; Point.prototype.move = function(x, y) &#123; this.x += x; this.y += y; &#125; var p = new Point(1, 2); /* Use the Prototype.toString() to judge the type */ function type(obj)&#123; return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase(); &#125; &lt;/script&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;typeof&lt;/td&gt; &lt;td&gt;toString&lt;/td&gt; &lt;td&gt;constructor&lt;/td&gt; &lt;td&gt;instanceof&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;undefined&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof a)&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(a))&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(a.constructor)&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(a instanceof \"undefined\")&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Null&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof b);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(b));&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(b.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(b instanceof \"null\");&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Boolean&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof c);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(c));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(c.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(c instanceof \"boolean\");&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Number&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof d);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(d));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(d.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(d instanceof \"number\");&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;String&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof e);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(e));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(e.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(e instanceof \"string\");&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Object&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof f);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(f));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(f.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(f instanceof \"object\");&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td colspan=\"5\"&gt;-----------------------&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Boolean Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof g);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(g));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(g.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(g instanceof Boolean);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Number Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof h);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(h));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(h.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(h instanceof Number);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;String Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof i);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(i));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(i.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(i instanceof String);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Object Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof j);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(j));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(j.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(j instanceof Object);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Array Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof k);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(k));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(k.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(k instanceof Array);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Date Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof l);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(l));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(l.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(l instanceof Date);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Error Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof m);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(m));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(m.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(m instanceof Error);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Function Object&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof n);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(n));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(n.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(n instanceof Function);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;RegExp Object&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof o);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(o));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(o.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(o instanceof RegExp);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td colspan=\"5\"&gt;-----------------------&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Point Objct&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(typeof p);&lt;/script&gt;&lt;/td&gt; &lt;td class=\"red\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(type(p));&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(p.constructor);&lt;/script&gt;&lt;/td&gt; &lt;td&gt;&lt;script type=\"text/javascript\"&gt;document.write(p instanceof Point);&lt;/script&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 执行的结果如下： 内置对象通常情况下只有对象才存在方法，但 JavaScript 不同它具有12种内置对象。内置对象又分为两类，普通对象（属性和方法）与构造器对象（可用于实例化普通对象，它还包含原型对象属性和方法，及实例对象属性和方法）。 JavaScript 对象原型链的简要说明 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.move = function(x, y) &#123; this.x += x; this.y += y;&#125;var p = new Point(1, 1);p.move(2,2); __proto__ 称之为原型链，有如下特点： __proto__为对象内部的隐藏属性 __proto__ 为实例化该对象的构造器的 prototype 对象的引用，因此可以直接方法 prototype 的所有属性和方法 除了 Object 每个对象都有一个 __proto__ 属性且逐级增长形成一个链，原型链顶端是一个 Object 对象。 在调用属性或方法时，引擎会查找自身的属性如果没有则会继续沿着原型链逐级向上查找，直到找到该方法并调用。 __proto__ 跟浏览器引擎实现相关，不同的引擎中名字和实现不尽相同(chrome、firefox中名称是 __proto__ ，并且可以被访问到，IE中无法访问)。基于代码兼容性、可读性等方面的考虑，不建议开发者显式访问 __proto__ 属性或通过 proto更改原型链上的属性和方法，可以通过更改构造器prototype 对象来更改对象的 __proto__ 属性。构造器对象与普通对象的区别 构造器对象与普通对象的区别 构造器对象原型链中的 proto 是一个 Function.prototype 对象的引用，因此可以调用 Function.prototype的属性及方 法 构造器对象本身有一个 prototype 属性，用该构造器实例化对象时该 prototype 会被实例对象的 proto 所引用 构造器对象本身是一个 function 对象，因此也会有自身属性 标准内置对象构造器对象 Object Boolean String Number Function Array RegExp Date Error 其他对象 Math JSON 全局对象 内置对象，其实也叫内置构造器，它们可以通过 new 的方式创建一个新的实例对象。内置对象所属的类型就叫内置对象类型。其声明方式如下： 12345678910var i = new String(\"str\"); // String Objectvar h = new Number(1); // Number Objectvar g = new Boolean(true); // Boolean Objectvar j = new Object(&#123;name : \"Tom\"&#125;); // Object Objectvar k = new Array([1, 2, 3, 4]); // Array Objectvar l = new Date(); // Date Objectvar m = new Error();var n = new Function();var o = new RegExp(\"\\\\d\"); 虽然标准类型中有Boolean String Number Object，内置对象类型中也有Boolean String Number Object，但它们其实是通过不同的声明方式来进行区别的。标准类型通过直接赋值，而对象类型则是通过构造器实现初始化 Object构造器的原型对象在对象实例化时将会被添加到实例对象的原型链当中。__proto__为原型链属性，编码时不可被显像调用。但是实例化对象可以调用原型链上的方法。用 String/Number 等构造器创建的对象原型链顶端对象始终是一个Object对象，因此这些对象可以调用Object的原型对象属性和方法。所以 String/Number 等构造器是 Object 的子类。 构造器说明：Object 是属性和方法的集合String/Number/Boolean/Array/Date/Error 构造器均为 Object 的子类并集成 Object 原型对象的属性及方法。 实例化方法123var obj0 = new Object(&#123;name: 'X', age: 13&#125;);// 常用方法var obj1 = &#123;name: 'Q', age: 14&#125;; 属性及方法 prototype create keys … **原型对象属性及其方法 constructor toString valueOf hasOwnProperty … Object.create功能：基于原型对象创造新对象 123// Object.create(prototype[, propertiesObject])var prototype = &#123;name: 'X', age: 13&#125;;var obj = Object.create(proto); Object.prototype.toString功能：获取方法调用者的标准类型 123// objectInstance.toString()var obj = &#123;&#125;;obj.toString(); // Object Object.prototype.hasOwnProperty功能：判断一个属性是否是一个对象的自身属性 12345// objectInstance.hasOwnProperty(\"propertyName\")var obj = Object.create(&#123;a: 1, b: 2&#125;);obj.c = 3;obj.hasOwnProperty('a'); // falseobj.hasOwnProperty('c'); // true String构造器说明：单双引号内的字符串实例化方法123'Hello, world!'var str0 = 'Xinyang';var str1 = new String('Xinyang'); 属性及方法 prototype fromCharCode（转换 ASCII 代码为字符） 原型对象属性及其方法 constructor indexOf replace slice split charCodeAt toLowerCase String.prototype.indexOf功能：获取子字符串在字符串中的索引12345// stringObject.indexOf(searchValue, fromIndex)var str = \"I am X. From China!\";var index = str.indexOf('a'); // 2str.indexOf('a', index + 1); // 16str.indexOf('Stupid'); // -1 字符串不存在 String.prototype.replace功能：查找字符串替换成目标文字123// stringObject.replace(regexp/substr, replacement)var str = \"apple is bad\";str = str.replace('bad', 'awesome'); String.prototype.split功能：按分隔符将分隔符分成字符串数组 12345// stringObject.split(separator, arrayLength)var str = '1 2 3 4';str.split(' '); // ['1', '2', '3', '4'];str.split(' ', 3); // ['1', '2', '3'];str.split(/\\d+/); // [\"\", \" \", \" \", \" \", \"\"] Number构造器说明：整型直接量，八进制直接量（0-），十六进制直接量（0x-)，浮点型直接量实例化方法 1234101.2e5var count = 0x10;var pi = new Number(3.1415); 属性及方法 prototype MAX_VALUE MIN_VALUE NaN NEGATIVE_INFINITY POSITIVE_INFINITY 原型对象属性及其方法 constructor toFixed toExponential … Number.prototype.toFixed功能：四舍五入至指定小数位 12345// numberObject.toFixed(num)var num0 = 3.14;num0.toFixed(1); // 3.1var num1 = 3.35;num1.toFixed(1); // 3.4 Array构造器说明：定义数组对象实例化方法 123var a0 = [1, 'abc', true, function()&#123;&#125;];var a1 = new Array();var a2 = new Array(1, 'abc', true); 属性及方法 prototype isArray 原型对象属性及其方法 constructor splice forEach find concat pop push reverse shift slice … Array.prototype.splice 功能：从数组中删除或添加元素，返回被删除的元素列表（作用域原有数组） 1234// arrayObject.splice(start, deleteCount[, item1[, item2[, ...]]])var arr = ['1', '2', 'a', 'b', '6'];var ret = arr.splice(2, 2, '3', '4', '5'); // ['a', 'b']arr; // ['1', '2', '3', '4', 5', '6'] Function…….. DOM编程节点操作获取节点父子关系 element.parentNode element.firstChild/ element.lastChild element.childNodes/ element.children 兄弟关系 element.previousSibling/ element.nextSibling element.previousElementSibling/ element.nextElementSibling 通过节点直接的关系获取节点会导致代码维护性大大降低（节点之间的关系变化会直接影响到获取节点），而通过接口则可以有效的解决此问题。 接口获取元素节点 getElementById getElementsByTagName getElementsByClassName querySelector querySelectorAll 创建节点创建节点 -&gt; 设置属性 -&gt; 插入节点1var element = document.createElement('tagName'); 修改节点textContent获取或设置节点以及其后代节点的文本内容（对于节点中的所有文本内容）。 12element.textContent; // 获取element.textContent = 'New Content'; innerText （不符合 W3C 规范）获取或设置节点以及节点后代的文本内容。其作用于 textContent 几乎一致。1element.innerText; 插入节点appendChild在指定的元素内追加一个元素节点。var aChild = element.appendChild(aChild); insertBefore在指定元素的指定节点前插入指定的元素。var aChild = element.insertBefore(aChild, referenceChild); 删除节点删除指定的节点的子元素节点。var child = element.removeChild(child); innerHTML获取或设置指定节点之中所有的 HTML 内容。替换之前内部所有的内容并创建全新的一批节点（去除之前添加的事件和样式）。innerHTML 不检查内容，直接运行并替换原先的内容。 只建议在创建全新的节点时使用。不可在用户可控的情况下使用。 var elementsHTML = element.innerHTML; 属性操作1234&lt;div&gt; &lt;label for=\"username\"&gt;User Name:&lt;/label&gt; &lt;input type=\"input\" name=\"username\" id=\"username\" class=\"text\" value=\"\"&gt;&lt;div&gt; 对应的属性 12345input.id; // &apos;username&apos;input.type; // &apos;text&apos;input.className; // &apos;text&apos;label.htmlFor; // &apos;username&apos; 属性操作方式 Property Accessor 通过属性方法符得到的属性为转换过的实例对象（并非全字符串）。 特点 X 通用行差（命名异常，使用不同的命名方式进行访问）X 扩展性差√ 实用对象（取出后可直接使用） 读取属性1234567&lt;div&gt; &lt;label for=\"username\"&gt;User Name: &lt;/label&gt; &lt;input type=\"input\" name=\"username\" id=\"username\" class=\"text\" value=\"\"&gt;&lt;/div&gt;input.className; // 'text'input[id]; // 'username' 写入属性 可增加新的属性或改写已有属性。12input.value = &apos;new value&apos;;input[id] = &apos;new-id&apos;; getAttribute / setAttribute 特点 X 仅可获取字符串（使用时需转换）√ 通用性强读取属性 获取到的均为属性的字符串。 var attribtue = element.getAttribute(‘attributeName’); 写入属性 可增加新的属性或改写已有属性。element.setAttribute(‘attributeName’, value); dataset自定义属性，其为 HTMLElement 上的属性也是 data-* 的属性集。主要用于在元素上保存数据。获取的均为属性字符串。数据通常使用 AJAX 获取并存储在节点之上。 123div.dataset.id; // &apos;1234&apos;div.dataset.username; // &apos;x&apos;div.dataset.email; // &apos;mail@gmail.com&apos; dataset 在低版本 IE 不可使用，但可通过 getAttribute 与 setAttribute 来做兼容。 样式操作更新样式123element.styleelement.style.color = 'red';element.style.background = 'black'; 增加样式后得到的结果1&lt;div style=\"color: red; background: black;\"&gt;&lt;/div&gt; 缺点 每个属性的更新都需要一个命令命名异常（以驼峰命名法命名属性） element.style.cssText一次同时设置多个行内样式，其结果同 element.style 单独设置相同。 1element.style.cssText = 'color: red; background: black'; 更新 class首先需要创建对应样式的 CSS 样式。 1234.angry &#123; color: red; background: black;&#125; 然后再在 JavaScript 中，在对应的事件中给元素添加需要的类即可。 element.className += ‘ angry’; 增加样式后得到的结果 统一更新多个元素样式以上方法均不适合同时更新多个样式，通过更换样式表的方式则可同时更改多个页面中的样式。将需要的大量样式也在一个皮肤样式表中，通过 JavaScript 来直接更换样式表来进行样式改变。（此方法也可用于批量删除样式） 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"base.css\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style1.css\"&gt; element.setAttribute(‘href’, ‘style2.css’); element.setAttribute(‘href’,’style2.css’) 获取样式element.style其对应的为元素的行内样式表而不是实际样式表。 element.style.color; // “” 事件DOM 事件何为 DOM 事件，HTML DOM 使JavaScript 有能力对 HTML 事件做出反应。（例如，点击 DOM 元素，键盘被按，输入框输入内容以及页面加载完毕等） 事件流一个 DOM 事件可以分为捕获过程、触发过程、冒泡过程。 DOM 事件流为 DOM 事件的处理及执行的过程。下面以一个&lt;a&gt;元素被点击为例。 事件注册事件注册，取消以及触发其作用对象均为一个 DOM 元素。 注册事件 eventTarget.addEventListener(type, listener[,useCapture]) evenTarget 表示要绑定事件的DOM元素 type 表示要绑定的事件，如：”click” listener 表示要绑定的函数 useCapture 可选参数，表示是否捕获过程 useCapture 为设定是否为捕获过程，默认事件均为冒泡过程，只有 useCapture 为 true 时才会启用捕获过程。 12345678910111213141516171819// 获取元素var elem = document.getElemenyById('id');// 事件处理函数var clickHandler = function(event) &#123; // statements&#125;;// 注册事件elem.addEventListener('click', clickHandler, false);// 第二种方式，不建议使用elem.onclick = clickHandler;// 或者来弥补只可触发一个处理函数的缺陷elem.onclick = function()&#123; clickHandler(); func(); // 其他处理函数&#125;; 取消事件eventTarget.removeEventListener(type, listener[,useCapture]); 12345678// 获取元素var elem = document.getElemenyById('id');// 取消事件elem.removeEventListener('click', clickHandler, false);// 第二种方式。不建议使用elem.onclick = null; 触发事件点击元素，按下按键均会触发 DOM 事件，当然也可以以通过代码来触发事件。 eventTarget.dispatchEvent(type); 12345// 获取元素var elem = document.getElemenyById('id');// 触发事件elem.dispatchEvent('click'); 事件对象调用事件处理函数时传入的信息对象，这个对象中含有关于这个事件的详细状态和信息，它就是事件对象 event。其中可能包含鼠标的位置，键盘信息等。 属性和方法通用属性和方法属性 type 事件类型 target(srcElement IE 低版本) 事件触发节点 currentTarget 处理事件的节点 方法 stopPropagation 阻止事件冒泡传播 preventDefault 阻止默认行为 stopImmediatePropagation 阻止冒泡传播 阻止事件传播event.stopPropagation()（W3C规范方法），如果在当前节点已经处理了事件，则可以阻止事件被冒泡传播至 DOM 树最顶端即 window 对象。event.stopImmediatePropagation() 此方法同上面的方法类似，除了阻止将事件冒泡传播值最高的 DOM 元素外，还会阻止在此事件后的事件的触发。 事件分类Event window load 页面全部加载完毕 unload 离开本页之前的卸载 error 页面异常 abort 取消加载 image load 图片加载完毕 error 图标加载错误 abort 取消图标加载在目标图标不能正常载入时，载入备份替代图来提供用户体验。 UIEvent MouseEventDOM 事件中最常见的事件之一 属性 clientX, clientX screenX, screenY ctrlKey, shiftKey, altKey, metaKey 如果被按下则为真（true） button(0, 1, 2) 鼠标的间位 MouseEvent 顺序鼠标的移动过程中会产生很多事件。事件的监察频率又浏览器决定。例子：从元素 A 上方移动过mousemove -&gt; mouseover(A) -&gt; mouseenter(A) -&gt; mousemove(A) -&gt; mouseout(A) -&gt; mouseleave(A)例子：点击元素mousedown -&gt; [mousemove] -&gt; mouseup -&gt; click 滚轮事件（Wheel） 属性 deltaMode 鼠标滚轮偏移量的单位 deltaX deltaY deltaZ FocusEvent其用于处理元素获得或失去焦点的事件。（例如输入框的可输入状态则为获得焦点，点击外部则失去焦点） blur 失去焦点时，focus 获得焦点时，focusin 即将获得焦点，focusout即将失去焦点。 KeyboardEvent其用于处理键盘事件 JavaScript 动画帧，为动画的最小单位，一个静态的图像。帧频，每秒播放的帧的数量。一个动画是由很多帧组成的，因为人眼的暂留特性，当图片交替的速度大于每秒 30 帧以上既有动画的感觉。 JavaScript 动画三要素 定时器 setInterval func 为执行改变属性的操作 delay 为出发时间间隔（毫秒为单位） para1 为执行时可传入改变属性函数的参数 12var intervalId = setInterval(func, delay[, param1, param2, ...]);clearInterval(intervalId); 使用 setInterval 可以调用一次定时器既可实现连贯的动画。使用 clearInterval 即可清除动画效果。 setTimeout func 为执行改变属性的操作 delay 为出发时间间隔（毫秒为单位）默认为 0 para1 为执行时可传入改变属性函数的参数 12var timeoutId = setTimeout(func[, delay, param1, param2, ...]);clearTimeout(timeoutId); 使用 setTimeout 实现动画，则需要在动画每一帧结束时再次调用定时器。但它无需清除定时器。 区别 setTimeout 在延时后只执行一次，setInterval 则会每隔一个延时期间后会再执行。 requestAnimationFrame 类似于 setTimeout 但是无需设定时间间隔。此定时器为 HTML5 中的新标准，其间隔时间不由用户控制，而是由显示器的刷新频率决定。（市面上的显示器刷新频率为每秒刷新60次） 常见动画 大多的复杂动画都是有下列的简单动画所组成的。 形变，改变元素的宽高 位移，改变元素相对位置 旋转 透明度 其他…","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"基础知识","slug":"技术/JavaScript/基础知识","permalink":"http://yoursite.com/categories/技术/JavaScript/基础知识/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"布局解决方案","slug":"布局解决方案","date":"2018-06-27T08:17:14.865Z","updated":"2018-06-27T12:00:22.083Z","comments":true,"path":"2018/06/27/布局解决方案/","link":"","permalink":"http://yoursite.com/2018/06/27/布局解决方案/","excerpt":"居中布局水平居中子元素于父元素水平居中且其（子元素与父元素）宽度均可变。 inline-block + text-align 123456789101112&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: inline-block; &#125; .parent &#123; text-align: center; &#125;&lt;/style&gt; 兼容性佳（甚至可以兼容 IE 6 和 IE 7）","text":"居中布局水平居中子元素于父元素水平居中且其（子元素与父元素）宽度均可变。 inline-block + text-align 123456789101112&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: inline-block; &#125; .parent &#123; text-align: center; &#125;&lt;/style&gt; 兼容性佳（甚至可以兼容 IE 6 和 IE 7） table + margin 12345678910&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; display: table 在表现上类似 block 元素，但是宽度为内容宽。无需设置父元素样式 （支持 IE 8 及其以上版本） absolute + transform 1234567891011121314&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; position: relative; &#125; .child &#123; position: absolute; left: 50%; transform: translateX(-50%); &#125;&lt;/style&gt; 优点 绝对定位脱离文档流，不会对后续元素的布局造成影响。 缺点 transform 为 CSS3 属性，有兼容性问题 flex + justify-content 12345678910111213141516171819&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content: center; &#125; /* 或者下面的方法，可以达到一样的效果 */ .parent &#123; display: flex; &#125; .child &#123; margin: 0 auto; &#125;&lt;/style&gt; 优点 只需设置父节点属性，无需设置子元素 缺点 有兼容性问题 垂直居中子元素于父元素垂直居中且其（子元素与父元素）高度均可变。 table-cell + vertical-align 1234567891011&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt;` 兼容性好（支持 IE 8，以下版本需要调整页面结构至 table） absolute + transform 1234567891011121314&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; transform: translateY(-50%); &#125;&lt;/style&gt; 优点 绝对定位脱离文档流，不会对后续元素的布局造成影响。但如果绝对定位元素是唯一的元素则父元素也会失去高度。 缺点 -transform 为 CSS3 属性，有兼容性问题 flex + align-items 12345678910&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; align-items: center; &#125;&lt;/style&gt; 优点 只需设置父节点属性，无需设置子元素 缺点 有兼容性问题 水平与垂直居中子元素于父元素垂直及水平居中且其（子元素与父元素）高度宽度均可变。 inline-block + text-align + table-cell + vertical-align 1234567891011121314&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; text-align: center; display: table-cell; vertical-align: middle; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; absolute + transform 123456789101112131415&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; position: relative; &#125; .child &#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125;&lt;/style&gt; flex + justify-content + align-items 1234567891011&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content: center; align-items: center; &#125;&lt;/style&gt; 多列布局多列布局在网页中非常常见（例如两列布局），多列布局可以是两列定宽，一列自适应， 或者多列不定宽一列自适应还有等分布局等。 一列定宽，一列自适应 float + margin1234567891011121314151617181920&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left &#123; float: left; width: 100px; &#125; .right &#123; margin-left: 100px /*间距可再加入 margin-left */ &#125;&lt;/style&gt; float + overflow12345678910111213141516171819&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left &#123; float: left; width: 100px; &#125; .right &#123; overflow: hidden; &#125;&lt;/style&gt; 设置 overflow: hidden 会触发 BFC 模式（Block Formatting Context）块级格式化文本。 BFC 中的内容与外界的元素是隔离的。 table12345678910111213141516171819202122232425&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table; width: 100%; table-layout: fixed; &#125; .left &#123; display: table-cell; width: 100px; &#125; .right &#123; display: table-cell; /*宽度为剩余宽度*/ &#125;&lt;/style&gt; table 的显示特性为每列的单元格宽度合一定等与表格宽度。 table-layout: fixed; 可加速渲染，也是设定布局优先。 table-cell 中不可以设置 margin 但是可以通过 padding 来设置间距。 flex123456789101112131415161718192021222324&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .left &#123; width: 100px; margin-left: 20px; &#125; .right &#123; flex: 1; /*等价于*/ /*flex: 1 1 0;*/ &#125;&lt;/style&gt; flex-item 默认为内容宽度。 缺点 低版本浏览器兼容问题性能问题，只适合小范围布局。 两列定宽，一列自适应12345678910111213141516171819202122232425&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"center\"&gt; &lt;p&gt;center&lt;p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left, .center &#123; float: left; width: 100px; margin-right: 20px; &#125; .right &#123; overflow: hidden; /*等价于*/ /*flex: 1 1 0;*/ &#125;&lt;/style&gt; 一列不定宽加一列自适应不定宽的宽度为内容决定，下面为可以实现此效果的方法： float + overflow，此方法在 IE6 中有兼容性问题 table，此方法在 IE6 中有兼容性问题 flex，此方法在 IE9及其以下版本中有兼容性问题 多列等分布局float12345678910111213141516171819202122232425&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;3&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style media=\"screen\"&gt; .parent &#123; margin-left: -20px; &#125; .column &#123; float: left; width: 25%; padding-left: 20px; box-sizing: border-box; &#125;&lt;/style&gt; table1234567891011121314151617181920212223242526272829303132&lt;div class='parent-fix'&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;3&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;4&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style media=\"screen\"&gt; .parent-fix &#123; margin-left: -20px; &#125; .parent &#123; display: table; width: 100%; /*可以布局优先，也可以单元格宽度平分在没有设置的情况下*/ table-layout: fixed; &#125; .column &#123; display: table-cell; padding-left: 20px; &#125;&lt;/style&gt; flex12345678910111213141516171819202122232425262728&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;3&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt;4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style media=\"screen\"&gt; .parent &#123; display: flex; &#125; .column &#123; /*等价于 flex: 1 1 0;*/ flex: 1; &#125; .column+.column &#123; margin-left: 20px; &#125;&lt;/style&gt; 全屏布局例如管理系统，监控与统计平台均广泛的使用全屏布局。 实现方案 Position 常规方案 Flex CSS3 新实现 Position12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div class=\"parent\"&gt; &lt;div class=\"top\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt; /*辅助结构用于滚动*/ &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; html, body, .parent &#123; height: 100%; /*用于隐藏滚动条*/ overflo: hidden; &#125; .top &#123; /*相对于 body 定位*/ position: absolute; top: 0; left: 0; right: 0; height: 100px; &#125; .left &#123; position: absolute; left: 0; top: 100px; bottom: 50px; width: 200px; &#125; .right &#123; position: absolute; left: 200px; right: 0; top: 100px; bottom: 50px; overflow: auto; &#125; .right .inner &#123; /*此样式为演示所有*/ min-height: 1000px; &#125; .bottom &#123; position: absolute; left: 0; right: 0; bottom: 0; height: 50px; &#125;&lt;/style&gt; Flex1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class=\"parent\"&gt; &lt;div class=\"top\"&gt;&lt;/div&gt; &lt;div class=\"middle\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style media=\"screen\"&gt; html, body, parent &#123; height: 100%; overflow: hidden; &#125; .parent &#123; display: flex; flex-direction: column; &#125; .top &#123; height: 100px; &#125; .bottom &#123; height: 50px; &#125; .middle &#123; // 居中自适应 flex: 1; display: flex; /*flex-direction: row 为默认值*/ &#125; .left &#123; width: 200px; &#125; .right &#123; flex: 1; overflow: auto; &#125; .right .inner &#123; min-height: 1000px; &#125;&lt;/style&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"布局解决方案","slug":"技术/布局解决方案","permalink":"http://yoursite.com/categories/技术/布局解决方案/"}],"tags":[{"name":"布局解决方案","slug":"布局解决方案","permalink":"http://yoursite.com/tags/布局解决方案/"}]},{"title":"css学习系列","slug":"css学习系列","date":"2018-06-27T06:45:19.085Z","updated":"2018-06-27T12:02:14.567Z","comments":true,"path":"2018/06/27/css学习系列/","link":"","permalink":"http://yoursite.com/2018/06/27/css学习系列/","excerpt":"语法语法1234567891011/* 选择器 */.m-userlist &#123; /* 属性声明 */ margin: 0 0 30px; /* 属性名:属性值; */&#125;.m-userlist .list &#123; position: relative; height: 100px; overflow: hidden;&#125;","text":"语法语法1234567891011/* 选择器 */.m-userlist &#123; /* 属性声明 */ margin: 0 0 30px; /* 属性名:属性值; */&#125;.m-userlist .list &#123; position: relative; height: 100px; overflow: hidden;&#125; 浏览器私有属性 Google Chrome, Safari (-webkit) Firefox (-moz-) IE (-ms-) Opera (-o-) 12345.pic &#123; -webkit-transform: rotate(-3deg); -ms-transform: rotate(-3deg); transform: rotate(-3deg);&#125; CSS 预处理器（Sass，Less，Stylus）或编辑器插件可自动添加浏览器厂商的私有属性前缀。 @规则 常用的规则: @media （用于响应式布局） @keyframes （CSS 动画的中间步骤） @font-face （引入外部字体） 其他规则（不常用） @import @charset @namespace @page @supports @document 选择器简单选择器标签选择器 类选择器 id 选择器 通配符选择器 * 属性选择器 [attr] 或 [attr=val] 来选择相应的元素。#nav{…} 既等同于 [id=nav]{…}。 [attr~=val] 可选用与选择包含 val 属性值的元素，像class=”title sports” 与 class=”sports”。.sports{…} 既等同于 [class~=sports]{…} [attr|=val] 可以选择val开头及开头紧接-的属性值 [attr^=val] 可选择以val开头的属性值对应的元素，如果值为符号或空格则需要使用引号 “”。 [attr$=val] 可选择以val结尾的属性值对应的元素。 [attr*=val] 可选择以包含val属性值对应的元素。 伪类选择器常用伪类选择器： :link IE6+ :visited IE7+ :hover IE6中仅可用于链接 :active IE6/7中仅可用于链接 :enabled IE9+ :disabled IE9+ :checked IE9+ :first-child IE8+ :last-child IE9+ :nth-child(even) 可为 odd even 或数字 IE9+ :nth-last-child(n) n从 0 开始计算 IE9+ :only-child 仅选择唯一的元素 IE9+ :only-of-type IE9+ :first-of-type IE9+ :last-of-type IE9+ :nth-of-type(even) IE9+ :nth-last-of-type(2n) IE9+ element:nth-of-type(n) 指父元素下第 n 个 element 元素，element:nth-child(n) 指父元素下第 n 个元素且元素为 element，若不是，选择失败 其他选择器伪元素选择器注意与伪类学则器的区分。 ::first-letter IE6+ ::first-line IE6+ ::before{content: “before”} 需与 content 一同使用 IE8+ ::after{content: “after”} 需与 content 一同使用 IE8+ ::selection 被用户选中的内容（鼠标选择高亮属性）IE9+ Firefox需用 -moz 前缀 组合选择器 后代选择器 .main h2 {…}，使用 表示 IE6+ 子选择器 .main&gt;h2 {…}，使用&gt;表示 IE7+ 兄弟选择器 h2+p {…}，使用+表示 IE7+h2~p {…}，使用~表示（此标签无需紧邻）IE7+ 选择器分组 1h1, h2, h3 &#123;color: red;&#125; 继承、优先、层级子元素继承父元素的样式，但并不是所有属性都是默认继承的。通过文档中的 inherited: yes 来判断属性是否可以自动继承。 自动继承属性： color font text-align list-style 非继承属性： background border position 文本字体改变字号 12345678div font-size 12px p#sample0 font-size 16px p#sample1 font-size 2em p#sample2 font-size 200% 以上两值在开发中并不常用。2em 与 200% 都为父元素默认大小的两倍（参照物为父元素的字体大小 12px）。 改变字体 font-family: arial, Verdana, sans-serif; 优先使用靠前的字体 加粗字体 font-weight: normal;font-weight: bold; 倾斜字体font-style: normal | italic | oblique | inherit 更改行距1234567/* length 类型 */line-height: 40px;line-height: 3em;/* percentage 类型 */line-height: 300%;/* number 类型 */line-height: 3; 当line-height为 number 类型时，子类直接继承其数值（不计算直接继承）。 而当为 percentage 类型时，子类则会先计算再显示（先计算后继承）。 字间距（字母间距） letter-spacing: normal | 其用于设置字间距或者字母间距，此属性适用于中文或西文中的字母。 如果需要设置西文中词与词的间距或标签直接的距离则需要使用 word-spacing。 改变文字颜色color: 123456789101112131415element &#123; color: red; &#125;element &#123; color: #f00; &#125;element &#123; color: #ff0000; &#125;element &#123; color: rgb(255,0,0); &#125;element &#123; color: rgb(100%, 0%, 0%); &#125;element &#123; color: hsl(0, 100%, 50%); &#125;/* 50% translucent */element &#123; color: rgba(255, 0, 0, 0.5); &#125;element &#123; color: hsla(0, 100%, 50%, 0.5); &#125;/* 全透明 */element &#123; color: transparent' &#125;element &#123; color: rgba(0, 0, 0, 0); &#125; 对齐方式: 文字居中text-align: start | end | left | right | center | justify | match-parent | start end 文本垂直对齐vertical-align: baseline | sub | super | text-top | text-bottom | middle | top | bottom 文本缩进text-indent: &lt;length&gt; | &lt;percentage&gt; &amp;&amp; [ hanging || each-line ] 缩进两个字可使用 text-indent: 2em; 格式处理保留空格格式white-space: normal | pre | nowrap | pre-wrap | pre-line 文字换行word-wrap: normal | break-word 文本装饰文字阴影 1234p &#123; text-shadow: 1px 1px 1px #000, 3px 3px 5px blue;&#125; value = The X-coordinate X 轴偏移像素 value = The Y-coordinate Y 轴偏移像素 value = The blur radius 阴影模糊半径 value = The color of the shadow 阴影颜色（默认为文字颜色） 文本装饰（下划线等）text-decoration: 123456789101112131415161718h1.under &#123; text-decoration: underline;&#125;h1.over &#123; text-decoration: overline;&#125;p.line &#123; text-decoration: line-through;&#125;p.blink &#123; text-decoration: blink;&#125;a.none &#123; text-decoration: none;&#125;p.underover &#123; text-decoration: underline overline;&#125; 高级设置省略字符text-overflow: [ clip | ellipsis | ]{1,2} 12345/* 常用配合 */text-overflow: ellipsis;overflow: hidden; /* 溢出截取 */white-space: nowrap; /* 禁止换行 */ 更换鼠标形状cursor: 常用属性 &lt;uri&gt; 图片资源地址代替鼠标默认形状 &lt;default&gt; 默认光标 &lt;none&gt; 隐藏光标 &lt;pointer&gt; 手型光标 &lt;zoom-in&gt; &lt;zoom-out&gt; &lt;move&gt; 强制继承inherit 会强制继承父元素的属性值。 1234567font-size: inherit;font-family: inherit;font-weight: inherit;...word-wrap: inherit;work-break: inherittext-showdow: inherit 盒模型盒子模型是网页布局的基石。它有边框、外边距、内边距、内容组成。 盒子由上到下依次分为五层，它们自上而下的顺序是。 border 边框 content + padding 内容与内边距 background-image 背景图片 background-color 背景颜色 margin 外边距 width内容盒子宽 height内容盒子高 border-radius overflow box-sizing box-shadow box-shadow: 4px 6px 3px 0px red; | | | | 水平偏移| | | 垂直偏移 | | 模糊半径 | 阴影大小 背景background-color background-image background-image: url(“../image/pic.png”); 当background-color 与 background-image 共存时，背景颜色永远在最底层（于背景图片之下）。 background-repeat background-repeat 需与背景图片数量一致。 space 平铺并在水平和垂直留有空隙，空隙的大小为图片均匀分布后完整覆盖显示区域的宽高 round 不留空隙平铺且覆盖显示区域，图标会被缩放以达到覆盖效果（缩放不一定等比） background-attachment 当页面内容超过显示区域时，使用 local 使背景图片同页面内容一同滚动。12background-attachment: `&lt;attachment&gt;`[, `&lt;attachment&gt;`]*`&lt;attachment&gt;` = scroll | fixed | local background-position 12345678910111213141516/* 默认位置为 */background-position: 0 0;/* percentage 是容器与图片的百分比重合之处*/background-position: 20% 50%;/* 等同效果 */background-position: 50% 50%;background-position: center center;background-position: 0 0;background-position: left top;background-position: 100% 100%;background-position: right bottom; 布局、变形、动画 单独有文章分析了 这里略过","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"css","slug":"技术/css","permalink":"http://yoursite.com/categories/技术/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"html学习系列","slug":"html学习系列","date":"2018-06-27T02:58:04.598Z","updated":"2018-06-27T12:01:49.390Z","comments":true,"path":"2018/06/27/html学习系列/","link":"","permalink":"http://yoursite.com/2018/06/27/html学习系列/","excerpt":"简介：一个html分三部分： 文档声明：&lt;!DOCTYPE html&gt; 必须首行定格 文档头部 为文档标题 //文档解码格式 和 //提供给搜索引擎使用 //移动端浏览器的宽高与缩放 标签可以引入 favicon 和样式表 CSS 文件","text":"简介：一个html分三部分： 文档声明：&lt;!DOCTYPE html&gt; 必须首行定格 文档头部 为文档标题 //文档解码格式 和 //提供给搜索引擎使用 //移动端浏览器的宽高与缩放 标签可以引入 favicon 和样式表 CSS 文件 文档主体 HTML 语法书写规范： 小写标签和属性 属性值双引号 代码因嵌套缩进 全局属性 id, ，页面中唯一 class，Click Me，页面中可重复出现 style，尽量避免 title，对于元素的描述类似于 Tooltip 的效果。 HTML 标签&lt;body&gt; 页面内容 &lt;header&gt; 文档头部 &lt;nav&gt; 导航 &lt;aside&gt; 侧边栏 &lt;article&gt; 定义外部内容（如外部引用的文章） &lt;section&gt; 一个独立的块 &lt;footer&gt; 尾部 页面通常结构 文本标签 1234567891011121314151617181920212223&lt;!-- 默认超链接 --&gt;&lt;a href=\"http://sample-link.com\" title=\"Sample Link\"&gt;Sample&lt;/a&gt;&lt;!-- 当前窗口显示 --&gt;&lt;a href=\"http://sample-link.com\" title=\"Sample Link\" target=\"_self\"&gt;Sample&lt;/a&gt;&lt;!-- 新窗口显示 --&gt;&lt;a href=\"http://sample-link.com\" title=\"Sample Link\" target=\"_blank\"&gt;Sample&lt;/a&gt;&lt;!-- iframe 中打开链接 --&gt;&lt;a href=\"http://sample-link.com\" title=\"Sample Link\" target=\"iframe-name\"&gt;Sample&lt;/a&gt;&lt;iframe name=\"iframe-name\" frameborder=\"0\"&gt;&lt;/iframe&gt;&lt;!-- 页面中的锚点 --&gt;&lt;a href=\"#achor\"&gt;Achor Point&lt;/a&gt;&lt;section id=\"achor\"&gt;Achor Content&lt;/section&gt;&lt;!-- 邮箱及电话需系统支持 --&gt;&lt;a href=\"mailto:sample-address@me.com\" title=\"Email\"&gt;Contact Us&lt;/a&gt;&lt;!-- 多个邮箱地址 --&gt;&lt;a href=\"mailto:sample-address@me.com, sample-address0@me.com\" title=\"Email\"&gt;Contact Us&lt;/a&gt;&lt;!-- 添加抄送，主题和内容 --&gt;&lt;a href=\"mailto:sample-address@me.com?cc=admin@me.com&amp;subject=Help&amp;body=sample-body-text\" title=\"Email\"&gt;Contact Us&lt;/a&gt;&lt;!-- 电话示例 --&gt;&lt;a href=\"tel:99999999\" title=\"Phone\"&gt;Ring Us&lt;/a&gt; 组合内容标签 ‘` ‘` ‘` ‘` ‘` ‘` ‘` 文档章节&lt;body&gt; 页面内容 &lt;header&gt; 文档头部 &lt;nav&gt; 导航 &lt;aside&gt; 侧边栏 &lt;article&gt;定义外部内容（如外部引用的文章） &lt;section&gt; 一个独立的块 &lt;footer&gt;尾部 引用&lt;cite&gt; 引用作品的名字、作者的名字等&lt;q&gt; 引用一小段文字（大段文字引用用&lt;blockquote&gt;）&lt;blockquote&gt; 引用大块文字&lt;pre&gt; 保存格式化的内容（其空格、换行等格式不会丢失） 12345678&lt;pre&gt; &lt;code&gt; int main(void) &#123; printf('Hello, world!'); return 0; &#125;&lt;/code&gt;&lt;/pre&gt; 代码&lt;code&gt; 引用代码 格式化&lt;b&gt; 加粗 &lt;i&gt;斜体 强调&lt;em&gt; 斜体。着重于强调内容，会改变语义的强调&lt;strong&gt;粗体。着重于强调内容的重要性 换行&lt;br&gt; 换行 列表无序列表1234&lt;ul&gt; &lt;li&gt;标题&lt;/li&gt; &lt;li&gt;结论&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;第一&lt;/li&gt; &lt;li&gt;第二&lt;/li&gt;&lt;/ol&gt; 自定义列表1234567&lt;dl&gt; &lt;dt&gt;作者&lt;/dt&gt; &lt;dd&gt;爱因斯坦&lt;/dd&gt; &lt;dt&gt;作品&lt;/dt&gt; &lt;dd&gt;《相对论》&lt;/dd&gt; &lt;dd&gt;《时间与空间》&lt;/dd&gt;&lt;/dl&gt; 一个可以对应多个 &lt;dl&gt; 为自定义列表，其中包含一个或多个 &lt;dt&gt; 及 一个或多个 &lt;dd&gt;，并且dt 与 dl列表会有缩进的效果。&lt;pre&gt; 会保留换行和空格，通常与 &lt;code&gt; 一同使用。 &lt;blockquote&gt; 拥有 cite 属性，它包含引用文本的出处，示例如下所示： 123&lt;blockquote cite=\"http://example.com/facts\"&gt; &lt;p&gt;Sample Quote...&lt;/p&gt;&lt;/blockquote&gt; 嵌入 123456789101112131415&lt;iframe src=\"\"&gt;&lt;/iframe&gt; 页面操作可以不影响到iframe的内容&lt;!--object embed通常用来嵌入外部资源 --&gt;&lt;object type=\"application/x-shockwave-player\"&gt; &lt;param name=\"movie\" value=\"book.pdf\"&gt;&lt;/object&gt;&lt;!--视频 track可以引入字幕 autoplay可以使视频加载后自动播放，loop可以使其循环播放 --&gt;&lt;video autoplay loop controls=\"controls\" poster=\"poster.jpg\"&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.webm\" type=\"video/webm\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt; &lt;track kind=\"subtitles\" src=\"video.vtt\" srclang=\"cn\" label=\"cn\"&gt;&lt;/video&gt; 资源标签 图标签canvas 基于像素，性能要求比较高，可用于实时数据展示。svg 为矢量图形图像。 热点区域标签img中套用map以及area可以实现点击某部分图片触发一个链接，点击另一部分触发另一个链接 12345&lt;img src=\"mama.jpg\" width=100 height=100 usemap=\"#map\" /&gt;&lt;map name=\"map\"&gt; &lt;area shap=\"rect\" coords=\"0,0,50,50\" href=\"\" alt=\"\"&gt; &lt;area shap=\"circle\" coords=\"75,75,25\" href=\"\" alt=\"\"&gt;&lt;/map&gt; 表格表格代码示例 12345678910111213&lt;table&gt; &lt;caption&gt;table title and/or explanatory text&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;header&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;data&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 使用 colspan=val 进行跨列，使用 rowspan=val 进行跨行。 表单12345678910111213141516171819&lt;form action=\"WebCreation_submit\" method=\"get\" accept-charset=\"utf-8\"&gt; &lt;fieldset&gt; &lt;legend&gt;title or explanatory caption&lt;/legend&gt; &lt;!-- 第一种添加标签的方法 --&gt; &lt;label&gt;&lt;input type=\"text/submit/hidden/button/etc\" name=\"\" value=\"\"&gt;&lt;/label&gt; &lt;!-- 第二种添加标签的方法 --&gt; &lt;label for=\"input-id\"&gt;Sample Label&lt;/label&gt; &lt;input type=\"text\" id=\"input-id\"&gt; &lt;/fieldset&gt; &lt;fieldset&gt; &lt;legend&gt;title or explanatory caption&lt;/legend&gt; &lt;!-- 只读文本框 --&gt; &lt;input type=\"text\" readonly&gt; &lt;!-- 隐藏文本框，可提交影藏数据 --&gt; &lt;input type=\"text\" name=\"hidden-info\" value=\"hiden-info-value\" hidden&gt; &lt;/fieldset&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;button type=\"reset\"&gt;Reset&lt;/button&gt;&lt;/form&gt; 使用fieldset可用于对表单进行分区表单中的其他控件类型： textarea （文本框） select 与 option （下拉菜单可多选） 实体字符实体字符（ASCII Encoding Reference）是用来在代码中以实体代替与HTML语法相同的字符，避免浏览解析错误。它的两种表示方式，第一种为 &amp; 外加实体字符名称，例如 &amp;nbsp;，第二种为 &amp; 加实体字符序号，例如 &amp;#160;。 常用HTML字符实体（建议使用实体）： 常用特殊字符实体（不建议使用实体）： 浏览器兼容：主流浏览器都兼容 HTML5 的新标签，对于 IE8 及以下版本不认识 HTML5的新元素，可以使用 JavaScript 创建一个没用的元素来解决，例如： 123&lt;script&gt; document.createElement(\"header\");&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"html","slug":"技术/html","permalink":"http://yoursite.com/categories/技术/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"HTTP笔记实录5","slug":"http笔记实录5","date":"2018-06-27T01:06:58.298Z","updated":"2018-06-27T12:02:46.307Z","comments":true,"path":"2018/06/27/http笔记实录5/","link":"","permalink":"http://yoursite.com/2018/06/27/http笔记实录5/","excerpt":"第 5 章 与 HTTP 协作的 Web 服务器一台 Web 服务器可搭建多个独立域名的 Web 网站， 也可作为通信路径上的中转服务器提升传输效率 5.1 用单台虚拟主机实现多个域名HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。 比如， 提供 Web 托管服务（Web Hosting Service） 的供应商， 可以用一台服务器为多位客户服务， 也可以以每位客户持有的域名运行各自不同的网站。 这是因为利用了虚拟主机（Virtual Host， 又称虚拟服务器） 的功能。 即使物理层面只有一台服务器， 但只要使用虚拟主机的功能， 则可以假想已具有多台服务器。 在互联网上， 域名通过 DNS 服务映射到 IP 地址（域名解析） 之后访问目标网站。 可见， 当请求发送到服务器时， 已经是以 IP 地址形式访问了。 所以， 如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名， 当收到请求时就需要弄清楚究竟要访问哪个域名。 在相同的 IP 地址下， 由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站， 因此在发送 HTTP 请求时， 必须在 Host 首部内完整指定主机名或域名的 URI。","text":"第 5 章 与 HTTP 协作的 Web 服务器一台 Web 服务器可搭建多个独立域名的 Web 网站， 也可作为通信路径上的中转服务器提升传输效率 5.1 用单台虚拟主机实现多个域名HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。 比如， 提供 Web 托管服务（Web Hosting Service） 的供应商， 可以用一台服务器为多位客户服务， 也可以以每位客户持有的域名运行各自不同的网站。 这是因为利用了虚拟主机（Virtual Host， 又称虚拟服务器） 的功能。 即使物理层面只有一台服务器， 但只要使用虚拟主机的功能， 则可以假想已具有多台服务器。 在互联网上， 域名通过 DNS 服务映射到 IP 地址（域名解析） 之后访问目标网站。 可见， 当请求发送到服务器时， 已经是以 IP 地址形式访问了。 所以， 如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名， 当收到请求时就需要弄清楚究竟要访问哪个域名。 在相同的 IP 地址下， 由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站， 因此在发送 HTTP 请求时， 必须在 Host 首部内完整指定主机名或域名的 URI。 5.2 通信数据转发程序 ： 代理、 网关、 隧道HTTP 通信时， 除客户端和服务器以外， 还有一些用于通信数据转发的应用程序， 例如代理、 网关和隧道。 它们可以配合服务器工作。 这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器， 并且能接收从那台服务器发送的响应再转发给客户端。 代理代理是一种有转发功能的应用程序， 它扮演了位于服务器和客户端“中间人”的角色， 接收由客户端发送的请求并转发给服务器， 同时也接收服务器返回的响应并转发给客户端。代理不改变请求 URI， 会直接发送给前方持有资源的目标服务器使用代理服务器的理由有： 利用缓存技术（稍后讲解） 减少网络带宽的流量， 组织内部针对特定网站的访问控制， 以获取访问日志为主要目的， 等等。 网关网关是转发其他服务器通信数据的服务器， 接收从客户端发送来的请求时， 它就像自己拥有资源的源服务器一样对请求进行处理。 有时客户端可能都不会察觉， 自己的通信目标是一个网关。 利用网关能提高通信的安全性， 因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。 比如， 网关可以连接数据库， 使用SQL语句查询数据。 另外， 在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动 隧道隧道是在相隔甚远的客户端和服务器两者之间进行中转， 并保持双方通信连接的应用程序。 5.3 保存资源的缓存缓存是指代理服务器或客户端本地磁盘内保存的资源副本。 利用缓存可减少对源服务器的访问， 因此也就节省了通信流量和通信时间 5.3.1 缓存的有效期限当遇上源服务器上的资源更新时， 如果还是使用不变的缓存， 那就会演变成返回更新前的“旧”资源了。 即使存在缓存， 也会因为客户端的要求、 缓存的有效期等因素， 向源服务器确认资源的有效性。 若判断缓存失效， 缓存服务器将会再次从源服务器上获取“新”资源。 5.3.2 客户端的缓存缓存不仅可以存在于缓存服务器内， 还可以存在客户端浏览器中。 以Internet Explorer 程序为例， 把客户端缓存称为临时网络文件（Temporary Internet File） 。浏览器缓存如果有效， 就不必再向服务器请求相同的资源了， 可以直接从本地磁盘内读取","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"http://yoursite.com/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"HTTP笔记实录4","slug":"http笔记实录4","date":"2018-06-27T00:44:30.418Z","updated":"2018-06-27T12:01:14.436Z","comments":true,"path":"2018/06/27/http笔记实录4/","link":"","permalink":"http://yoursite.com/2018/06/27/http笔记实录4/","excerpt":"第 4 章 返回结果的 HTTP 状态码4.1 状态码告知从服务器端返回的请求结果数字中的第一位指定了响应类别， 后两位无分类。 响应类别有以下 5 种。表 4-1： 状态码的类别 4.2 2XX 成功2XX 的响应结果表明请求被正常处理了。 4.2.1 200 OK","text":"第 4 章 返回结果的 HTTP 状态码4.1 状态码告知从服务器端返回的请求结果数字中的第一位指定了响应类别， 后两位无分类。 响应类别有以下 5 种。表 4-1： 状态码的类别 4.2 2XX 成功2XX 的响应结果表明请求被正常处理了。 4.2.1 200 OK 4.2.2 204 No Content该状态码代表服务器接收的请求已成功处理， 但在返回的响应报文中不含实体的主体部分。 另外， 也不允许返回任何实体的主体。 比如，当从浏览器发出请求处理后， 返回 204 响应， 那么浏览器显示的页面不发生更新 4.2.3 206 Partial Content该状态码表示客户端进行了范围请求， 而服务器成功执行了这部分的GET 请求。 响应报文中包含由 Content-Range 指定范围的实体内容。 4.3 3XX 重定向3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 4.3.1 301 Moved Permanently永久性重定向。 该状态码表示请求的资源已被分配了新的 URI， 以后应使用资源现在所指的 URI。 也就是说， 如果已经把资源对应的 URI保存为书签了， 这时应该按 Location 首部字段提示的 URI 重新保存。 4.3.2 302 Found临时性重定向。 该状态码表示请求的资源已被分配了新的 URI， 希望用户（本次） 能使用新的 URI 访问。 和 301 Moved Permanently 状态码相似， 但 302 状态码代表的资源不是被永久移动， 只是临时性质的。 换句话说， 已移动的资源对应的URI 将来还有可能发生改变。 比如， 用户把 URI 保存成书签， 但不会像 301 状态码出现时那样去更新书签， 而是仍旧保留返回 302 状态码的页面对应的 URI。 4.3.3 303 See Other该状态码表示由于请求对应的资源存在着另一个 URI， 应使用 GET方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相同的功能， 但 303 状态码明确表示客户端应当采用 GET 方法获取资源， 这点与 302 状态码有区别。 4.3.4 304 Not Modified该状态码表示客户端发送附带条件的请求 2 时， 服务器端允许请求访问资源， 但未满足条件的情况。 304 状态码返回时， 不包含任何响应的主体部分。 304 虽然被划分在 3XX 类别中， 但是和重定向没有关系 4.3.5 307 Temporary Redirect临时重定向。 该状态码与 302 Found 有着相同的含义。 尽管 302 标准禁止 POST 变换成 GET， 但实际使用时大家并不遵守 4.4 4XX 客户端错误4.4.1 400 Bad Request该状态码表示请求报文中存在语法错误。 当错误发生时， 需修改请求的内容后再次发送请求。 另外， 浏览器会像 200 OK 一样对待该状态码。 4.4.2 401 Unauthorized 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证） 的认证信息。 另外若之前已进行过 1 次请求， 则表示用户认证失败。 4.4.3 403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。 服务器端没有必要给出拒绝的详细理由， 但如果想作说明的话， 可以在实体的主体部分对原因进行描述， 这样就能让用户看到了。 未获得文件系统的访问授权， 访问权限出现某些问题（从未授权的发送源 IP 地址试图访问） 等列举的情况都可能是发生 403 的原因。 4.4.4 404 Not Found该状态码表明服务器上无法找到请求的资源。 除此之外， 也可以在服务器端拒绝请求且不想说明理由时使用 4.5 5XX 服务器错误5XX 的响应结果表明服务器本身发生错误。 4.5.1 500 Internal Server Error该状态码表明服务器端在执行请求时发生了错误。 也有可能是 Web应用存在的 bug 或某些临时的故障 4.5.2 503 Service Unavailable该状态码表明服务器暂时处于超负载或正在进行停机维护， 现在无法处理请求。 如果事先得知解除以上状况需要的时间， 最好写入RetryAfter 首部字段再返回给客户端","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"http://yoursite.com/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"HTTP笔记实录3","slug":"http笔记实录3","date":"2018-06-26T08:28:19.967Z","updated":"2018-06-26T13:30:41.092Z","comments":true,"path":"2018/06/26/http笔记实录3/","link":"","permalink":"http://yoursite.com/2018/06/26/http笔记实录3/","excerpt":"第 3 章 HTTP 报文内的 HTTP信息HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。 本章就让我们来了解一下请求和响应是怎样运作的。 3.1 HTTP 报文用于 HTTP 协议交互的信息被称为 HTTP 报文。 请求端（客户端） 的HTTP 报文叫做请求报文， 响应端（服务器端） 的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符） 数据构成的字符串文本。 HTTP 报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF） 来划分。 通常， 并不一定要有报文主体。","text":"第 3 章 HTTP 报文内的 HTTP信息HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。 本章就让我们来了解一下请求和响应是怎样运作的。 3.1 HTTP 报文用于 HTTP 协议交互的信息被称为 HTTP 报文。 请求端（客户端） 的HTTP 报文叫做请求报文， 响应端（服务器端） 的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符） 数据构成的字符串文本。 HTTP 报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF） 来划分。 通常， 并不一定要有报文主体。 3.2 请求报文及响应报文的结构 请求行包含用于请求的方法， 请求 URI 和 HTTP 版本。状态行包含表明响应结果的状态码， 原因短语和 HTTP 版本。首部字段包含表示请求和响应的各种条件和属性的各类首部。 一般有 4 种首部， 分别是： 通用首部、 请求首部、 响应首部和实体首部 3.3 编码提升传输速率HTTP 在传输数据时可以按照数据原貌直接传输， 但也可以在传输过程中通过编码提升传输速率。 通过在传输时编码， 能有效地处理大量的访问请求。 但是， 编码的操作需要计算机来完成， 因此会消耗更多的 CPU 等资源。 3.3.1 报文主体和实体主体的差异 报文（ message）是 HTTP 通信中的基本单位， 由 8 位组字节流（octet sequence，其中 octet 为 8 个比特） 组成， 通过 HTTP 通信传输。 实体（entity） 作为请求或响应的有效载荷数据（补充项） 被传输， 其内容由实体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。 通常， 报文主体等于实体主体。 只有当传输中进行编码操作时， 实体主体的内容发生变化， 才导致它和报文主体产生差异 3.3.2 压缩传输的内容编码向待发送邮件内增加附件时， 为了使邮件容量变小， 我们会先用 ZIP压缩文件之后再添加附件发送。 HTTP 协议中有一种被称为内容编码的功能也能进行类似的操作。 3.3.3 分割发送的分块传输编码在 HTTP 通信过程中， 请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。 在传输大容量数据时， 通过把数据分割成多块， 能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding） 。 3.4 发送多种数据的多部分对象集合多部分对象集合包含的对象如下。 multipart/form-data 在 Web 表单文件上传时使用。 multipart/byteranges 状态码 206（Partial Content， 部分内容） 响应报文包含了多个范围的内容时使用。 在 HTTP 报文中使用多部分对象集合时， 需要在首部字段里加上Content-type。 有关这个首部字段， 我们稍后讲解。 3.5 获取部分内容的范围请求以前， 用户不能使用现在这种高速的带宽访问互联网， 当时， 下载一个尺寸稍大的图片或文件就已经很吃力了。 如果下载过程中遇到网络中断的情况， 那就必须重头开始。 为了解决上述问题， 需要一种可恢复的机制。 所谓恢复是指能从之前下载中断处恢复下载。 要实现该功能需要指定下载的实体范围。 像这样， 指定范围发送的请求叫做范围请求（ Range Request） 。 执行范围请求时， 会用到首部字段 Range 来指定资源的 byte 范围。 byte 范围的指定形式如下。 3.6 内容协商返回最合适的内容同一个 Web 网站有可能存在着多份相同内容的页面。 比如英语版和中文版的 Web 页面， 它们内容上虽相同， 但使用的语言却不同。 当浏览器的默认语言为英语或中文， 访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。 这样的机制称为内容协商（Content Negotiation） 。 包含在请求报文中的某些首部字段（如下） 就是判断的基准。 这些首部字段的详细说明请参考下一章。 AcceptAccept-CharsetAccept-EncodingAccept-LanguageContent-Languag 内容协商技术有以下 3 种类型： 服务器驱动协商（ Server-driven Negotiation） 服务器驱动协商（ Server-driven Negotiation） 透明协商（ Transparent Negotiation）","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"http://yoursite.com/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"HTTP笔记实录2","slug":"http笔记实录2","date":"2018-06-26T07:55:04.485Z","updated":"2018-06-26T13:30:55.737Z","comments":true,"path":"2018/06/26/http笔记实录2/","link":"","permalink":"http://yoursite.com/2018/06/26/http笔记实录2/","excerpt":"第 2 章 简单的 HTTP 协议2.1 HTTP 协议用于客户端和服务器端之间的通信HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同， 用于客户端和服务器之间的通信。 请求访问文本或图像等资源的一端称为客户端， 而提供资源响应的一端称为服务器端。","text":"第 2 章 简单的 HTTP 协议2.1 HTTP 协议用于客户端和服务器端之间的通信HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同， 用于客户端和服务器之间的通信。 请求访问文本或图像等资源的一端称为客户端， 而提供资源响应的一端称为服务器端。 2.2 通过请求和响应的交换达成通信 起始行开头的GET表示请求访问服务器的类型， 称为方法（method） 。 随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI（request-URI） 。 最后的 HTTP/1.1， 即 HTTP 的版本号， 用来提示客户端使用的 HTTP 协议功能。 请求报文是由请求方法、 请求 URI、 协议版本、 可选的请求首部字段和内容实体构成的。 接收到请求的服务器， 会将请求内容的处理结果以响应的形式返回： 在起始行开头的 HTTP/1.1 表示服务器对应的 HTTP 版本。紧挨着的 200 OK 表示请求的处理结果的状态码（status code） 和原因短语（reason-phrase） 。 下一行显示了创建响应的日期时间， 是首部字段（header field） 内的一个属性。接着以一空行分隔， 之后的内容称为资源实体的主体（entitybody） 。响应报文基本上由协议版本、 状态码（表示请求成功或失败的数字代码） 、 用以解释状态码的原因短语、 可选的响应首部字段以及实体主体构成。 2.3 HTTP 是不保存状态的协议HTTP 是一种不保存状态， 即无状态（stateless） 协议。 HTTP 协议自身不对请求和响应之间的通信状态进行保存。 也就是说在 HTTP 这个级别， 协议对于发送过的请求或响应都不做持久化处理。 可是， 随着 Web 的不断发展， 因无状态而导致业务处理变得棘手的情况增多了。 比如， 用户登录到一家购物网站， 即使他跳转到该站的其他页面后， 也需要能继续保持登录状态。 针对这个实例， 网站为了能够掌握是谁送出的请求， 需要保存用户的状态。 HTTP/1.1 虽然是无状态协议， 但为了实现期望的保持状态功能， 于是引入了 Cookie 技术。 有了 Cookie 再用 HTTP 协议通信， 就可以管理状态了。 2.4 请求 URI 定位资源HTTP 协议使用 URI 定位互联网上的资源。 正是因为 URI 的特定功能， 在互联网上任意位置的资源都能访问到。 2.5 告知服务器意图的 HTTP 方法 GET ： 获取资源GET 方法用来请求访问已被 URI 识别的资源。 指定的资源经服务器端解析后返回响应内容。 也就是说， 如果请求的资源是文本， 那就保持原样返回； 如果是像 CGI（Common Gateway Interface， 通用网关接口） 那样的程序， 则返回经过执行后的输出结果。 POST： 传输实体主体POST 方法用来传输实体的主体。虽然用 GET 方法也可以传输实体的主体， 但一般不用 GET 方法进行传输， 而是用 POST 方法。 虽说 POST 的功能与 GET 很相似， 但POST 的主要目的并不是获取响应的主体内容。 PUT： 传输文件PUT 方法用来传输文件。 就像 FTP 协议的文件上传一样， 要求在请求报文的主体中包含文件内容， 然后保存到请求 URI 指定的位置。 但是， 鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制， 任何人都可以上传文件 , 存在安全性问题， 因此一般的 Web 网站不使用该方法。 若配合 Web 应用程序的验证机制， 或架构设计采用。 HEAD： 获得报文首部HEAD 方法和 GET 方法一样， 只是不返回报文主体部分。 用于确认URI 的有效性及资源更新的日期时间等。 DELETE： 删除文件DELETE 方法用来删除文件， 是与 PUT 相反的方法。 DELETE 方法按请求 URI 删除指定的资源。但是， HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制， 所以一般的 Web 网站也不使用 DELETE 方法。 当配合 Web 应用程序的验证机制， 或遵守 REST 标准时还是有可能会开放使用的。 OPTIONS： 询问支持的方法OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。 TRACE： 追踪路径TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。 不长用到，不做解释。 -CONNECT： 要求用隧道协议连接代理CONNECT 方法要求在与代理服务器通信时建立隧道， 实现用隧道协议进行 TCP 通信。 主要使用 SSL（Secure Sockets Layer， 安全套接层） 和 TLS（Transport Layer Security， 传输层安全） 协议把通信内容加 密后经网络隧道传输 2.6 使用方法下达命令向请求 URI 指定的资源发送请求报文时， 采用称为方法的命令。方法的作用在于， 可以指定请求的资源按期望产生某种行为。 方法中有 GET、 POST 和 HEAD 等 2.7 持久连接节省通信量HTTP 协议的初始版本中， 每进行一次 HTTP 通信就要断开一次 TCP连接。 每次的请求都会造成无谓的 TCP 连接建立和断开， 增加通信量的开销。 2.7.1 持久连接为解决上述 TCP 连接的问题， HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections， 也称为 HTTP keep-alive 或HTTP connection reuse） 的方法。 持久连接的特点是， 只要任意一端没有明确提出断开连接， 则保持 TCP 连接状态。 持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销， 减轻了服务器端的负载。 另外， 减少开销的那部分时间， 使HTTP 请求和响应能够更早地结束， 这样 Web 页面的显示速度也就相应提高了 2.7.2 管线化持久连接使得多数请求以管线化（pipelining） 方式发送成为可能。 从前发送请求后需等待并收到响应， 才能发送下一个请求。 管线化技术出现后， 不用等待响应亦可直接发送下一个请求。 这样就能够做到同时并行发送多个请求， 而不需要一个接一个地等待响应了 2.8 使用 Cookie 的状态管理假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态） ， 那么每次跳转新页面不是要再次登录， 就是要在每次请求报文中附加参数来管理登录状态。 不可否认， 无状态协议当然也有它的优点。 由于不必保存状态， 自然可减少服务器的 CPU 及内存资源的消耗。 从另一侧面来说， 也正是因为 HTTP 协议本身是非常简单的， 所以才会被应用在各种场景里 保留无状态协议这个特征的同时又要解决类似的矛盾问题， 于是引入了 Cookie 技术。 Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息， 通知客户端保存 Cookie。 当下次客户端再往该服务器发送请求时， 客户端会自动在请求报文中加入 Cookie 值后发送出去。 服务器端发现客户端发送过来的 Cookie 后， 会去检查究竟是从哪一个客户端发来的连接请求， 然后对比服务器上的记录， 最后得到之前的状态信息。 HTTP 请求报文和响应报文的内容如下：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"http://yoursite.com/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"HTTP笔记实录","slug":"http笔记实录","date":"2018-06-26T06:47:55.140Z","updated":"2018-06-26T13:31:09.161Z","comments":true,"path":"2018/06/26/http笔记实录/","link":"","permalink":"http://yoursite.com/2018/06/26/http笔记实录/","excerpt":"一、了解Web及网络基础1.1 使用 HTTP 协议访问 Web当我们在网页浏览器（Web browser） 的地址栏中输入 URL时， Web 页面是如何呈现的？ 根据 Web 浏览器地址栏中指定的URL， Web 浏览器从 Web 服务器端获取文件资源（resource）等信息， 从而显示出 Web 页面。像这种通过发送请求获取服务器资源的 Web 浏览器等， 都可称为客户端（client） 。 Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。可以说，Web是建立在 HTTP 协议上通信的。","text":"一、了解Web及网络基础1.1 使用 HTTP 协议访问 Web当我们在网页浏览器（Web browser） 的地址栏中输入 URL时， Web 页面是如何呈现的？ 根据 Web 浏览器地址栏中指定的URL， Web 浏览器从 Web 服务器端获取文件资源（resource）等信息， 从而显示出 Web 页面。像这种通过发送请求获取服务器资源的 Web 浏览器等， 都可称为客户端（client） 。 Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。可以说，Web是建立在 HTTP 协议上通信的。 提出了3项 WWW 构建技术： 分别是： 把 SGML（Standard Generalized Markup Language， 标准通用标记语言） 作为页面的文本标记语言的 HTML（HyperText Markup Language， 超文本标记语言） ； 作为文档传递协议的 HTTP ； 指定文档所在地址的 URL（Uniform Resource Locator， 统一资源定位符） 。 1.2 网络基础 TCP/IP通常使用的网络（包括互联网） 是在 TCP/IP 协议族的基础上运作的。 而 HTTP 属于它内部的一个子集。 1.2.1 TCP/IP 协议族 计算机与网络设备要相互通信， 双方就必须基于相同的方法。 协议中存在各式各样的内容。 从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、 双方建立通信的顺序， 以及 Web 页面显示需要处理的步骤， 等等。 像这样把与互联网相关联的协议集合起来总称为 TCP/IP。 1.2.2 TCP/IP 的分层管理TCP/IP 协议族里重要的一点就是分层。 TCP/IP 协议族按层次分别分为以下 4 层： 应用层 传输层 网络层 数据链路层 把 TCP/IP 层次化是有好处的。 比如， 如果互联网只由一个协议统筹， 某个地方需要改变设计时， 就必须把所有部分整体替换掉。 而分层之后只需把变动的层替换掉即可。 把各层之间的接口部分规划好之后， 每个层次内部的设计就能够自由改动了。 TCP/IP 协议族各层的作用如下。应用层: 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。 比如， FTP（FileTransfer Protocol， 文件传输协议） 和 DNS（Domain Name System， 域名系统） 服务就是其中两类。 HTTP 协议也处于该层。 传输层： 传输层对上层应用层， 提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议： TCP（Transmission Control Protocol， 传输控制协议）和 UDP（User Data Protocol， 用户数据报协议。 网络层（ 又名网络互连层）： 网络层用来处理在网络上流动的数据包。 数据包是网络传输的最小数据单位。 该层规定了通过怎样的路径（所谓的传输路线） 到达对方计算机， 并把数据包传送给对方。 与对方计算机之间通过多台计算机或网络设备进行传输时， 网络层所起的作用就是在众多的选项内选择一条传输路线。 链路层（ 又名数据链路层， 网络接口层）： 用来处理连接网络的硬件部分。 包括控制操作系统、 硬件的设备驱动、 NIC（Network Interface Card， 网络适配器， 即网卡） ， 及光纤等物理可见部分（还包括连接器等一切传输媒介） 。 硬件上的范畴均在链路层的作用范围之内。 1.2.3 TCP/IP 通信传输流 利用 TCP/IP 协议族进行网络通信时， 会通过分层顺序与对方进行通信。 发送端从应用层往下走，接收端则往应用层往上走。 我们用 HTTP 举例来说明， 首先作为发送端的客户端在应用层（HTTP 协议） 发出一个想看某个 Web 页面的 HTTP 请求。 接着， 为了传输方便， 在传输层（TCP 协议） 把从应用层处收到的数据（HTTP 请求报文） 进行分割， 并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP 协议） ， 增加作为通信目的地的 MAC 地址后转发给链路层。 这样一来， 发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据， 按序往上层发送， 一直到应用层。 当传输到应用层， 才能算真正接收到由客户端发送过来的 HTTP请求 1.3 与 HTTP 关系密切的协议 : IP、 TCP 和 DNS1.3.1 负责传输的 IP 协议按层次分， IP（Internet Protocol） 网际协议位于网络层。 可能有人会把“IP”和“IP 地址”搞混， “IP”其实是一种协议的名称。 IP 协议的作用是把各种数据包传送给对方。 而要保证确实传送到对方那里， 则需要满足各类条件。 其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address） 。 IP 地址指明了节点被分配到的地址， MAC 地址是指网卡所属的固定地址。 IP 地址可以和 MAC 地址进行配对。 IP 地址可变换， 但 MAC地址基本上不会更改。 IP 间的通信依赖 MAC 地址。 在网络上， 通信的双方在同一局域网（LAN） 内的情况是很少的， 通常是经过多台计算机和网络设备中转才能连接到对方。 而在进行中转时， 会利用下一站中转设备的 MAC地址来搜索下一个中转目标。 这时， 会采用 ARP 协议（AddressResolution Protocol） 。 ARP 是一种用以解析地址的协议， 根据通信方的 IP 地址就可以反查出对应的 MAC 地址。 在到达通信目标前的中转过程中， 那些计算机和路由器等网络设备只能获悉很粗略的传输路线。 这种机制称为路由选择（routing） ， 有点像快递公司的送货过程。 想要寄快递的人， 只要将自己的货物送到集散中心， 就可以知道快递公司是否肯收件发货， 该快递公司的集散中心检查货物的送达地址， 明确下站该送往哪个区域的集散中心。 接着， 那个区域的集散中心自会判断是否能送到对方的家中。 1.3.2 确保可靠性的 TCP 协议按层次分， TCP 位于传输层， 提供可靠的字节流服务。 所谓的字节流服务（Byte Stream Service） 是指， 为了方便传输， 将大块数据分割成以报文段（segment） 为单位的数据包进行管理。 而可靠的传输服务是指， 能够把数据准确可靠地传给对方。 一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割， 而且 TCP 协议能够确认数据最终是否送达到对方。 确保数据能到达目标 为了准确无误地将数据送达目标处， TCP 协议采用了三次握手（three-way handshaking） 策略。 用 TCP 协议把数据包送出去后， TCP不会对传送后的情况置之不理， 它一定会向对方确认是否成功送达。 握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。 发送端首先发送一个带 SYN 标志的数据包给对方。 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。 最后， 发送端再回传一个带 ACK 标志的数据包， 代表“握手”结束。 若在握手过程中某个阶段莫名中断， TCP 协议会再次以相同的顺序发送相同的数据包 1.4 负责域名解析的 DNS 服务DNS（Domain Name System） 服务是和 HTTP 协议一样位于应用层的协议。 它提供域名到 IP 地址之间的解析服务。 计算机既可以被赋予 IP 地址， 也可以被赋予主机名和域名。 比如 www.hackr.jp。 用户通常使用主机名或域名来访问对方的计算机， 而不是直接通过 IP地址访问。 因为与 IP 地址的一组纯数字相比， 用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。 但要让计算机去理解名称， 相对而言就变得困难了。 因为计算机更擅长处理一长串数字。为了解决上述的问题， DNS 服务应运而生。 DNS 协议提供通过域名查找 IP 地址， 或逆向从 IP 地址反查域名的服务。 1.5 各种协议与 HTTP 协议的关系学习了和 HTTP 协议密不可分的 TCP/IP 协议族中的各种协议后， 我们再通过这张图来了解下 IP 协议、 TCP 协议和 DNS 服务在使用HTTP 协议的通信过程中各自发挥了哪些作用 1.6 URI 和 URL与 URI（统一资源标识符） 相比， 我们更熟悉 URL（UniformResource Locator， 统一资源定位符） 。 URL正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。 比如， 下图的 http://hackr.jp/ 就是 URL。 1.6.1 统一资源标识符URI 是 Uniform Resource Identifier 的缩写。 RFC2396 分别对这 3 个单词进行了如下定义： Uniform 规定统一的格式可方便处理多种不同类型的资源， 而不用根据上下文环境来识别资源指定的访问方式。 另外， 加入新增的协议方案（如http: 或 ftp:） 也更容易。 Resource 资源的定义是“可标识的任何东西”。 除了文档文件、 图像或服务（例如当天的天气预报） 等能够区别于其他类型的， 全都可作为资源。 另外， 资源不仅可以是单一的， 也可以是多数的集合体。 Identifier 表示可标识的对象。 也称为标识符。 采用 HTTP 协议时， 协议方案就是 http。 除此之外， 还有 ftp、mailto、 telnet、 file 等。 URI 用字符串标识某一互联网资源， 而 URL表示资源的地点（互联网上所处的位置） 。 可见 URL是 URI 的子集。 1.6.2 URI 格式让我们先来了解一下绝对 URI 的格式 使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。 不区分字母大小写， 最后附一个冒号（:） 。 登录信息（ 认证）指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证） 。 此项是可选项。 服务器地址使用绝对 URI 必须指定待访问的服务器地址。 地址可以是类似hackr.jp 这种 DNS 可解析的名称， 或是 192.168.1.1 这类 IPv4 地址名， 还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。 服务器端口号指定服务器连接的网络端口号。 此项也是可选项， 若用户省略则自动使用默认端口号。 带层次的文件路径指定服务器上的文件路径来定位特指的资源。 这与 UNIX 系统的文件目录结构相似。 -查询字符串针对已指定的文件路径内的资源， 可以使用查询字符串传入任意参数。 此项可选。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"HTTP","slug":"技术/HTTP","permalink":"http://yoursite.com/categories/技术/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"理解Promise","slug":"理解promise","date":"2018-06-26T01:03:29.328Z","updated":"2018-06-26T06:43:41.986Z","comments":true,"path":"2018/06/26/理解promise/","link":"","permalink":"http://yoursite.com/2018/06/26/理解promise/","excerpt":"","text":"Promise in js 回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。而 Promise 很好地解决了这一切。 另外解决回调地狱的问题。 所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。 Promise 对象有以下两个特点。（1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。 Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 12345678910111213var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(value) &#123; // failure&#125;); Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 方法和 reject 方法。 如果异步操作成功，则用 resolve 方法将 Promise 对象的状态，从「未完成」变为「成功」（即从 pending 变为 resolved）； 如果异步操作失败，则用 reject 方法将 Promise 对象的状态，从「未完成」变为「失败」（即从 pending 变为 rejected）。 基本的 api: Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() // 所有的完成 1var p = Promise.all([p1,p2,p3]); Promise.race() // 竞速，完成一个即可 进阶promises 的奇妙在于给予我们以前的 return 与 throw，每个 Promise 都会提供一个 then() 函数，和一个 catch()，实际上是 then(null, …) 函数， 123somePromise().then(functoin()&#123; // do something &#125;); 我们可以做三件事， return 另一个 promise return 一个同步的值 (或者 undefined) throw 一个同步异常 throw new Eror(‘’); 封装同步与异步代码 12 new Promise(function (resolve, reject) {resolve(someValue);});1写成 Promise.resolve(someValue);12","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"理解Promise","slug":"技术/理解Promise","permalink":"http://yoursite.com/categories/技术/理解Promise/"}],"tags":[{"name":"理解Promise","slug":"理解Promise","permalink":"http://yoursite.com/tags/理解Promise/"}]},{"title":"npm 再了解","slug":"NPM再了解","date":"2018-06-25T03:09:34.699Z","updated":"2018-06-25T03:21:01.236Z","comments":true,"path":"2018/06/25/NPM再了解/","link":"","permalink":"http://yoursite.com/2018/06/25/NPM再了解/","excerpt":"虽然之前已经学习并使用过npm了，这篇文章主要为了总结并学习的。","text":"虽然之前已经学习并使用过npm了，这篇文章主要为了总结并学习的。 npm模块管理器npm的出现则是为了在CommonJS规范的基础上，实现解决包的安装卸载，依赖管理，版本管理等问题,npm不需要单独安装。在安装Node的时候，会连带一起安装npm 允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 npm包一个符合CommonJS规范的包应该是如下这种结构： 一个package.json文件应该存在于包顶级目录下 二进制文件应该包含在bin目录下。 JavaScript代码应该包含在lib目录下。 文档应该在doc目录下。 单元测试应该在test目录下 package.json name：包名，需要在NPM上是唯一的，小写字母和数字组成可包含_ - .但不能有空格 description：包简介。通常会显示在一些列表中 version：版本号。一个语义化的版本号（http://semver.org/ ），通常为x.y.z。该版本号十分重要，常常用于一些版本控制的场合 keywords：关键字数组。用于NPM中的分类搜索 maintainers：包维护者的数组。数组元素是一个包含name、email、web三个属性的JSON对象 contributors：包贡献者的数组。第一个就是包的作者本人。在开源社区，如果提交的patch被merge进master分支的话，就应当加上这 个贡献patch的人。格式包含name和email bugs：一个可以提交bug的URL地址。可以是邮件地址（mailto:mailxx@domain），也可以是网页地址 licenses：包所使用的许可证 repositories：托管源代码的地址数组 dependencies：当前包需要的依赖。这个属性十分重要，NPM会通过这个属性，帮你自动加载依赖的包 npm的使用查看各种信息 1234567891011# 查看 npm 命令列表$ npm help# 查看各个命令的简单用法$ npm -l# 查看 npm 的版本$ npm -v# 查看 npm 的配置$ npm config list -l npm 命令安装模块Node模块采用npm install命令安装。 每个模块可以“全局安装”，也可以“本地安装”。“全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块。“本地安装”指的是将一个模块下载到当前项目的node_modules子目录，然后只有在项目目录之中，才能调用这个模块。 本地安装$ npm install 全局安装$ sudo npm install -global $ sudo npm install -g 指定所安装的模块属于哪一种性质的依赖关系 –save：模块名将被添加到dependencies，可以简化为参数-S。 –save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。 $ npm install –save$ npm install –save-dev 卸载模块我们可以使用以下命令来卸载 Node.js 模块 $ npm uninstall 更新模块我们可以使用以下命令来卸载 Node.js 模块 $ npm update 创建模块我们可以使用以下命令来创建 Node.js 模块 $ npm init npm init创建模块会在交互命令行帮我们生产package.json文件12345678910111213141516171819202122232425262728293031$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt; --save` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.name: (node_modules) test # 模块名version: (1.0.0) description: Node.js 测试模块 # 描述entry point: (index.js) test command: make testgit repository: https://github.com/test/test.git # Github 地址keywords: author: license: (ISC) About to write to ……/node_modules/package.json: # 生成地址&#123; &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Node.js 测试模块&quot;, ……&#125;Is this ok? (yes) yes 模块发布发布模块前首先要在npm注册用户 $ npm adduserUsername: liuxingPassword:Email: (this IS public) ogilhinn@gmail.com 然后 $ npm publish现在我们的npm包就成功发布了。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"npm","slug":"技术/npm","permalink":"http://yoursite.com/categories/技术/npm/"}],"tags":[{"name":"Rnpm","slug":"Rnpm","permalink":"http://yoursite.com/tags/Rnpm/"}]},{"title":"JS事件循环","slug":"JS关于事件循环","date":"2018-06-25T02:11:34.216Z","updated":"2018-06-25T02:33:18.949Z","comments":true,"path":"2018/06/25/JS关于事件循环/","link":"","permalink":"http://yoursite.com/2018/06/25/JS关于事件循环/","excerpt":"","text":"一、为什么JavaScript是单线程？JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 二、任务队列单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待 状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 下图就是主线程和任务队列的示意图。 三、事件和回调函数“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"JS事件循环","slug":"技术/JavaScript/JS事件循环","permalink":"http://yoursite.com/categories/技术/JavaScript/JS事件循环/"}],"tags":[{"name":"JS事件循环","slug":"JS事件循环","permalink":"http://yoursite.com/tags/JS事件循环/"}]},{"title":"meta标签常用属性整理","slug":"meta标签常用属性整理","date":"2018-06-24T12:05:43.335Z","updated":"2018-06-24T12:45:31.383Z","comments":true,"path":"2018/06/24/meta标签常用属性整理/","link":"","permalink":"http://yoursite.com/2018/06/24/meta标签常用属性整理/","excerpt":"概要： 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。","text":"概要： 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 SEO优化 页面关键词，每个网页应具有描述该网页内容的一组唯一的关键字。使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过 874 个字符。 1&lt;meta name=\"keywords\" content=\"your tags\" /&gt; 页面描述，每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。 1&lt;meta name=\"description\"content=\"150 words\" /&gt; 搜索引擎索引方式，robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。 123456789&lt;meta name=\"robots\" content=\"index,follow\" /&gt; &lt;!-- all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。 --&gt; 页面重定向和刷新：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。 1&lt;meta http-equiv=\"refresh\" content=\"0;url=\" /&gt; 其他 1234&lt;meta name=\"author\" content=\"author name\" /&gt; &lt;!-- 定义网页作者 --&gt; &lt;meta name=\"google\" content=\"index,follow\" /&gt; &lt;meta name=\"googlebot\" content=\"index,follow\" /&gt; &lt;meta name=\"verify\" content=\"index,follow\" /&gt; 移动设备 viewport：能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。 大部分4.7-5寸设备的viewport宽设为360px；5.5寸设备设为400px；iphone6设为375px；ipone6 plus设为414px。 12&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no\"/&gt; &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 --&gt; width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素） height：高度（数值 / device-height）（范围从223 到10,000） initial-scale：初始的缩放比例 （范围从&gt;0 到10） minimum-scale：允许用户缩放到的最小比例 maximum-scale：允许用户缩放到的最大比例 user-scalable：用户是否可以手动缩 (no,yes) minimal-ui：可以在页面加载时最小化上下状态栏。（已弃用） WebApp全屏模式：伪装app，离线应用。 1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; &lt;!-- 启用 WebApp 全屏模式 --&gt; 隐藏状态栏/设置状态栏颜色：只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。 &lt;meta name=”apple-mobile-web-app-status-bar-style”content=”black-translucent” /&gt; 添加到主屏后的标题 &lt;meta name=”apple-mobile-web-app-title”content=”标题”&gt; 网页相关 申明编码 优先使用 IE 最新版本和 Chrome 12345&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; &lt;!-- 关于X-UA-Compatible --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=6\" &gt;&lt;!-- 使用IE6 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\" &gt;&lt;!-- 使用IE7 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\" &gt;&lt;!-- 使用IE8 --&gt; 浏览器内核控制：国内浏览器很多都是双内核（webkit和Trident），webkit内核高速浏览，IE内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。 禁止浏览器从本地计算机的缓存中访问页面内容：这样设定，访问者将无法脱机浏览。 -站点适配：主要用于PC-手机页的对应关系。12345&lt;meta name=\"mobile-agent\"content=\"format=[wml|xhtml|html5];url=url\"&gt; &lt;!-- [wml|xhtml|html5]根据手机页的协议语言，选择其中一种； url=\"url\" 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。 --&gt; &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"html meta","slug":"技术/html-meta","permalink":"http://yoursite.com/categories/技术/html-meta/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"meta属性","slug":"meta属性","permalink":"http://yoursite.com/tags/meta属性/"}]},{"title":"JS需要了解的一些知识","slug":"JS你需要了解的知识","date":"2018-06-24T10:19:14.314Z","updated":"2018-06-24T10:32:57.020Z","comments":true,"path":"2018/06/24/JS你需要了解的知识/","link":"","permalink":"http://yoursite.com/2018/06/24/JS你需要了解的知识/","excerpt":"","text":"1、JS非常重要的两种变成范例：JavaScript是一种多范式语言，支持与OOP（面向对象编程）和函数式编程一起的命令式/过程式编程。JavaScript支持原型继承的 OOP 。 2、函数式编程与面向对象编程有什么优缺点面向对象的优点：很容易理解对象的基本概念，并易于解释方法调用的含义。面向对象程序员倾向于使用命令式的风格，而不是声明式的风格，这种风格读起来就像是一套简单易懂的计算机指令。 OOP缺点： OOP通常取决于共享状态。对象和行为通常在同一个实体上加在一起，这可以通过任意数量的具有非确定性顺序的函数随机访问，这可能会导致不良行为，例如竞争条件。 FP优点：使用功能范例，程序员可以避免任何共享状态或副作用，从而消除由于多个功能竞争相同资源而导致的错误。由于具有诸如可用的无点式（又名默认编程）等功能，与OOP相比，功能倾向于从根本上简化并且容易为更一般的可重用代码重新组合。 FP也趋向于支持声明和指称的风格，不拼出来的操作一步一步的指示，而是专注于怎样做，让底层的功能采取的护理如何。这为重构和性能优化留下了巨大的自由度，甚至允许用很少的代码更改替换具有更高效率的整个算法。（例如，记忆或使用懒惰的评估来取代急切的评估。） 使用纯函数的计算也很容易跨多个处理器或分布式计算集群扩展，而不用担心线程资源冲突，竞争条件等等。 FP缺点：过度利用FP功能（如无点式和大型组合）可能会降低可读性，因为生成的代码通常更抽象地指定，更简洁且不太具体。 越来越多的人熟悉面向对象和命令式编程，而不是函数式编程，所以即使在函数式编程中常见的习惯用法也会让新的团队成员感到困惑。 与OOP相比，FP的学习曲线更加陡峭，因为OOP的广泛流行使得OOP的语言和学习材料变得更加对话，而FP的语言更趋于学术化和形式化。FP概念经常被写成关于使用lambda微积分，代数和类别理论中的习语和符号，所有这些都需要在这些领域中有先验知识基础来加以理解。 3、什么是双向数据绑定和单向数据流，它们有什么不同？双向数据绑定意味着UI字段会动态绑定到模型数据，以便在UI字段更改时，模型数据随之更改，反之亦然。 数据流的一种方式意味着该模型是真相的唯一来源。用户界面触发消息中的变化，将用户意图指示给模型（或React中的“存储”）。只有模型有权更改应用程序的状态。其效果是数据总是以单一方向流动，这使得它更易于理解。 数据流的一种方式是确定性的，而双向绑定会导致难以遵循和理解的副作用。 React是单向数据流的新规范示例，因此提及React是一个很好的信号。Cycle.js是另一种单向数据流的流行实现。Angular是一个使用双向绑定的流行框架。","categories":[{"name":"前段知识","slug":"前段知识","permalink":"http://yoursite.com/categories/前段知识/"},{"name":"基础知识","slug":"前段知识/基础知识","permalink":"http://yoursite.com/categories/前段知识/基础知识/"}],"tags":[{"name":"JS基础知识","slug":"JS基础知识","permalink":"http://yoursite.com/tags/JS基础知识/"}]},{"title":"JavaScript设计模式","slug":"设计模式","date":"2018-06-24T09:27:32.254Z","updated":"2018-06-24T10:16:30.266Z","comments":true,"path":"2018/06/24/设计模式/","link":"","permalink":"http://yoursite.com/2018/06/24/设计模式/","excerpt":"构造函数模式12345678910111213/** * 构造一个动物的函数 */function Animal(name, color) &#123; this.name = name; this.color = color; this.getName = function() &#123; return this.name; &#125;;&#125;// 实例一个对象var cat = new Animal('猫', '白色');console.log(cat.getName());","text":"构造函数模式12345678910111213/** * 构造一个动物的函数 */function Animal(name, color) &#123; this.name = name; this.color = color; this.getName = function() &#123; return this.name; &#125;;&#125;// 实例一个对象var cat = new Animal('猫', '白色');console.log(cat.getName()); 工厂模式工厂模式的定义：提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象）。创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。工厂就是把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合(也就是相互影响) 1234567891011121314/** * 工厂模式 */function Animal(opts) &#123; var obj = new Object(); obj.name = opts.name; obj.color = opts.color; obj.getInfo = function() &#123; return '名称：' + obj.name + '， 颜色：' + obj.color; &#125;; return obj;&#125;var cat = Animal(&#123; name: '波斯猫', color: '白色' &#125;);cat.getInfo(); 模块模式123456789101112131415161718/** * 模块模式 = 封装大部分代码，只暴露必需接口 */var Car = (function() &#123; var name = '法拉利'; function sayName() &#123; console.log(name); &#125; function getColor(name) &#123; console.log(name); &#125; return &#123; name: sayName, color: getColor, &#125;;&#125;)();Car.name();Car.color('红色'); 混合模式12345678910111213141516171819202122232425262728293031/** * 混合模式 = 原型模式 + 构造函数模式 */function Animal(name, color) &#123; this.name = name; this.color = color; console.log(this.name + this.color);&#125;Animal.prototype.getInfo = function() &#123; console.log('名称：' + this.name);&#125;;function largeCat(name, color) &#123; Animal.call(null, name, color); this.color = color;&#125;largeCat.prototype = create(Animal.prototype);function create(parentObj) &#123; function F() &#123;&#125; F.prototype = parentObj; return new F();&#125;largeCat.prototype.getColor = function() &#123; return this.color;&#125;;var cat = new largeCat('Persian', '白色');console.log(cat); 单例模式单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点。也可以说单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 12345678910111213141516171819202122232425262728/** * 在执行当前 Single 只获得唯一一个对象 */var Single = (function() &#123; var instance; function init() &#123; //define private methods and properties //do something return &#123; //define public methods and properties &#125;; &#125; return &#123; // 获取实例 getInstance: function() &#123; if (!instance) &#123; instance = init(); &#125; return instance; &#125;, &#125;;&#125;)();var obj1 = Single.getInstance();var obj2 = Single.getInstance();console.log(obj1 === obj2); 发布订阅模式定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。它需要一种高级的抽象策略，以便订阅者能够彼此独立地发生改变，而发行方能够接受任何有消费意向的订阅者。 发布订阅模式的流程如下： 确定谁是发布者(比如我的博客)。 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者。 发布消息，发布者需要遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 退订（比如不想再接收到这些订阅的信息了，就可以取消掉） 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 发布订阅模式 */var EventCenter = (function() &#123; var events = &#123;&#125;; /* &#123; my_event: [&#123;handler: function(data)&#123;xxx&#125;&#125;, &#123;handler: function(data)&#123;yyy&#125;&#125;] &#125; */ // 绑定事件 添加回调 function on(evt, handler) &#123; events[evt] = events[evt] || []; events[evt].push(&#123; handler: handler, &#125;); &#125; function fire(evt, arg) &#123; if (!events[evt]) &#123; return; &#125; for (var i = 0; i &lt; events[evt].length; i++) &#123; events[evt][i].handler(arg); &#125; &#125; function off(evt) &#123; delete events[evt]; &#125; return &#123; on: on, fire: fire, off: off, &#125;;&#125;)();var number = 1;EventCenter.on('click', function(data) &#123; console.log('click 事件' + data + number++ + '次');&#125;);EventCenter.off('click'); // 只绑定一次EventCenter.on('click', function(data) &#123; console.log('click 事件' + data + number++ + '次');&#125;);EventCenter.fire('click', '绑定');","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript设计模式","slug":"技术/JavaScript设计模式","permalink":"http://yoursite.com/categories/技术/JavaScript设计模式/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"JavaScript设计模式","slug":"JavaScript设计模式","permalink":"http://yoursite.com/tags/JavaScript设计模式/"}]},{"title":"JS作用域的理解","slug":"js作用域的理解","date":"2018-06-24T04:17:58.590Z","updated":"2018-06-24T10:17:09.803Z","comments":true,"path":"2018/06/24/js作用域的理解/","link":"","permalink":"http://yoursite.com/2018/06/24/js作用域的理解/","excerpt":"1.执行环境（execution context）执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有与之对应的变量对象（variable object），保存着该环境中定义的所有变量和函数。我们无法通过代码来访问变量对象，但是解析器在处理数据时会在后台使用到它。 执行环境有全局执行环境（也称全局环境）和函数执行环境之分。执行环境如其名是在运行和执行代码的时候才存在的，所以我们运行浏览器的时候会创建全局的执行环境，在调用函数时，会创建函数执行环境。","text":"1.执行环境（execution context）执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有与之对应的变量对象（variable object），保存着该环境中定义的所有变量和函数。我们无法通过代码来访问变量对象，但是解析器在处理数据时会在后台使用到它。 执行环境有全局执行环境（也称全局环境）和函数执行环境之分。执行环境如其名是在运行和执行代码的时候才存在的，所以我们运行浏览器的时候会创建全局的执行环境，在调用函数时，会创建函数执行环境。 1.1 全局执行环境 全局执行环境是最外围的一个执行环境，在web浏览器中，我们可以认为他是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。代码载入浏览器时，全局环境被创建，关闭网页或者关闭浏览时全局环境被销毁。 1.2 函数执行环境 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中，当函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境。 2 作用域、作用域链2.1 全局作用域（globe scope）和局部作用域（local scope） 全局作用域可以在代码中的任何地方都能被访问，例如： 1234567891 var name1=\"haha\";2 function changName()&#123;3 var name2=\"xixi\";4 console.log(name1); // haha5 console.log(name2);// xixi6 &#125; 7 changName();8 console.log(name1);//haha9 console.log(name2);//Uncaught ReferenceError: name2 is not defined 局部作用域一般只在固定的代码片段内可以访问得到，例如上述代码中的name2，只有在函数内部可以访问得到。 2.2 作用域链（scope chain）全局作用域和局部作用域中变量的访问权限，其实是由作用域链决定的。 每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。作用域链是函数被创建的作用域中对象的集合。作用域链可以保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链的最前端始终是当前执行的代码所在环境的变量对象（如果该环境是函数，则将其活动对象作为变量对象），下一个变量对象来自包含环境（包含当前还运行环境的环境），下一个变量对象来自包含环境的包含环境，依次往上，直到全局执行环境的变量对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。 标识符解析是沿着作用域一级一级的向上搜索标识符的过程。搜索过程始终是从作用域的前端逐地向后回溯，直到找到标识符（找不到，就会导致错误发生）。 例如： 12345678910111213141516171819202122var name1 = \"haha\";function changeName()&#123; var name2=\"xixi\"; function swapName()&#123; console.log(name1);//haha console.log(name2);//xixi var tempName=name2; name2=name1; name1=tempName; console.log(name1);//xixi console.log(name2);//haha console.log(tempName);//xixi &#125; swapName(); console.log(name1);//haha console.log(name2);//xixi //console.log(tempName);抛出错误：Uncaught ReferenceError: tempName is not defined&#125;changName();console.log(name1);//console.log(name2); 抛出错误：Uncaught ReferenceError: name2 is not defined//console.log(tempName);抛出错误：Uncaught ReferenceError: tempName is not defined 上述代码中，一共有三个执行环境：全局环境、changeName()的局部环境和 swapName() 的局部环境。所以， 1.函数 swapName()的作用域链包含三个对象：自己的变量对象—–&gt;changeName()局部环境的变量对象 —–&gt;全局环境的变量对象。 2.函数changeName()的作用域包含两个对象：自己的变量对象—–&gt;全局环境的变量对象。 函数的局部环境可以访问函数作用域中的变量，也可以访问和操作父环境（包含环境）乃至全局环境中的变量。 父环境只能访问其包含环境和自己环境中的变量和函数，不能访问其子环境中的变量和函数。 全局环境只能访问全局环境中的变量和函数，不能直接访问局部环境中的任何数据。 3.提升（hoisting）变量提升： 把变量放在最前面，单线程执行，不提升，可能读取不到！","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"js作用域","slug":"技术/js作用域","permalink":"http://yoursite.com/categories/技术/js作用域/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"js作用域","slug":"js作用域","permalink":"http://yoursite.com/tags/js作用域/"}]},{"title":"React-Router","slug":"React.Router","date":"2018-06-24T03:45:45.140Z","updated":"2018-06-25T14:03:41.488Z","comments":true,"path":"2018/06/24/React.Router/","link":"","permalink":"http://yoursite.com/2018/06/24/React.Router/","excerpt":"主要用来管理页面跳转 首先是安装Router：直接npm 安装即可。 1、代码的逻辑结构： 首页 详情页、主题部分共享于首页 列表页面 其他平级页面 2、控制页面的层级结构","text":"主要用来管理页面跳转 首先是安装Router：直接npm 安装即可。 1、代码的逻辑结构： 首页 详情页、主题部分共享于首页 列表页面 其他平级页面 2、控制页面的层级结构 3、单页面构建Root控制12345678910111213141516171819202122232425262728import React from 'react';import ReactDom from 'react-dom';import Index from './index';import ComponentList from './components/list';import &#123;Router,Route,hashHistory&#125; from 'react-router';export default class Root extends React.Component&#123; render()&#123; return( //这里替换了之前的Index,变成了程序的入口 &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route component=&#123;Index&#125; path=\"/\"&gt;&lt;/Route&gt; &lt;Route component=&#123;ComponentList&#125; path=\"list\"&gt;&lt;/Route&gt; &lt;/Router&gt; ); &#125;;&#125;//入口文件 ReactDOM.render(&lt;Root/&gt;, document.getElementById('example')); 在package.json里面改下配置 “main”:”root.js”在webpack.config.js 里面改下配置 entry: “./src/js/root.js” 另外root可以在不同的入口进行嵌套：比如在Index里面嵌套一个详情页可以着用写： 在Index页面里写入： {this.props.children} 4、页面间的跳转：首先导入必要的包： import {Link} from ‘react-router’ 加链接: 在Header 页 导航加入： &lt;Link to = {‘/‘}&gt;首页 &lt;Link to = {‘/details’}&gt;详情页 &lt;Link to = {‘/list’}&gt;列表页 5、Router 参数传递首先在router加入Id path=”list/:id” 然后在相对应的页面来接收： Id:{this.props.params.id}","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Router","slug":"技术/Router","permalink":"http://yoursite.com/categories/技术/Router/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"Router","slug":"Router","permalink":"http://yoursite.com/tags/Router/"}]},{"title":"React-样式","slug":"React样式","date":"2018-06-24T02:20:32.413Z","updated":"2018-06-24T03:46:25.545Z","comments":true,"path":"2018/06/24/React样式/","link":"","permalink":"http://yoursite.com/2018/06/24/React样式/","excerpt":"1、内联样式：1.1内部书写：a、首先在render里面定义变量：变量的形式： 12345678const styleComponentHeader = &#123; header: &#123; backgroundColor: '#333333', color: '#FFFFFF', 'padding-top': '15px', paddingBottom: '15px', &#125;,&#125;;","text":"1、内联样式：1.1内部书写：a、首先在render里面定义变量：变量的形式： 12345678const styleComponentHeader = &#123; header: &#123; backgroundColor: '#333333', color: '#FFFFFF', 'padding-top': '15px', paddingBottom: '15px', &#125;,&#125;; 注意上面的命名规范： 驼峰命名 paddingBottom: ‘15px’ 引号写法 ‘padding-top’: ‘15px’ 另外是属性值用引号括起来 b、然后在元素上进行引用：style={styleComponentHeader.header} 1.2 外部引用：在外部引用css文件： 在index.html里面全局应用：和正常的引用一样。 注意 class 需要更改成 className 上面两种方法的缺点： 动画、伪类 (hover) 等不能使用 1.3 内联样式的表达式首先在元素上绑定一个点击事件：onClick={this.switchHeader.bind(this)} 绑定一个函数 switchHeader 这个函数在render外面来定义： 12345678910111213//先初始化constrcutor()&#123; super(); this.state = &#123; miniHeader: false &#125;&#125;switchHeader()&#123; this.setState(&#123; miniHeader: !this.state.miniHeader; &#125;)&#125; 那我们怎么定义miniHeader的样式状态呢：可以吧他绑在我们刚才定义的样式里面 paddingBottom: (this.state.miniHeader) ? “3px” : “15px” 这里用到了三元表达式的写法 2、CSS模块化：首先安装三个模块，在配置文件先定义好，然后用npm安装即可。 这个三个模块分别是： babel-plugin-react-html-attrs 解决在react写类class不必非得用calssName style-loader css-loader 下面是配置webpack.config.js 具体配置可以看看相关的文档或者看我之前写的webpack教程。 下面是把你写的css文件导入到你制定的js文件页， 比如你写好了footer.css的样式文件，你可以把他引入到footer.js页面 引入方式： var footerCss = require(“../../css/footer.css”); 在footer.js使用它： 在你的元素上加上 这是footer页面 这里footerCSS是我们上面定义的 miniFooter是我们在footer.css里面写的。 2、jsx样式和css样式互转：css to react 在线转换","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"样式","slug":"技术/样式","permalink":"http://yoursite.com/categories/技术/样式/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"样式","slug":"样式","permalink":"http://yoursite.com/tags/样式/"}]},{"title":"React-组件的Refs","slug":"React组件的refs","date":"2018-06-23T14:20:39.474Z","updated":"2018-06-23T14:34:34.342Z","comments":true,"path":"2018/06/23/React组件的refs/","link":"","permalink":"http://yoursite.com/2018/06/23/React组件的refs/","excerpt":"","text":"操作DOM两种方法： 1、JS的原生写法： var myDiv =document.getElementById(‘myDiv’); ReactDOM.findDOMNode(myDiv).style.color =’green’; // 这里用到了ReactDOM 在头部先引入 import ReactDOM from ‘react-dom’ 2、在元素上定义ref=”submitButton” 然后直接可以调用了： this.refs.submitButton.style.color=”red”; Refs 是访问到组件内部 DOM 节点唯一可靠的方法 Refs 会自动销毁对子组件的引用 不要在 render 或 render 之前对 Refs 进行调用 //在事件内调用 或者render后面调用。 不要滥用 Refs","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"组件的Refs","slug":"技术/组件的Refs","permalink":"http://yoursite.com/categories/技术/组件的Refs/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"组件的Refs","slug":"组件的Refs","permalink":"http://yoursite.com/tags/组件的Refs/"}]},{"title":"React-可复用组件","slug":"React可复用组件","date":"2018-06-23T13:36:37.057Z","updated":"2018-06-23T14:37:23.624Z","comments":true,"path":"2018/06/23/React可复用组件/","link":"","permalink":"http://yoursite.com/2018/06/23/React可复用组件/","excerpt":"","text":"Prop 验证比如我们需要传入的是一种数字数据，我们可以用着用方法：123BodyIndex.propTypes = &#123; userid: React.PropTypes.number.isRequired&#125;; 其中我们看到用到了react里面的PropTypes 这个属性 后面跟了isRequired (这个数据类型是必须的) 默认 Prop 值const defaultProps = { text:’Hello World’ }; 使用方法：BodyIndex.defaultProps = defaultProps; 传递所有参数的快捷方式子页面代码： Component：代表的是子页面的子页面即孙页面的组件名。 {…this.props} 这个是我们从父页面传递过来的， 后面的more=”values” 就是我们新加的属性 然后在孙页面输出 {this.props.userid} {this.props.username} {this.props.id}","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"可复用组件","slug":"技术/可复用组件","permalink":"http://yoursite.com/categories/技术/可复用组件/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"可复用组件","slug":"可复用组件","permalink":"http://yoursite.com/tags/可复用组件/"}]},{"title":"git学习","slug":"Gitlearn1","date":"2018-06-23T12:41:05.514Z","updated":"2018-07-01T08:32:52.821Z","comments":true,"path":"2018/06/23/Gitlearn1/","link":"","permalink":"http://yoursite.com/2018/06/23/Gitlearn1/","excerpt":"1.初始化一个Git仓库，使用git init命令。 2.添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 3.要随时掌握工作区的状态，使用git status命令。 4.如果git status告诉你有文件被修改过，用git diff可以查看修改内容。","text":"1.初始化一个Git仓库，使用git init命令。 2.添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 3.要随时掌握工作区的状态，使用git status命令。 4.如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 5.版本回退： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hardcommit_id 或者用 –hard HEAD^ 这种形式回到上一个版本 上上个版本用 –hard HEAD^^ 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 6.工作区和暂存区 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 6.撤销修改命令 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 加入你已经add 了，但是还没有commit 你可以用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区： git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 接下来就是用git checkout – readme.txt 撤回工作区的修改了。 7.删除命令 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout – test.txtgit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程仓库首先在github 上建立我们的远程仓库，执行git init ,然后执行命令git remote add origin git@github.com:用户名/learngit.git 建立本地和远程的链接， 下面注意： 如果你的远程仓库里面含有README.md 而你本地的仓库没有这个文件，你需要执行git pull –rebase origin master 先合并， 然后再执行推送本地的内容，git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 远程仓库进行克隆：git clone git@github.com:你的用户名字/gitskills.git 再本地那个文件执行就会放在哪个文件下。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 下面看看具体是怎么做的呢首先，我们创建dev分支，然后切换到dev分支：12$ git checkout -b devSwitched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：123$ git branch dev$ git checkout devSwitched to branch &apos;dev&apos; 查看所处的分支： 123$ git branch* dev master 切换回master分支： 1$ git checkout master 合并分支： 1git merge dev git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： 1$ git branch -d dev 总结： Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突准备新的feature1分支，继续我们的新分支开发： $ git checkout -b feature1 进行修改文件 在这个分支上提交 $ git add readme.txt $ git commit -m “AND simple” 切换到master分支： $ git checkout master Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行进行修改 好了，提交： $ git add readme.txt$ git commit -m “&amp; simple” 现在，master分支和feature1分支各自都分别有新的提交， 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突， 来，执行下看看： $ git merge feature1 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： 我们可以直接查看我们修改的文件的内容： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 把冲突的内容修改好，再提交 $ git add readme.txt$ git commit -m “conflict fixed” 最后，删除feature1分支： $ git branch -d feature1 总结： 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log –graph命令可以看到分支合并图。 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下–no-ff方式的git merge： 首先，仍然创建并切换dev分支： $ git checkout -b dev 修改文件并提交 $ git add readme.txt$ git commit -m “add merge” 现在，我们切换回master： $ git checkout master 准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward： $ git merge –no-ff -m “merge with no-ff” dev 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： $ git status 看到还有没提交啊 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： $ git stashSaved working directory and index state WIP on dev: f52c633 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： $ git checkout master $ git checkout -b issue-101 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： $ git add readme.txt$ git commit -m “fix bug 101” 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： $ git checkout master$ git merge –no-ff -m “merged bug fix 101” issue-101 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！ $ git checkout dev 查看下：$ git status 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： $ git stash liststash@{0}: WIP on dev: f52c633 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： $ git stash pop 再用git stash list查看，就看不到任何stash内容了 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 问题修改完bug，master的内容已经和dev上的原始内容不一样了，在完成dev和master合并的时候，就会报有内容冲突。如果bug修改量很大，冲突的内容就会很多，如果高效的解决这种冲突？ 答：把bug分支修改后再跟dev分支合并这样master和dev分支就都搞定了 为什么要用stash？一开始，我也觉得没必要，直接切换分支，再回来是一样的啊。然后测试了一把，就知道原因了。情景如下：1、在dev分支，创建一个新文件test6.txt。并add它，让它stage。2、这时切回master分支，你会看到这个test6.txt居然也在master分支里。但它实际上是属于dev分支的。怎么办？3、git stash就有作用了。切回dev分支，执行git stach。这时git bash会告诉你“Saved working directory and index state WIP on newF2: b63fbcb add test6.txtHEAD is now at b63fbcb add test6.txt”。它已经把test6.txt的现场保存好了。4、这时你在切回master分支，test6.txt就消失了。现在懂了吧。。。。为什么要用git stash。 feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： $ git checkout -b feature-vulcan 5分钟后，开发完毕： $ git add vulcan.py$ git status$ git commit -m “add feature vulcan” 切回dev，准备合并： $ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是！ 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： $ git branch -d feature-vulcanerror: The branch ‘feature-vulcan’ is not fully merged.If you are sure you want to delete it, run ‘git branch -D feature-vulcan’. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。 现在我们强行删除： $ git branch -D feature-vulcanDeleted branch feature-vulcan (was 287773e). 小结开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： $ git remote 或者，用git remote -v显示更详细的信息： 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin master如果要推送其他分支，比如dev，就改成： $ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： $ git clone git@github.com:michaelliao/learngit.git 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： $ git branch master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： $ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： $ git add env.txt $ git commit -m “add env” $ git push origin dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch –set-upstream-to=origin/dev dev 再pull： $ git pull 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： $ git commit -m “fix env conflict” $ git push origin dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to origin/。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 标签管理在Git中打标签非常简单，首先，切换到需要打标签的分支上： $ git branch devmaster$ git checkout masterSwitched to branch ‘master’ 然后，敲命令git tag 就可以打一个新标签： $ git tag v1.0 可以用命令git tag查看所有标签： $ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了：$ git log –pretty=oneline –abbrev-commit 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： $ git tag v0.9 f52c633 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show 查看标签信息： $ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)Author: Michael Liao &#97;&#x73;&#x6b;&#x78;&#117;&#101;&#x66;&#101;&#x6e;&#x67;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;Date: Fri May 18 21:56:54 2018 +0800 add merge diff –git a/readme.txt b/readme.txt… 小结 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m “blablabla…”可以指定标签信息； 命令git tag可以查看所有标签。 操作标签如果标签打错了，也可以删除： $ git tag -d v0.1Deleted tag ‘v0.1’ (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin ： 或者，一次性推送全部尚未推送到远程的本地标签： $ git push origin –tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v0.9Deleted tag ‘v0.9’ (was f52c633)然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git [deleted] v0.9 小结 命令git push origin 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 问答：最好加上有标签了，怎么根据标签回溯版本的内容，否则只是加标签没意义呀！ 先用 git show v1.0 就能知道tag标记的这次commit的节点的id 号码；如果是 590cf6b63d1039a17869defb6b70e4fa977c073a那么就用git checkout 590cf6b（数字长度六七位就可以）就能返回这个版本。在版本之间切换的内容。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Git学习","slug":"技术/Git学习","permalink":"http://yoursite.com/categories/技术/Git学习/"}],"tags":[{"name":"Git学习","slug":"Git学习","permalink":"http://yoursite.com/tags/Git学习/"}]},{"title":"JavaScript-高级函数","slug":"高阶函数","date":"2018-06-23T09:31:50.208Z","updated":"2018-06-12T13:15:03.173Z","comments":true,"path":"2018/06/23/高阶函数/","link":"","permalink":"http://yoursite.com/2018/06/23/高阶函数/","excerpt":"一、什么是JavaScript的高级函数通俗一点讲就是：函数作为参数的行为 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 123function add(x, y, f) &#123; return f(x) + f(y);&#125; 当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为： x = -5;y = 6;f = Math.abs;f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;return 11;","text":"一、什么是JavaScript的高级函数通俗一点讲就是：函数作为参数的行为 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 123function add(x, y, f) &#123; return f(x) + f(y);&#125; 当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为： x = -5;y = 6;f = Math.abs;f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;return 11; map举例说明，比如我们有一个函数$$ f(x)=x^2 $$要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下： 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果： 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results); map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串： 12var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)比方说对一个Array求和，就可以用reduce实现：1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25 filter filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] 把一个Array中的空字符串删掉，可以这么写： 12345var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);r; // ['A', 'B', 'C'] 可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。 注：trim()方法返回调用字符串对象的一个副本,但是所有起始和结尾的空格都被删除了 利用filter，可以巧妙地去除Array的重复元素： 123456789'use strict';var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;);console.log(r.toString()); // 把数组转化为字符串； sort:排序算法: 排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。 JavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊： 看上去正常的结果:1[&apos;Google&apos;, &apos;Apple&apos;, &apos;Microsoft&apos;].sort(); // [&apos;Apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;]; apple排在了最后:1[&apos;Google&apos;, &apos;apple&apos;, &apos;Microsoft&apos;].sort(); // [&apos;Google&apos;, &apos;Microsoft&quot;, &apos;apple&apos;] 无法理解的结果:1[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。 第三个排序结果是什么鬼？简单的数字排序都能错？ 这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果’10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小。 幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 要按数字大小排序，我们可以这么写： 12345678910111213'use strict';var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20] 如果要倒序排序，我们可以把大的数放前面： 12345678910var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return 1; &#125; if (x &gt; y) &#123; return -1; &#125; return 0;&#125;); // [20, 10, 2, 1] 默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：123456789101112var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) &#123; x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) &#123; return -1; &#125; if (x1 &gt; x2) &#123; return 1; &#125; return 0;&#125;); // ['apple', 'Google', 'Microsoft'] &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"高级函数","slug":"技术/JavaScript/高级函数","permalink":"http://yoursite.com/categories/技术/JavaScript/高级函数/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}]},{"title":"闭包","slug":"闭包","date":"2018-06-23T09:31:50.193Z","updated":"2018-06-19T02:54:00.058Z","comments":true,"path":"2018/06/23/闭包/","link":"","permalink":"http://yoursite.com/2018/06/23/闭包/","excerpt":"核心理解就两点： 1、函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 2、把私有变量封装起来，类似于java里面class的私有变量。由于JavaScript里面没有私有变量定义，所以采用闭包来封装起来。","text":"核心理解就两点： 1、函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 2、把私有变量封装起来，类似于java里面class的私有变量。由于JavaScript里面没有私有变量定义，所以采用闭包来封装起来。 我们来实现一个对Array的求和。通常情况下，求和的函数是这样定义的：1234567function sum(arr) &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;);&#125;sum([1, 2, 3, 4, 5]); // 15 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！12345678function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125; 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数： var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()调用函数f时，才真正计算求和的结果： f(); // 15 在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。 请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数： var f1 = lazy_sum([1, 2, 3, 4, 5]);var f2 = lazy_sum([1, 2, 3, 4, 5]);f1 === f2; // falsef1()和f2()的调用结果互不影响。 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 1234567891011121314151617181920function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123(function (x) &#123; return x * x;&#125;)(3); // 9 理论上讲，创建一个匿名函数并立刻执行可以这么写： function (x) { return x * x } (3); 但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来： (function (x) { return x * x }) (3); 通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写： (function (x) { return x * x;})(3); 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。 我们用JavaScript创建一个计数器： 1234567891011'use strict';function create_counter(initial) &#123; var x = initial || 0; return &#123; inc: function () &#123; x += 1; return x; &#125; &#125;&#125; 它用起来像这样： 123456789var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13 在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 闭包还可以把多参数的函数变成单参数的函数。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"闭包","slug":"技术/闭包","permalink":"http://yoursite.com/categories/技术/闭包/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2018-06-23T09:31:50.181Z","updated":"2018-06-20T00:06:57.950Z","comments":true,"path":"2018/06/23/箭头函数/","link":"","permalink":"http://yoursite.com/2018/06/23/箭头函数/","excerpt":"x =&gt; x * x 上面的箭头函数相当于： 123function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125;","text":"x =&gt; x * x 上面的箭头函数相当于： 123function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 如果参数不是一个，就需要用括号()括起来：(x, y) =&gt; x x + y y 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： 因为和函数体的{ … }有语法冲突，所以要改为： x =&gt; ({ foo: x }) 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域 12345678910var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window或undefined &#125;; return fn(); &#125;&#125;; 现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：123456789var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25 如果使用箭头函数，以前的那种hack写法： var that = this;就不再需要了。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"箭头函数","slug":"技术/箭头函数","permalink":"http://yoursite.com/categories/技术/箭头函数/"}],"tags":[{"name":"箭头函数","slug":"箭头函数","permalink":"http://yoursite.com/tags/箭头函数/"}]},{"title":"深入理解JS函数","slug":"深入理解JS函数","date":"2018-06-23T09:31:50.174Z","updated":"2018-06-22T09:39:55.582Z","comments":true,"path":"2018/06/23/深入理解JS函数/","link":"","permalink":"http://yoursite.com/2018/06/23/深入理解JS函数/","excerpt":"一、函数的三种角色 首先要先了解在函数本身会有一些自己的属性，比如： length：形参的个数； name：函数名； prototype：类的原型，在原型上定义的方法都是当前这个类的实例的公有方法； __proto__：把函数当做一个普通对象，指向Function这个类的原型","text":"一、函数的三种角色 首先要先了解在函数本身会有一些自己的属性，比如： length：形参的个数； name：函数名； prototype：类的原型，在原型上定义的方法都是当前这个类的实例的公有方法； __proto__：把函数当做一个普通对象，指向Function这个类的原型 函数在整个JavaScript中是最复杂也是最重要的知识，对于一个函数来说，会存在多种角色： 1234567891011121314function Fn() &#123; var num = 500; this.x = 100;&#125;Fn.prototype.getX = function () &#123; console.log(this.x);&#125;Fn.aaa = 1000;var f = new Fn;f.num // undefinedf.aaa // undefinedvar res = Fn(); // res是undefined Fn中的this是window 角色一：普通函数，对于Fn而言，它本身是一个普通的函数，执行的时候会形成私有的作用域，然后进行形参赋值、预解析、代码执行、执行完成后内存销毁； 角色二：类，它有自己的实例，f就是Fn作为类而产生的一个实例，也有一个叫做prototype的属性是自己的原型，它的实例都可以指向自己的原型； 角色三：普通对象，Fn和 var obj = {} 中的obj一样，就是一个普通的对象（所有的函数都是Function的实例），它作为对象可以有一些自己的私有属性，也可以通过proto找到Function.prototype； 二、call深入12var ary = [12, 23, 34];ary.slice(); 以上两行简单的代码的执行过程为：ary这个实例通过原型链的查找机制找到Array.prototype上的slice方法，让找到的slice方法执行，在执行slice方法的过程中才把ary数组进行了截取。 slice方法执行之前有一个在原型上查找的过程（当前实例中没有找到，再根据原型链查找）。 当知道了一个对象调用方法会有一个查找过程之后，我们再看： 12345678var obj = &#123;name:'iceman'&#125;;function fn() &#123; console.log(this); console.log(this.name);&#125;fn(); // this --&gt; window// obj.fn(); // Uncaught TypeError: obj.fn is not a functionfn.call(obj); call方法的作用：首先寻找call方法，最后通过原型链在Function的原型中找到call方法，然后让call方法执行，在执行call方法的时候，让fn方法中的this变为第一个参数值obj，最后再把fn这个函数执行。 2.2、call方法原理123456 function fn1() &#123; console.log(1);&#125;function fn2() &#123; console.log(2);&#125; 输出 fn1.call(fn2); // 1 首先fn1通过原型链查找机制找到Function.prototype上的call方法，并且让call方法执行，此时call这个方法中的this就是要操作的fn1。在call方法代码执行的过程过程中，首先让fn1中的“this关键字”变为fn2，然后再让fn1这个方法执行。 注意：在执行call方法的时候，fn1中的this的确会变为fn2，但是在fn1的方法体中输出的内容中并没有涉及到任何和this相关的内容，所以还是输出1。 apply方法、bind方法和call方法apply方法和call方法的作用是一模一样的，都是用来改变方法的this关键字，并且把方法执行，而且在严格模式下和非严格模式下，对于第一个参数是null/undefined这种情况规律也是一样的，只是传递函数的的参数的时候有区别。123456function fn(num1, num2) &#123; console.log(num1 + num2); console.log(this);&#125;fn.call(obj , 100 , 200);fn.apply(obj , [100, 200]); bind方法和apply、call稍有不同，bind方法是事先把fn的this改变为我们要想要的结果，并且把对应的参数值准备好，以后要用到了，直接的执行即可，也就是说bind同样可以改变this的指向，但和apply、call不同就是不会马上的执行。 12var tempFn = fn.bind(obj, 1, 2);tempFn(); 第一行代码只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，但是此时并没有把fn这个函数给执行，执行bind会有一个返回值，这个返回值tempFn就是把fn的this改变后的那个结果。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"深入理解JS函数","slug":"技术/深入理解JS函数","permalink":"http://yoursite.com/categories/技术/深入理解JS函数/"}],"tags":[{"name":"深入理解JS函数","slug":"深入理解JS函数","permalink":"http://yoursite.com/tags/深入理解JS函数/"}]},{"title":"JS方法","slug":"方法","date":"2018-06-23T09:31:50.164Z","updated":"2018-06-15T01:33:42.488Z","comments":true,"path":"2018/06/23/方法/","link":"","permalink":"http://yoursite.com/2018/06/23/方法/","excerpt":"在一个对象中绑定函数，称为这个对象的方法。 在JavaScript中，对象的定义是这样的： 1234var xiaoming = &#123; name: '小明', birth: 1990&#125;;","text":"在一个对象中绑定函数，称为这个对象的方法。 在JavaScript中，对象的定义是这样的： 1234var xiaoming = &#123; name: '小明', birth: 1990&#125;; 但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄： 1234567891011var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？ 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 12345678910111213141516'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"方法","slug":"技术/JavaScript/方法","permalink":"http://yoursite.com/categories/技术/JavaScript/方法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"方法","slug":"方法","permalink":"http://yoursite.com/tags/方法/"}]},{"title":"谷歌浏览器开发工具综述","slug":"开发者工具","date":"2018-06-23T09:31:50.157Z","updated":"2018-06-14T14:17:40.549Z","comments":true,"path":"2018/06/23/开发者工具/","link":"","permalink":"http://yoursite.com/2018/06/23/开发者工具/","excerpt":"总体而言，有八个主要的工具可供查看开发工具： 元素 资源 网络 源 时间表 简介 审核 控制台","text":"总体而言，有八个主要的工具可供查看开发工具： 元素 资源 网络 源 时间表 简介 审核 控制台 你可以使用 Ctrl + [ 和 Ctrl + ] 快捷键在面板之间移动。 查阅 DOM 和格式1、实时编辑 DOM 节点 要实时编辑 DOM 节点，只需双击选定元素，然后进行更改： 2、实时编辑样式 在 Styles 窗格中实时编辑样式属性名称和值。所有样式均可修改，除了灰色部分（与 User Agent 样式表一样）。 要编辑名称或值，请点击它，进行更改，然后按 Tab 或 Enter 保存更改。 3、检查和编辑框模型参数 利用控制台进行工作JavaScript 控制台为开发者提供了测试 Web 页面和应用程序两个主要功能,其中包括： 在开发过程中记录诊断信息。 一个可与文档和工具交互的 shell 提示符。 您可以使用控制台编程接口提供的方法来记录诊断信息。如 console.log() 或 console.profile()。 您可以直接在控制台中评估表达式，并使用命令行提供的方法。这些包括使用 $() 命令选择元素或通过 profile() 方法启动 CPU 分析器命令。 JavaScript 的调试1、断点调试代码行断点在 DevTools 中设置一行代码断点： 点击 Sources 选项卡。 打开包含您想要打破的代码行的文件。 去代码的行。 行号的左边是行号列。点击它。一个蓝色图标显示在行号列的顶部。 条件行代码断点当您知道需要调查的确切代码区域时，请使用有条件的代码行断点，但只有在其他条件成立时才想暂停。 要设置条件的代码行断点： 点击 Sources 选项卡。 打开包含您想要打破的代码行的文件。 去代码的行。 行号的左边是行号列。用鼠标右键单击它。 选择添加条件断点。代码行下面会显示一个对话框。 在对话框中输入你的条件。 按 Enter 激活断点。行号列上出现橙色图标。 DOM 更改断点当您想要更改 DOM 节点或其子节点的代码时，使用 DOM 更改断点。 要设置 DOM 更改断点： 点击元素标签。 转到您想设置断点的元素。 右键单击该元素。 将鼠标悬停在 Break 上，然后选择 Subtree 修改，属性修改或节点删除。 事件监听器断点当想要暂停事件侦听器代码时，使用事件侦听器断点。您可以选择特定的事件，例如事件 click 类别，例如所有的鼠标事件。 点击 Sources 选项卡。 展开“ 事件侦听器断点”窗格。DevTools 显示事件类别的列表，例如动画。 选中这些类别中的一个可以暂停该类别的任何事件，或者展开类别并检查特定事件。 异常断点当您想暂停引发捕获或未捕获异常的代码行时，使用异常断点。 点击 Sources 选项卡。 点击暂停例外 暂停例外。启用后变成蓝色。 （可选）如果除了未捕获的异常外，还想暂停捕获的异常，请选中“ 捕获异常时暂停”复选框。 测量资源加载时间使用 Network 面板测量您的网站网络性能。 Network 面板记录页面上每个网络操作的相关信息，包括详细的耗时数据、HTTP 请求与响应标头和 Cookie，等等。 待更新","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"开发者工具","slug":"技术/开发者工具","permalink":"http://yoursite.com/categories/技术/开发者工具/"}],"tags":[{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"}]},{"title":"如何优化你的网站","slug":"如何优化你的网站","date":"2018-06-23T09:31:50.131Z","updated":"2018-06-14T14:15:14.145Z","comments":true,"path":"2018/06/23/如何优化你的网站/","link":"","permalink":"http://yoursite.com/2018/06/23/如何优化你的网站/","excerpt":"1、利用浏览器缓存你的 js 和 CSS 文件： 在网站根目录 .htaccess 中加入以下代码 123 ExpiresActive on ExpiresDefault “access plus 1 year” 这段代码的意思是对 jpg|gif|png|css|js 发送 header 缓存头，进行一年的缓存、在浏览器不使用 ctrl+F5 强制刷新时，会一直缓存到时间时间结束，唯一遗憾的是如果你更改了js或者css文件必须把以前的路径或者文件名更改，可以这样 base.js?ver=(x) 这种方式下次浏览器就会自动读取并缓存。","text":"1、利用浏览器缓存你的 js 和 CSS 文件： 在网站根目录 .htaccess 中加入以下代码 123 ExpiresActive on ExpiresDefault “access plus 1 year” 这段代码的意思是对 jpg|gif|png|css|js 发送 header 缓存头，进行一年的缓存、在浏览器不使用 ctrl+F5 强制刷新时，会一直缓存到时间时间结束，唯一遗憾的是如果你更改了js或者css文件必须把以前的路径或者文件名更改，可以这样 base.js?ver=(x) 这种方式下次浏览器就会自动读取并缓存。 2、把你的 .js 库文件地址替换成 Google CDN的地址： 随着 jquery 和 mootools 等js库的使用需要加载的.js文件越来越多也越来越大，通常传统的网站是上传到网站本身的目录。但对于一个接近70多KB的jquery.js体积确实不利于网站响应速度的提升，此时就应该使用Google API 。 例如：把你的 http://www.***.cn/jquery.x.x.js 替换为 http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js，其意义在于当一个用户访问过使用 google api 的网站之后，再次访问其他调用了该api地址的网站就不需要再次加载该文件了。从而达到提速的目的。 不单是jquery库，其他诸如mootools yui 也可以使用这种方式。 3、精简和优化你的 js 和 CSS： 虽然有了缓存和gzip保驾护航，但是对于 js 和 css 的优化却也是必须的。我们写的javascript脚本和 css 代码都是经过缩进和换行的，适合人类阅读，但是浏览器执行这些脚本不并需要这些无意义的空格和换行。所以我们应该去除这一些空格换行，甚至缩短 javascript 和 css 里面的变量。诸如此类的优化工具有 YUI Compressor 和 Closure Compiler 。这两个工具都是基于 java 的，使用应该安装jdk并且设置 JAVA_HOME 。(对于非程序员的网站管理员而言确实有点困难) 此工具可以不用在本地安装jdk，直接上传 js 和 css 文件进行压缩，可选择是采用 YUI Compressor 或 Closure Compiler 。 4、GZIP 压缩你的 JS 和 CSS 文件： 压缩js和css可以通过服务器动态脚本进行也可以更简单的使用apache服务器可以在网站根目录 .htaccess 中加入以下代码 AddOutputFilterByType DEFLATE text/html text/css text/plain text/xml application/x-javascript application/json Header append Vary Accept-Encoding 这段代码的意思是调用服务器的压缩模块对以上文件输出之前进行GZIP压缩，gzip的压缩之后所有文件都应该能减少30%以上的体积。特别是对于大量使用js的博客有了gzip保驾护航之后速度能提高不少。 5、使用css sprites合并图片 一个网站经常使用小图标和小图片进行美化，但是很遗憾这些小图片占用了大量的HTTP请求，因此可以采用sprites的方式把所有的图片合并成一张图片 ，可以通过相关工具在线合并，也可以在ps中合并。 6、优化你网站图片： 大量使用的图片和图标虽然可以给网站带来美轮美奂的效果，图文混编更是一种非常绚丽的博文展现方法。可图片的体积确实不是很给力，jpg是一种有损压缩格式，而png虽然是无损的，但缺憾是体积颇大。为了减少图片体积达到最快的下载速度，每一张图片上传前应该优化一下体积。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网站优化","slug":"技术/网站优化","permalink":"http://yoursite.com/categories/技术/网站优化/"}],"tags":[{"name":"网站优化","slug":"网站优化","permalink":"http://yoursite.com/tags/网站优化/"}]},{"title":"网页响应式开发3","slug":"响应式开发3","date":"2018-06-23T09:31:50.119Z","updated":"2018-06-13T11:24:51.049Z","comments":true,"path":"2018/06/23/响应式开发3/","link":"","permalink":"http://yoursite.com/2018/06/23/响应式开发3/","excerpt":"1、不使用绝对宽度由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。 具体说，CSS代码不能指定像素宽度： 1width: xx%; 或者1width:auto;","text":"1、不使用绝对宽度由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。 具体说，CSS代码不能指定像素宽度： 1width: xx%; 或者1width:auto; 2、相对大小的字体3、设置 box-sizing: border-box字体也不能使用绝对大小（px），而只能使用相对大小（em）。123body &#123; font: normal 100% Helvetica, Arial, sans-serif; &#125; 123h1 &#123; font-size: 1.5em; &#125; 4、流动布局（fluid grid）“流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。 12345678910.main &#123; float: right; width: 70%; &#125; .leftBar &#123; float: left; width: 25%; &#125; float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。 另外，绝对定位（position: absolute）的使用，也要非常小心。 5、选择加载CSS“自适应网页设计”的核心，就是CSS3引入的Media Query模块。 它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 123&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-device-width: 400px)\" href=\"tinyScreen.css\" /&gt; 上面的代码意思是，如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。 6、CSS的@media规则同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 123456789101112@media screen and (max-device-width: 400px) &#123; .column &#123; float: none; width:auto; &#125; #sidebar &#123; display:none; &#125; &#125; 上面的代码意思是，如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）。 7、图片的自适应（fluid image）除了布局和文本，”自适应网页设计”还必须实现图片的自动缩放。 这只要一行CSS代码： 1img &#123; max-width: 100%;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"http://yoursite.com/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"http://yoursite.com/tags/响应式开发/"}]},{"title":"网页响应式开发2","slug":"响应式开发2","date":"2018-06-23T09:31:50.103Z","updated":"2018-06-13T11:25:15.986Z","comments":true,"path":"2018/06/23/响应式开发2/","link":"","permalink":"http://yoursite.com/2018/06/23/响应式开发2/","excerpt":"遵循的一些准则和基础1、在 Viewport 里加 Meta 标签在你 HTML 的&lt;head&gt; 代码里添加 Meta 标签。它可以使 media queries 在不同设备上起作用 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;","text":"遵循的一些准则和基础1、在 Viewport 里加 Meta 标签在你 HTML 的&lt;head&gt; 代码里添加 Meta 标签。它可以使 media queries 在不同设备上起作用 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 2、理解CSS盒模型 3、设置 box-sizing: border-box在 CSS 文件最顶端设置 box-sizing。运用 * 通用选择器使其应用到页面的每个元素上。12345*, *:before, *:after &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;&#125; 4、创建容器一个容器将包含页面所有标签，并控制页面最大宽度. 运用容器，让我们的响应式设计更进了一步！ 5、创建列在移动优先里，列默认均是 block 级别的（可以占满整行的宽度）。不需要额外的样式！ 12345&lt;div class=\"container\"&gt; &lt;div class=\"column\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt;&lt;/div&gt; 6、创建列宽在大屏中，用 float: left 将列水平排列。然后运用 padding 设置相邻两列之间的间隙，忘掉传统的margin吧。 7、创建行列应该包裹在行内，以避免其他元素堆放在其旁边造成布局混乱。否则就会出现广为人知的 clearing 问题。出现之后可以使用由 Nicolas Gallagher 发明的 clearfix 解决。 12345678910111213141516171819&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213.clearfix:before,.clearfix:after &#123; content: \" \"; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 8、相对流（ Flow Opposite ）给你想让它在移动端优先显示，而在大屏幕中右侧显示的列，添加 .flow-opposite 类。 12345678910&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"column half flow-opposite\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;div class=\"column half\"&gt; &lt;!-- Your Content --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123@media (min-width: 40rem) &#123; .column.flow-opposite &#123; float: right; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"http://yoursite.com/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"http://yoursite.com/tags/响应式开发/"}]},{"title":"网页响应式开发","slug":"响应式开发","date":"2018-06-23T09:31:50.079Z","updated":"2018-06-14T01:07:01.689Z","comments":true,"path":"2018/06/23/响应式开发/","link":"","permalink":"http://yoursite.com/2018/06/23/响应式开发/","excerpt":"一、原理定义最小宽度： // Extra small devices (portrait phones, less than 576px)// No media query since this is the default in Bootstrap // Small devices (landscape phones, 576px and up)@media (min-width: 576px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … }","text":"一、原理定义最小宽度： // Extra small devices (portrait phones, less than 576px)// No media query since this is the default in Bootstrap // Small devices (landscape phones, 576px and up)@media (min-width: 576px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … } 定义最大宽度：// Extra small devices (portrait phones, less than 576px)@media (max-width: 575.98px) { … } // Small devices (landscape phones, less than 768px)@media (max-width: 767.98px) { … } // Medium devices (tablets, less than 992px)@media (max-width: 991.98px) { … } // Large devices (desktops, less than 1200px)@media (max-width: 1199.98px) { … } // Extra large devices (large desktops)// No media query since the extra-large breakpoint has no upper bound on its width 使用逻辑混用：// Extra small devices (portrait phones, less than 576px)@media (max-width: 575.98px) { … } // Small devices (landscape phones, 576px and up)@media (min-width: 576px) and (max-width: 767.98px) { … } // Medium devices (tablets, 768px and up)@media (min-width: 768px) and (max-width: 991.98px) { … } // Large devices (desktops, 992px and up)@media (min-width: 992px) and (max-width: 1199.98px) { … } // Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) { … } 提取模板：(用的 bootstrap)12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css\" integrity=\"sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Hello, world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;div class=\"col-sm\"&gt; One of three columns &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.2.1.slim.min.js\" integrity=\"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js\" integrity=\"sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js\" integrity=\"sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 响应式框架介绍1、bootstrap如何安装？ 建议使用npm来安装：命令如下：12npm install bootstrap 也可以用CDN安装： CSS only 1&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\" integrity=\"sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB\" crossorigin=\"anonymous\"&gt; JS, Popper.js, and jQuery 123&lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js\" integrity=\"sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; 2、Foundation模板快速开发具体的模板，可以看bootstrap,不做详细介绍了。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"网页响应式开发","slug":"技术/网页响应式开发","permalink":"http://yoursite.com/categories/技术/网页响应式开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"http://yoursite.com/tags/响应式开发/"}]},{"title":"CSS 网格布局知识2","slug":"前端基础知识整理4","date":"2018-06-23T09:31:50.034Z","updated":"2018-06-11T12:57:59.131Z","comments":true,"path":"2018/06/23/前端基础知识整理4/","link":"","permalink":"http://yoursite.com/2018/06/23/前端基础知识整理4/","excerpt":"定义一个网格：Grid(网格) 模块为 display 属性提供了一个新的值：grid。当你将任何元素的 display 属性设置为 grid 时，那么这个元素就是一个 网格容器(grid container)，它的所有直接子元素就成了 网格项(grid items)。 让我们创建创建一个 3×3 的布局，做一个 Tic-Tac-Toe (井字游戏) 棋盘。 首先，我们将写一些 HTML： 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;","text":"定义一个网格：Grid(网格) 模块为 display 属性提供了一个新的值：grid。当你将任何元素的 display 属性设置为 grid 时，那么这个元素就是一个 网格容器(grid container)，它的所有直接子元素就成了 网格项(grid items)。 让我们创建创建一个 3×3 的布局，做一个 Tic-Tac-Toe (井字游戏) 棋盘。 首先，我们将写一些 HTML： 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt; .game-board div 是网格容器，而 .box div 是网格项。现在我们将通过 Grid 布局来实现 3×3 布局。 123456.game-board &#123; display: grid; grid-template-rows: 200px 200px 200px; grid-template-columns: 200px 200px 200px; &#125; grid-template-rows 属性允许我们指定网格中的行数及行的高度。那么你应该猜到另一个属性是干什么的了。 grid-template-columns 属性允许我们指定网格中的列数及列的宽度。 fr 单位(等分)fr 是为网格布局定义的一个新单位。它可以帮助你摆脱计算百分比，并将可用空间等分。 例如，如果在网格容器中设置这个规则：grid-template-rows: 2fr 3fr，那么你的网格容器将首先被分成 2 行。然后将数字部分加在一起，这里总和为 5， 即 5 等分。 就是说，我们将有 2 行：第一排占据垂直空间的 2/5 。 第二排占垂直空间的 3/5 。 回到我们的 Tic-Tac-Toe 例子，我们使用 fr 代替 px。我们想要的是，应该有3行3列。所以，我们只需要用 3 个 1fr 替换 3 个 200px 即可： 123456.game-board &#123; display: grid; grid-template-rows: 1fr 1fr 1fr; grid-template-columns: 1fr 1fr 1fr; &#125; 这里特别需要注意的是： fr 单位是等分可用空间，或者说剩余空间。看个例子: 123456789.game-board &#123; grid-gap:2px; display: grid; width:300px; height:200px; grid-template-rows: 100px 1fr 1fr; grid-template-columns: 1fr 50px 1fr; &#125; 你会看到 fr 单位是将 总的尺寸 减去 单元格明确尺寸后，在等分剩余空间。 grid-gap 是间隔。 repeat() 函数在某些情况下，我们可能有很多的列和行。在 grid-template 属性中指定每一个值可能会很乏味。幸运的是，有一个 repeat 函数，就像任何一个循环重复多少次输出某个给定值。它有两个参数。第一个是迭代次数，第二个是要重复的值。我们用 repeat 函数重写上面的例子。 123456.game-board &#123; display: grid; grid-template-rows: repeat(3, 1fr); grid-template-columns: repeat(3, 1fr); &#125; grid-template 属性grid-template 属性是 grid-template-rows 和 grid-template-columns 的简写语法。 这是它的语法： grid-template: ro ws / co lu mns; 我们上面的例子使用这个简写语法后，看起来非常整齐。 12345.game-board &#123; display: grid; grid-template: repeat(3, 1fr) / repeat(3, 1fr); &#125; 下面是具体创建的例子了：HTML 1234567891011&lt;div class=\"game-board\"&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;O&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt; &lt;div class=\"box\"&gt;X&lt;/div&gt;&lt;/div&gt; CSS 12345678910111213141516171819202122232425.game-board&#123; width: 600px; height: 600px; margin: 0 auto; background-color: #34495e; color: #fff; border: 6px solid #2c3e50; border-radius: 10px; display: grid; grid-template: repeat(3, 1fr) / repeat(3, 1fr);&#125;.box&#123; border: 6px solid #2c3e50; border-radius: 2px; font-family: Helvetica; font-weight: bold; font-size: 4em; display: flex; justify-content: center; align-items: center;&#125; 网格线编号,网格单元格，网格轨道网格线是存在于列和行每一侧的线。一组垂直线将空间垂直划分成列，而另一组水平线将空间水平划分成行。这意味着在我们之前的例子中，有四条垂直线和四条水平线包含它们之间的行和列。 在将网格项从一个位置跨越到另一个位置时，网格线变得非常有用。 网格轨道是两条线之间的空间。 网格轨道可以是一行或一列。 网格单元格很像表格单元，是两条相邻垂直线和两条相邻水平线之间的空间。 这是网格中最小的单位。 定位网格项采取了前面的例子的网格，并用数字从1到9标记每个单元格，而不是X或O，下面是它的样子： 假设我想将第 6 个框移到第 2 个框的位置。 我们使用网格模块，改变网格中网格项的位置是一件轻而易举的事情。 要将第6个框移到第2个框的位置，我们必须确切知道第2个框在哪里。通过网格线编号的帮助，我们可以很容易地找到这个位置。第二个方框位于第2条列网格线之后，第3条列网格线之前，第1条行网格线之下，第2条行网格线之上。现在我们可以使用以下属性将这些网格线编号分配到第6个框中： grid-column-start grid-column-end grid-row-start grid-row-end 前两个属性对应于垂直网格线，也就是列网格线的开始和结束。 最后两个属性是指水平网格线，也就是行网格线的开始和结束。 让我们分配正确的网格线编号来移动第 6 个框。 1234567.box:nth-child(6) &#123; grid-row-start: 1; grid-row-end: 2; grid-column-start: 2; grid-column-end: 3; &#125; 还有两个简写属性用于将行和列的开始网格线和结束网格线设置在一起。 12345.box:nth-child(6) &#123; grid-row: 1 / 2; grid-column: 2 / 3; &#125; 此外，还有一个grid-area属性是所有四个上述属性的简写属性。 它按以下顺序取值： grid-area: / / / ; 现在我们的例子可以写成这样: 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / 3; &#125; 如果我们想要第6个框跨越两个框的区域呢？ 这很容易通过将 column-end 值加 1 的办法来完成。 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / 4; &#125; 您也可以使用 span 关键字和占据的 轨道数量，来代替指定 grid-row-end 和 grid-column-end 的结束网格线编号。 在这种情况下，第6个框是跨越 2 列和 1 行。 1234.box:nth-child(6) &#123; grid-area: 1 / 2 / 2 / span 2; &#125; 网格区域命名grid-area 属性也可以用来命名网格的某一个部分，然后我们可以用 grid-template-areas 属性来定位。让我们创建一个简单的 bread-and-butter 布局，顶部有一个 top, nav，中间有 main 和 aside，下面是 footer。这是所需的HTML： 1234567&lt;div class=\"container\"&gt; &lt;header&gt;&lt;/header&gt; &lt;nav&gt;&lt;/nav&gt; &lt;main&gt;&lt;/main&gt; &lt;aside&gt;&lt;/aside&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/div&gt; 我们需要使用 grid-area 属性来命名每个区域： 1234567891011121314151617181920212223242526272829header &#123; grid-area: header; background-color: #9b59b6; &#125; nav &#123; grid-area: nav; background-color: #3498db; &#125; main &#123; grid-area: main; background-color: #2ecc71; &#125; aside &#123; grid-area: aside; background-color: #f1c40f; &#125; footer &#123; grid-area: footer; background-color: #1abc9c; &#125; 现在我们将使用 grid-template-areas 属性来指定每个网格区域所占据的行和列。 以下是我们如何做到的： 1234567891011.container &#123; display: grid; grid-template-rows: 1fr 5fr 1fr; grid-template-columns: 2fr 5fr 3fr; grid-template-areas: \"header header header\" \"nav main aside\" \"footer footer footer\"; grid-gap: .75em; &#125; 请注意，header 和 footer 单词重复三次。 这表明，header 和 footer 横跨 3 列的宽度。 你可以把它全部写在一行中，但是把每一行写在一个单独的行上很好，很干净。 你可以看到我在这里使用了一个新的属性 grid-gap。 它所做的只是在两个网格区域之间添加一个间距。 你也可以使用 grid-row-gap 和 grid-column-gap 来为行和列指定不同的间距值。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"网格布局","slug":"技术/前端基础知识/网格布局","permalink":"http://yoursite.com/categories/技术/前端基础知识/网格布局/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"网格布局","slug":"网格布局","permalink":"http://yoursite.com/tags/网格布局/"}]},{"title":"CSS 网格布局知识1","slug":"前端基础知识整理3","date":"2018-06-23T09:31:50.016Z","updated":"2018-06-11T12:33:13.612Z","comments":true,"path":"2018/06/23/前端基础知识整理3/","link":"","permalink":"http://yoursite.com/2018/06/23/前端基础知识整理3/","excerpt":"2.1 网格布局知识 CSS Grid(网格) 布局使我们能够比以往任何时候都可以更灵活构建和控制自定义网格。 Grid(网格) 布局使我们能够将网页分成具有简单属性的行和列。它还能使我们在不改变任何HTML的情况下，使用 CSS 来定位和调整网格内的每个元素。它允许 HTML 纯粹作为内容的容器。HTML 结构不再受限于样式表现，比如不要为了实现某种布局而多次嵌套，现在这些都可以让 CSS 来完成。 浏览器兼容性 对于大多数布局，我们会使用下面的query特性来让老的浏览器对他们理解的特性也能工作： 12345@supports (display: grid) &#123; .grid &#123; display: grid; &#125;&#125; 不支持浏览器@supports或网格的浏览器将不会生效。","text":"2.1 网格布局知识 CSS Grid(网格) 布局使我们能够比以往任何时候都可以更灵活构建和控制自定义网格。 Grid(网格) 布局使我们能够将网页分成具有简单属性的行和列。它还能使我们在不改变任何HTML的情况下，使用 CSS 来定位和调整网格内的每个元素。它允许 HTML 纯粹作为内容的容器。HTML 结构不再受限于样式表现，比如不要为了实现某种布局而多次嵌套，现在这些都可以让 CSS 来完成。 浏览器兼容性 对于大多数布局，我们会使用下面的query特性来让老的浏览器对他们理解的特性也能工作： 12345@supports (display: grid) &#123; .grid &#123; display: grid; &#125;&#125; 不支持浏览器@supports或网格的浏览器将不会生效。 创建带有间距（gutter）的两列（column）网格 [使用grid-template-columns 和 grid-gap创建带间距的两列布局] 为了创建上述网格布局，我们需要使用grid-template-columns和grid-gap。grid-template-columns表示网格中的列是如何布局的，它的值是一连串以空格分割的的值，这些值标识每列的大小，值的个数表示列的数目。 例如，四列250px宽度的网格布局可以这样表示： 1grid-template-columns: 250px 250px 250px 250px; 也可以使用repeat关键字表示：1grid-template-columns: repeat(4, 250px); 定义间距grid-gap定义了网格布局的间距大小，接收一个或两个值，如果定义两个值则表示列（column）和行（row）的间距大小。 在两列布局示例中，我们可以如下使用： 12345.grid &#123; display: grid; grid-template-columns: 50vw 50vw; grid-gap: 1rem;&#125; 不幸的是，这个间距将会占用容器元素的整体宽度，计算出来就是100vw + 1rem，最终这个布局会导致出现水平滚动条。 为了解决这个空间溢出问题，我们需要些不同的方法来处理，需要用分数单位或者说是FR。 分数单位标识占用可用空间的份额，如果900px是可用空间，其中的一个元素占有1份，另外的元素占有2份——那么第一个元素的宽度会是900px的1/3，另外的元素是900px的2/3。修改后用分数代替view-port单位的新代码如下： 12345.grid &#123; display: grid; grid-template-columns: 1fr 1fr; grid-gap: 1rem;&#125; 内容对齐为了对齐示例中的内容，我们在子元素上使用grid布局，并加上对齐属性来定位他们到指定轨道(track)，轨道就是一个网格的列或行的某个位置的常见的名称。网格跟Flex布局一样，有一系列对齐的属性——共有四种值——start, center, end, 和stretch，分别对应其子元素所在的轨道。stretch跟其他不太一样，它会将元素从所在轨道的头拉伸到尾。 [align-items 和 justify-content] 例子中我们要将内容水平和垂直居中，可以通过在容器上设置下面这些属性：12345.center-content &#123; display: grid; align-items: center; justify-content: center;&#125; 通过CSS网格实现内边距（Negative Space）网格布局允许你通过grid-column-start属性指定列开始的位置，所以就有了可以在网格内创建内边距的可能性。[使用grid-template-columns和grid-column-start创建内边距] 在上面的内边距示例中，html结构中用一个div包裹另外一个div：123&lt;div class=\"grid\"&gt; &lt;div class=\"child\"&gt;&lt;!-- 内容 --&gt;&lt;/div&gt;&lt;/div 网格像这样设置： 123.child &#123; grid-column-start: 2;&#125; 创建行如果我们想分割布局为四份，我们目前所了解的关于列的布局方式对行同样有效： 12345.grid &#123; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 250px 250px;&#125; 理想情况下这个示例是没问题的。因为此时每个网格项的内容足够少而不会撑开每行。但随着内容的变化，一切都不一样了。当示例中的内容超出指定行的大小后，看下会发生什么： [内容超出声明的行高] 我们创建了250px高的两行，如果内容超过每行的高度，将会打破布局并和后面的行的内容重叠。并不是一个我们想要的结果。 灵活的设置最小值我们在该场景下需要的是设置最小尺寸的能力，但又要允许尺寸可以根据内容弹性变化。这里我们通过上面旧浏览器示例中的minmax关键字实现。 123.grid &#123; grid-template-rows: minmax(250px, auto) minmax(250px, auto);&#125; 现在我们已经了解了创建带有内容的行的基础方法，我们开始来创建水平和垂直交错的更复杂网格布局。 [使用grid-column-start和span关键字创建复杂网格布局Unsplash] 123.span-column-3 &#123; grid-column-start: span 3;&#125; 不需要媒体查询（media queries）的弹性网格虽然上面说到的例子能在可用空间内适应变化，但是没有一个是专门为空间变化设计的。网格有两个非常有用的特性来适应可用空间的变化。这两个属性叫‘auto-fit’和‘auto-fill’，像下面这样结合repeat function和minmax function使用： 1grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); auto-fill的表现跟auto-fit类似，但是任何的空白空间都会自动收缩，同时这一行的元素也会被拉升——类似flexbox的效果，列会随着可用空间变小发生折叠。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"网格布局","slug":"技术/前端基础知识/网格布局","permalink":"http://yoursite.com/categories/技术/前端基础知识/网格布局/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"网格布局","slug":"网格布局","permalink":"http://yoursite.com/tags/网格布局/"}]},{"title":"CSS 基础知识整理","slug":"前端基础知识整理2","date":"2018-06-23T09:31:49.997Z","updated":"2018-06-11T08:17:38.481Z","comments":true,"path":"2018/06/23/前端基础知识整理2/","link":"","permalink":"http://yoursite.com/2018/06/23/前端基础知识整理2/","excerpt":"1、CSS基础知识亲自做的思维导图：方便学习查看","text":"1、CSS基础知识亲自做的思维导图：方便学习查看 2、CSS 布局知识亲自做的思维导图：方便学习查看","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML 基础知识整理","slug":"前端基础知识整理1","date":"2018-06-23T09:31:49.978Z","updated":"2018-06-11T06:43:26.675Z","comments":true,"path":"2018/06/23/前端基础知识整理1/","link":"","permalink":"http://yoursite.com/2018/06/23/前端基础知识整理1/","excerpt":"把很久之前学习的基础知识整理一遍：1、HTML基础元素亲自做的思维导图：方便学习查看","text":"把很久之前学习的基础知识整理一遍：1、HTML基础元素亲自做的思维导图：方便学习查看 1.2 HTML表单元素亲自做的思维导图：方便学习查看 2、DOM文档对象模型 根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 亲自做的思维导图：方便学习查看 上面两个图标明了其属性，下面看看具体的方法： 1、创建 HTML 内容1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=\"p1\"&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById(\"p1\").innerHTML=\"New text!\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、改变 HTML 样式1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=\"p2\"&gt;Hello world!&lt;/p&gt;&lt;script&gt;document.getElementById(\"p2\").style.color=\"blue\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、创建新的 HTML 元素 将新元素作为父元素的最后一个子元素进行添加。 12345678910111213&lt;&lt;div id=\"d1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var element=document.getElementById(\"d1\");element.appendChild(para);&lt;/script&gt; 插在前面1234567891011121314&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var element=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");element.insertBefore(para,child);&lt;/script&gt; 4、删除已有的 HTML 元素 如需删除 HTML 元素，您必须清楚该元素的父元素： 12345678910&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var parent=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");parent.removeChild(child);&lt;/script&gt;&lt;/html&gt; 6、替换 HTML 元素 如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法： 1234567891011121314&lt;&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;This is a paragraph.&lt;/p&gt;&lt;p id=\"p2\"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement(\"p\");var node=document.createTextNode(\"This is new.\");para.appendChild(node);var parent=document.getElementById(\"div1\");var child=document.getElementById(\"p1\");parent.replaceChild(para,child);&lt;/script&gt; 7、使用事件：123456789101112131415&lt;html&gt;&lt;body&gt;&lt;script&gt;function ChangeBackground()&#123;document.body.style.backgroundColor=\"lavender\";&#125;&lt;/script&gt;&lt;input type=\"button\" onclick=\"ChangeBackground()\"value=\"Change background color\" /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"}]},{"title":"JS函数","slug":"函数","date":"2018-06-23T09:31:49.964Z","updated":"2018-06-14T14:19:35.053Z","comments":true,"path":"2018/06/23/函数/","link":"","permalink":"http://yoursite.com/2018/06/23/函数/","excerpt":"一、小心你的return语句我们JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑： 1234function foo() &#123; return &#123; name: 'foo' &#125;;&#125;foo(); // &#123; name: 'foo' &#125;","text":"一、小心你的return语句我们JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑： 1234function foo() &#123; return &#123; name: 'foo' &#125;;&#125;foo(); // &#123; name: 'foo' &#125; 如果把return语句拆成两行： 123456function foo() &#123; return &#123; name: 'foo' &#125;;&#125;foo(); // undefined 要小心了，由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了： 1234function foo() &#123; return; // 自动添加了分号，相当于return undefined; &#123; name: 'foo' &#125;; // 这行语句已经没法执行到了&#125; 所以正确的多行写法是：12345function foo() &#123; return &#123; // 这里不会自动加分号，因为&#123;表示语句尚未结束 name: 'foo' &#125;;&#125; 二、变量和作用域：在JavaScript中，用var申明的变量实际上是有作用域的。 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量： 123456'use strict';function foo() &#123; var x = 1; x = x + 1;&#125; x = x + 2; // ReferenceError! 无法在函数体外引用变量x 如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：123456'use strict';function foo() &#123; var x = 1; x = x + 1;&#125; 1234function bar() &#123; var x = 'A'; x = x + 'B';&#125; 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：123456789'use strict';function foo() &#123; var x = 1; function bar() &#123; var y = x + 1; // bar可以访问foo的变量x! &#125; var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!&#125; JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：123456789'use strict';function foo() &#123; var x = 'Hello, ' + y; console.log(x); var y = 'Bob';&#125;foo(); 虽然是strict模式，但语句var x = ‘Hello, ‘ + y;并不报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 对于上述foo()函数，JavaScript引擎看到的代码相当于：123456function foo() &#123; var y; // 提升变量y的申明，此时y为undefined var x = 'Hello, ' + y; console.log(x); y = 'Bob';&#125; 由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：12345678910function foo() &#123; var x = 1, // x初始化为1 y = x + 1, // y初始化为2 z, i; // z和i为undefined // 其他语句: for (i=0; i&lt;100; i++) &#123; ... &#125;&#125; 三、名字空间 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如： 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。 许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。 四、局部作用域由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的： 12345678'use strict';function foo() &#123; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125; 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量： 12345678910'use strict';function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; // SyntaxError: i += 1;&#125; 五、常量由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”： var PI = 3.14;ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域： 12345'use strict';const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 六、解构赋值从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。 什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量：1234var array = ['hello', 'JavaScript', 'ES6'];var x = array[0];var y = array[1];var z = array[2]; 现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值： 1234'use strict';// 如果浏览器支持解构赋值就不会报错:var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的：12345678910111213141516171819var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: &#123; city: 'Beijing', street: 'No.1 Road', zipcode: '100001' &#125;&#125;;var &#123;name, address: &#123;city, zip&#125;&#125; = person;name; // '小明'city; // 'Beijing'zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：1234567891011121314var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'&#125;;// 把passport属性赋值给变量id:let &#123;name, passport:id&#125; = person;name; // '小明'id; // 'G-12345678'// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题：123456789101112131415161718192021var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678'&#125;;// 如果person对象没有single属性，默认赋值为true:var &#123;name, single=true&#125; = person;name; // '小明'single; // true``````javascript有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：// 声明变量:var x, y;// 解构赋值:&#123;x, y&#125; = &#123; name: '小明', x: 100, y: 200&#125;;// 语法错误: Uncaught SyntaxError: Unexpected token = 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：1(&#123;x, y&#125; = &#123; name: '小明', x: 100, y: 200&#125;); 使用场景解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量： 12var x=1, y=2;[x, y] = [y, x] 快速获取当前页面的域名和路径： 1var &#123;hostname:domain, pathname:path&#125; = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象： 1234function buildDate(&#123;year, month, day, hour=0, minute=0, second=0&#125;) &#123; return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);&#125; 它的方便之处在于传入的对象只需要year、month和day这三个属性： 123456buildDate(&#123; year: 2017, month: 1, day: 1 &#125;);// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)也可以传入hour、minute和second属性：buildDate(&#123; year: 2017, month: 1, day: 1, hour: 20, minute: 15 &#125;);// Sun Jan 01 2017 20:15:00 GMT+0800 (CST) &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"函数","slug":"技术/函数","permalink":"http://yoursite.com/categories/技术/函数/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}]},{"title":"JS原型继承","slug":"关于JS继承","date":"2018-06-23T09:31:49.935Z","updated":"2018-06-22T09:39:26.995Z","comments":true,"path":"2018/06/23/关于JS继承/","link":"","permalink":"http://yoursite.com/2018/06/23/关于JS继承/","excerpt":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。 由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。","text":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。 由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。 首先看一个构造函数： 1234567function Student(props) &#123; this.name = props.name || 'Unnamed';&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125; 构造Student函数， 然后给他一个hello方法 其原型链 我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：12345function PrimaryStudent(props) &#123; // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1;&#125; 但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是： new PrimaryStudent() —-&gt; PrimaryStudent.prototype —-&gt; Object.prototype —-&gt; null 必须想办法把原型链修改为： new PrimaryStudent() —-&gt; PrimaryStudent.prototype —-&gt; Student.prototype —-&gt; Object.prototype —-&gt; null 这样，原型链对了，继承关系就对了。新的基于PrimaryStudent创建的对象不但能调用PrimaryStudent.prototype定义的方法，也可以调用Student.prototype定义的方法。 如果你想用最简单粗暴的方法这么干： PrimaryStudent.prototype = Student.prototype; 是不行的！如果这样的话，PrimaryStudent和Student共享一个原型对象，那还要定义PrimaryStudent干啥？ 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： 123456789101112131415161718192021222324252627282930313233343536373839// PrimaryStudent构造函数:function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 空函数F:function F() &#123;&#125;// 把F的原型指向Student.prototype:F.prototype = Student.prototype;// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:PrimaryStudent.prototype = new F();// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:PrimaryStudent.prototype.constructor = PrimaryStudent;// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;;// 创建xiaoming:var xiaoming = new PrimaryStudent(&#123; name: '小明', grade: 2&#125;);xiaoming.name; // '小明'xiaoming.grade; // 2// 验证原型:xiaoming.__proto__ === PrimaryStudent.prototype; // truexiaoming.__proto__.__proto__ === Student.prototype; // true// 验证继承关系:xiaoming instanceof PrimaryStudent; // truexiaoming instanceof Student; // true 注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。 如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码： 1234567function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125; 这个inherits()函数可以复用： 123456789101112131415161718192021function Student(props) &#123; this.name = props.name || 'Unnamed';&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125;function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 实现原型继承链:inherits(PrimaryStudent, Student);// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;; JavaScript的原型继承实现方式就是： 定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this； 借助中间函数F实现原型链继承，最好通过封装的inherits函数完成； 继续在新的构造函数的原型上定义新方法。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JS原型继承","slug":"技术/JS原型继承","permalink":"http://yoursite.com/categories/技术/JS原型继承/"}],"tags":[{"name":"JS原型继承","slug":"JS原型继承","permalink":"http://yoursite.com/tags/JS原型继承/"}]},{"title":"HTML 中的data_","slug":"关于data_","date":"2018-06-23T09:31:49.919Z","updated":"2018-06-14T14:16:39.043Z","comments":true,"path":"2018/06/23/关于data_/","link":"","permalink":"http://yoursite.com/2018/06/23/关于data_/","excerpt":"‘data-‘属性的作用是什么?下面我们通过一个例子来看看 我们写一个html页面，自定义一个data-chb=”header”的属性，希望具备这个属性的div区域背景颜色为黑色，文字为白色，居中显示；不具备data-chb自定义属性的div按照默认方式显示，html代码如下： 123456789&lt;body&gt; &lt;div data-chb=\"header\"&gt; &lt;h1&gt;我是使用了data-chb自定义属性的div&lt;/h1&gt; &lt;/div&gt; &lt;br/&gt; &lt;div&gt; 我没有使用data-chb自定义属性，该怎么展现就怎么展现； &lt;/div&gt; &lt;/body&gt;","text":"‘data-‘属性的作用是什么?下面我们通过一个例子来看看 我们写一个html页面，自定义一个data-chb=”header”的属性，希望具备这个属性的div区域背景颜色为黑色，文字为白色，居中显示；不具备data-chb自定义属性的div按照默认方式显示，html代码如下： 123456789&lt;body&gt; &lt;div data-chb=\"header\"&gt; &lt;h1&gt;我是使用了data-chb自定义属性的div&lt;/h1&gt; &lt;/div&gt; &lt;br/&gt; &lt;div&gt; 我没有使用data-chb自定义属性，该怎么展现就怎么展现； &lt;/div&gt; &lt;/body&gt; 要想实现”背景颜色为黑色，文字为白色，居中显示”的显示效果，我们定义如下的css： 12345678&lt;style&gt; .ui_header &#123; background-color: black; text-align: center; color:white; border:1px solid #000; &#125; &lt;/style&gt; 然后我们通过如下js方法实现在页面加载时，动态添加css定义，改变具备data-chb属性的div的显示样式： 123456789101112131415161718192021&lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var elems = document.getElementsByTagName(\"div\"); if(elems!=null&amp;&amp;elems.length&gt;0)&#123; var length = elems.length; //遍历所有DIV控件 for(var i=0;i&lt;length;i++)&#123; var elem = elems[i]; //获取该控件的自定义属性 var customAttr = elem.dataset.chb; //也可以通过如下方式获得自定义属性 //var customAttr = elem.dataset[\"chb\"]; //如果是我们预先定义好的header值，表示需要处理 if(customAttr==\"header\")&#123; //添加样式 elem.setAttribute(\"class\",\"ui_header\"); &#125; &#125; &#125; &#125; &lt;/script&gt; 这样我们就能动态的改变需要控制的div了。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"html","slug":"技术/html","permalink":"http://yoursite.com/categories/技术/html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"},{"name":"data_","slug":"data","permalink":"http://yoursite.com/tags/data/"}]},{"title":"前端问题集合及思考","slug":"一些问题集合及理解","date":"2018-06-23T09:31:49.909Z","updated":"2018-06-15T07:36:52.517Z","comments":true,"path":"2018/06/23/一些问题集合及理解/","link":"","permalink":"http://yoursite.com/2018/06/23/一些问题集合及理解/","excerpt":"1、前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标","text":"1、前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 2、的title和alt有什么区别 title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。alt是的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 3、HTML全局属性(global attribute)有哪些 accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素 class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素 contenteditable: 指定元素内容是否可编辑 contextmenu: 自定义鼠标右键弹出菜单内容 data-*: 为元素增加自定义属性 dir: 设置元素文本方向 draggable: 设置元素是否可拖拽 dropzone: 设置元素拖放类型： copy, move, link hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果 id: 元素id，文档内唯一 lang: 元素内容的的语言 spellcheck: 是否启动拼写和语法检查 style: 行内css样式 tabindex: 设置元素可以获得焦点，通过tab可以导航 title: 元素相关的建议信息 translate: 元素和子孙节点内容是否需要本地化 4、HTTP method 一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可 GET是最常用的方法，通常用于请求服务器发送某个资源。 HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分 PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它 POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将- 其发送到要去的地方。 TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。 OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。 DELETE请求服务器删除请求URL指定的资源 5、如何进行网站性能优化 1、content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下- 载和DNS查询 避免重定向：多余的中间访问 使Ajax可缓存 非必须组件延迟加载 未来所需组件预加载 减少DOM元素数量 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 减少iframe数量 不要404 2、Server方面 使用CDN 添加Expires或者Cache-Control响应头 对组件使用Gzip压缩 配置ETag Flush Buffer Early Ajax使用GET进行请求 避免空src的img标签 3、Cookie方面 减小cookie大小 引入资源的域名不要包含cookie 4、css方面 将样式表放到页面顶部 不使用CSS表达式 使用不使用@import 不使用IE的Filter 5 Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 合理设计事件监听器 6 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 保证favicon.ico小并且可缓存 7 HTTP状态码及其含义 1XX：信息状态码 2XX：成功状态码 3XX：重定向 4XX：客户端错误 5XX: 服务器错误 7、CSS选择器有哪些 *通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+ #X id选择器：选择id值为X的元素，兼容性：IE6+ .X 类选择器： 选择class包含X的元素，兼容性：IE6+ X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+ X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+ :link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+ X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+ X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+ X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+ [attr]：选择所有设置了attr属性的元素，兼容性IE7+ [attr=value]：选择属性值刚好为value的元素 [attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素 [attr|=value]：选择属性值刚好为value或者value-开头的元素 [attr^=value]：选择属性值以value开头的元素 [attr$=value]：选择属性值以value结尾的元素 [attr=value]*：选择属性值中包含value的元素 [:checked]：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+ X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，- ::after为IE9+ :hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+ :not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+ ::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+ ::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+ :nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n &gt;= 0， 兼容性IE9+ :nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素 其中n &gt;= 0，兼容性IE9+ X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+ X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+ X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+ X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+ X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+ X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+ X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素 是此此类型元素的第一个兄弟。选中它。兼容性IE9+ 8、css hack原理及常用hack 原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。常见的hack有1）属性hack。2）选择器hack。3）IE条件注释 9、link与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC link可以通过rel=”alternate stylesheet”指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import 10、PNG,GIF,JPG的区别及如何选 GIF: 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG： 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG： 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 11、容器包含若干浮动元素时如何清理(包含)浮动 容器元素闭合标签前添加额外元素并设置clear: both 父元素触发块级格式化上下文(见块级可视化上下文部分) 设置容器元素伪元素进行清理推荐的清理浮动方法示例： 1234567891011121314151617181920212223242526/*** 在标准浏览器下使用* 1 content内容为空格用于修复opera下文档中出现* contenteditable属性时在清理浮动元素上下的空白* 2 使用display使用table而不是block：可以防止容器和* 子元素top-margin折叠,这样能使清理效果与BFC，IE6/7* zoom: 1;一致**/.clearfix:before,.clearfix:after &#123; content: \" \"; /* 1 */ display: table; /* 2 */&#125;.clearfix:after &#123; clear: both;&#125;/*** IE 6/7下使用* 通过触发hasLayout实现包含浮动**/.clearfix &#123; *zoom: 1;&#125; 12、外边距折叠(collapsing margins) 毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下： 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 元素自身的margin-bottom和margin-top相邻时也会折叠 13、如何水平居中一个元素 如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现 如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。3）IE6下需在父元素上设置text-align: center;,再给子元素恢复需要的值 12345678910111213141516171819&lt;body&gt; &lt;div class=\"content\"&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; text-align: center; /* 3 */ &#125; .content &#123; width: 500px; /* 1 */ text-align: left; /* 3 */ margin: 0 auto; /* 2 */ background: purple; &#125;&lt;/style&gt; 如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=\"content\"&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; &#125; .content &#123; width: 500px; /* 1 */ float: left; position: relative; /* 2 */ left: 50%; /* 3 */ margin-left: -250px; /* 4 */ background-color: purple; &#125;&lt;/style&gt; 如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=\"content\"&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; position: relative; &#125; .content &#123; width: 800px; position: absolute; left: 50%; margin-left: -400px; background-color: purple; &#125;&lt;/style&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端问题集合及思考","slug":"技术/前端问题集合及思考","permalink":"http://yoursite.com/categories/技术/前端问题集合及思考/"}],"tags":[{"name":"问题集合","slug":"问题集合","permalink":"http://yoursite.com/tags/问题集合/"}]},{"title":"webpack使用技术详情","slug":"webpack系列文章7","date":"2018-06-23T09:31:49.891Z","updated":"2018-06-10T12:13:50.341Z","comments":true,"path":"2018/06/23/webpack系列文章7/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章7/","excerpt":"本文主要步骤：1、创建文件 mkdir mywebpack2、npm init -y // 用来创建webpack的配置文件3、安装webpack npm install webpack –save-dev4、安装组件 npm install html-webpack-plugin –save-dev //具体的index等文件自己创建就好了5、webpack.config.js 的使用 //这个之前基础都学习过了","text":"本文主要步骤：1、创建文件 mkdir mywebpack2、npm init -y // 用来创建webpack的配置文件3、安装webpack npm install webpack –save-dev4、安装组件 npm install html-webpack-plugin –save-dev //具体的index等文件自己创建就好了5、webpack.config.js 的使用 //这个之前基础都学习过了 5、处理js文件需要用的依赖包： 12npm install --save-dev babel-loader babel-core npm install --save-dev babel-preset-env //转义ES6 为防止浏览器不支持 Promise/Object.assign/Array.from等还有性能问题,我们引入两个包: babel-polyfill babel-plugin-transform-runtime 1npm install --save-dev babel-polyfill babel-plugin-transform-runtime 引入生产版本依赖 npm install –save babel-runtime 通过 .babelrc 添加配置: 12345678&#123; \"presets\": [ \"env\" ], \"plugins\": [ \"transform-runtime\" ]&#125; 将 babel-polyfill 加到你的 entry 数组中使用，配置js文件要经过babel转义： 12345678910111213141516171819202122232425const path = require('path');module.exports = &#123; //entry为入口,webpack从这里开始编译 entry: [ \"babel-polyfill\", path.join(__dirname, './src/index.js') ], //output为输出 path代表路径 filename代表文件名称 output: &#123; path: path.join(__dirname, './bundle'), filename: 'bundle.js' &#125;, //module是配置所有模块要经过什么处理 //test:处理什么类型的文件,use:用什么,include:处理这里的,exclude:不处理这里的 module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], include: path.join(__dirname , 'src'), exclude: /node_modules/ &#125; ] &#125;,&#125;; 6、打包： 直接执行命令webpack7、看看日志说明：8、使用快捷方式进行编译： 可以在项目package.json里面来配置 ： 123456789101112131415161718192021&#123; \"name\": \"05-01\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" \"build\":\"webpack\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"babel-preset-es2015\": \"^6.14.0\", \"babel-preset-react\": \"^6.11.1\", \"babelify\": \"^7.3.0\", \"react\": \"^15.3.2\", \"react-dom\": \"^15.3.2\", \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.1\" &#125;&#125; 下面你可以使用命令： 1npm run build 9、怎样自动加载： 首先安装webpack-dev-server 执行命令：1npm install webpack-dev-serve --save-dev 下面就可以执行如下命令了1webpack-dev-server --contentbase -src --inline 注意： 这里版本很重要，要匹配。 如果安装其他版本，可以在名称后面加@跟上版本号就可以了。 10、配置端口号 webpakc.config.js 里面配置 12345 devServer: &#123; contentBase: path.join(__dirname, \"dist\"), compress: true, port: 9000&#125; 接下来以管理员身份执行命令 1npm run start 11、配置ESLint 实现代码规范化自动化测试 安装： npm install eslint --save-dev 配置： package.json 里面的配置： { \"name\": \"05-01\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" \"build\":\"webpack\" \"lintjs\":\"eslint app/ webpack.*.js --cache\" //这是我们需要配置的 }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"babel-preset-es2015\": \"^6.14.0\", \"babel-preset-react\": \"^6.11.1\", \"babelify\": \"^7.3.0\", \"react\": \"^15.3.2\", \"react-dom\": \"^15.3.2\", \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.1\" } } eslintrc.js 里面的配置： 具体的规则可以去官网查看。 执行如下命令即可： npm run lintjs 如果有错误：会相应的提示。 怎样修复呢：执行命令： npm run lintjs -- --fix 如何自动测试 在webpack 中集成： 首先进行安装： npm install eslint-loader –save-dev 然后在webpack.config.js 里面进行配置： 具体配置可以查看官方文档。 12、webpack中加载CSS的相关配置 需要安装两个插件： npm insatall css-loader style-loader --save-dev webpack.config.js进行配置： const ExtractTextPlugin = require('extract-text-webpack-plugin'); ... module: { rules: [ ... { test: /\\.less$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: ['css-loader', 'style-loader','postcss-loader', 'less-loader'] //进行配置 }) } ] }, plugins: [ ... new ExtractTextPlugin({ filename: 'index.css' }), ], 13、webpack中加载图片 在 webpack 里，负责图片翻译的是 file-loader： npm install file-loader --save-dev 在webpack.config.js里面进行配置： }, { test: /\\.(png|jpg|gif)$/, use: [ { loader: 'file-loader', options: {} } ] } ] 至于我们怎样在js文件里配置： 我们需要一张图片，我从 unsplash 找来了一张玫瑰，放到 src/img/rose.jpg 位置。 我们在 src/index.js 中 import 它： import ReactDOM from 'react-dom' import Rose from './img/rose.jpg' class App extends React.Component { render () { return ( &lt;div&gt;&lt;img src={Rose} alt='玫瑰' /&gt;&lt;/div&gt; ) } } ReactDOM.render(&lt;App /&gt;, document.body) 14、打包： 在完成项目开发后，我们需要输出文件给生产环境部署，只要执行： npx webpack --mode production 14、部署： 部署时，拷贝 dist 目录即可。 15、清理 dist 随着某些文件的增删，我们的 dist 目录下会产生一些不再使用的文件，我们不想这些文件也部署到生产环境上占用空间，所以 webpack 在打包前最好能删除 dist 目录。 我们来试试 clean-webpack-plugin。 首先是安装： npm i -D clean-webpack-plugin 然后在 webpack.config.js 中调用： const path = require('path') const CleanWebpackPlugin = require('clean-webpack-plugin') module.exports = { mode: 'development', devServer: { contentBase: path.resolve(__dirname, 'dist') }, plugins: [ new CleanWebpackPlugin(['dist']) //需要实例化 ], module: { 再执行 npx webpack –mode production，webpack 确实会在打包前清空 dist 目录，但我们的 index.html 也一起被清空了。 下面我们使用 html-webpack-plugin 来自动生成 index.html： 首先是安装： npm i --save-dev html-webpack-plugin 调整 webpack.config.js： const CleanWebpackPlugin = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', devServer: { contentBase: path.resolve(__dirname, 'dist') }, plugins: [ new CleanWebpackPlugin(['dist']) new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin() ], 再运行 npx webpack –mode production，dist 下已经自动生成 index.html，再 title 却是 Webpack App，我们需要再调整一下 webpack.config.js： plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin() new HtmlWebpackPlugin({ title: 'webpack 教程' }) ], 至此，我们大致的教程算是完结了，但是这样比较麻烦，如果开发一个特定类型的项目，我们可以采用脚手架的方式直接生成： 比较有名的有： create-react-app react 官方出品的一套，只适用开发 react.js 项目； neutrino.js 这是 Mozilla 出品的一套解决方案，Web、React、Node.js 等方案均有；","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-配置","slug":"webpack系列文章6","date":"2018-06-23T09:31:49.883Z","updated":"2018-06-10T05:36:38.888Z","comments":true,"path":"2018/06/23/webpack系列文章6/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章6/","excerpt":"12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ &#125;,","text":"12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ &#125;, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157 module: &#123; // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: &#123; test, include, exclude &#125;, // issuer 条件（导入源） enforce: \"pre\", enforce: \"post\", // 标识应用这些规则，即使规则覆盖（高级选项） loader: \"babel-loader\", // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: &#123; presets: [\"es2015\"] &#125;, // loader 的可选项 &#125;, &#123; test: /\\.html$/, test: \"\\.html$\" use: [ // 应用多个 loader 和选项 \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // 只使用这些嵌套规则之一 &#123; rules: [ /* rules */ ] &#125;, // 使用所有这些嵌套规则（合并可用条件） &#123; resource: &#123; and: [ /* 条件 */ ] &#125; &#125;, // 仅当所有条件都匹配时才匹配 &#123; resource: &#123; or: [ /* 条件 */ ] &#125; &#125;, &#123; resource: [ /* 条件 */ ] &#125;, // 任意条件匹配时匹配（默认为数组） &#123; resource: &#123; not: /* 条件 */ &#125; &#125; // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ &#125;, resolve: &#123; // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ \"node_modules\", path.resolve(__dirname, \"app\") ], // 用于查找模块的目录 extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 使用的扩展名 alias: &#123; // 模块别名列表 \"module\": \"new-module\", // 起别名：\"module\" -&gt; \"new-module\" 和 \"module/path/file\" -&gt; \"new-module/path/file\" \"only-module$\": \"new-module\", // 起别名 \"only-module\" -&gt; \"new-module\"，但不匹配 \"only-module/path/file\" -&gt; \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // 起别名 \"module\" -&gt; \"./app/third/module.js\" 和 \"module/file\" 会导致错误 // 模块别名相对于当前上下文导入 &#125;, /* 可供选择的别名语法（点击展示） */ /* 高级解析选项（点击展示） */ &#125;, performance: &#123; hints: \"warning\", // 枚举 maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // enum // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map' 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: \"web\", // 枚举 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: [\"react\", /^@angular\\//], // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: \"errors-only\", // 精确控制要显示的 bundle 信息 devServer: &#123; proxy: &#123; // proxy URLs to backend development server '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... &#125;, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-插件","slug":"webpack系列文章5","date":"2018-06-23T09:31:49.877Z","updated":"2018-06-10T05:32:59.393Z","comments":true,"path":"2018/06/23/webpack系列文章5/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章5/","excerpt":"插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。","text":"插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。 用法由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。 根据你的 webpack 用法，这里有多种方式使用插件： 12345678910111213141516171819202122232425const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, use: 'babel-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-loader","slug":"webpack系列文章4","date":"2018-06-23T09:31:49.867Z","updated":"2018-06-10T05:26:58.187Z","comments":true,"path":"2018/06/23/webpack系列文章4/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章4/","excerpt":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;;","text":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;; loader的使用方式 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 //不推荐就不作介绍了 CLI：在 shell 命令中指定它们。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-出口","slug":"webpack系列文章3","date":"2018-06-23T09:31:49.850Z","updated":"2018-06-10T05:17:33.215Z","comments":true,"path":"2018/06/23/webpack系列文章3/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章3/","excerpt":"配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 单个出口用法在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config;","text":"配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 单个出口用法在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config; 多个出口如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 123456789101112&#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' &#125;&#125;// 写入到硬盘：./dist/app.js, ./dist/search.js","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习-入口起点","slug":"webpack系列文章2","date":"2018-06-23T09:31:49.845Z","updated":"2018-06-10T05:08:39.152Z","comments":true,"path":"2018/06/23/webpack系列文章2/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章2/","excerpt":"单个入口单个入口在上一章其实已经看到了，下面，我们主要学习下多个入口怎样创建。","text":"单个入口单个入口在上一章其实已经看到了，下面，我们主要学习下多个入口怎样创建。 多个入口1、分离 应用程序(app) 和 第三方库(vendor) 入口123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 从表面上看，这告诉我们 webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。 2、多页面应用程序1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; webpack 需要 3 个独立分离的依赖图（如上面的示例）。在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事： 使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识学习","slug":"webpack系列文章1","date":"2018-06-23T09:31:49.836Z","updated":"2018-06-10T04:51:28.443Z","comments":true,"path":"2018/06/23/webpack系列文章1/","link":"","permalink":"http://yoursite.com/2018/06/23/webpack系列文章1/","excerpt":"简介webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 核心概念的理解1.入口(entry)2.输出(output)3.loader4.插件(plugins)","text":"简介webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 核心概念的理解1.入口(entry)2.输出(output)3.loader4.插件(plugins) 1、入口入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中.可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。接下来我们看一个 entry 配置的最简单例子： 123456789module.exports = &#123; context: path.join(dirname), devtool: debug ? “inline-sourcemap” : null, entry: “./src/js/index.js”, output: &#123; path: dirname, filename: “./src/bundle.js” &#125;,&#125;; 2、出口output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： 1234567891011121314 var debug = process.env.NODE_ENV !== “production”; var webpack = require(‘webpack’); var path = require(‘path’);module.exports = &#123; context: path.join(dirname), devtool: debug ? “inline-sourcemap” : null, entry: “./src/js/index.js”, output: &#123; path: dirname, filename: “./src/bundle.js” &#125;,&#125;; 3、loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在更高层面，在 webpack 的配置中 loader 有两个目标：1、test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。2、use 属性，表示进行转换时，应该使用哪个 loader。 123456789101112131415const path = require(‘path’);const config = &#123; output: &#123; filename: ‘my-first-webpack.bundle.js’ &#125;, module: &#123; rules: [ &#123; test: /.txt$/, use: ‘raw-loader’ &#125; // 也可以改成.js?$/ ] &#125;&#125;;module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。” 4、插件loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 1234567891011121314151617const HtmlWebpackPlugin = require(‘html-webpack-plugin’); // 通过 npm 安装const webpack = require(‘webpack’); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /.txt$/, use: ‘raw-loader’ &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: ‘./src/index.html’&#125;) ]&#125;;module.exports = config; 5、模式通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 123module.exports = &#123; mode: ‘production’&#125;; 以上是对webpack 作了一个简短的介绍，后面详细学习之！","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"webpack系列文章","slug":"技术/webpack系列文章","permalink":"http://yoursite.com/categories/技术/webpack系列文章/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Sass学习","slug":"Sass","date":"2018-06-23T09:31:49.803Z","updated":"2018-06-14T14:16:23.953Z","comments":true,"path":"2018/06/23/Sass/","link":"","permalink":"http://yoursite.com/2018/06/23/Sass/","excerpt":"一、安装由于Sass是基于ruby的，所以先安装ruby。 Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板：Start Command Prompt with Ruby 1、通过命令安装 Sass 1gem install sass 使用国内淘宝镜像gem。第一步：gem sources –remove https://rubygems.org/ 删除自带gem第二步：gem sources -a https://ruby.taobao.org/ 添加国内淘宝镜像gem第三步：gem sources 显示下载的gem信息 查看版本sass -v 更新：gem update sass 删除gem uninstall sass","text":"一、安装由于Sass是基于ruby的，所以先安装ruby。 Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板：Start Command Prompt with Ruby 1、通过命令安装 Sass 1gem install sass 使用国内淘宝镜像gem。第一步：gem sources –remove https://rubygems.org/ 删除自带gem第二步：gem sources -a https://ruby.taobao.org/ 添加国内淘宝镜像gem第三步：gem sources 显示下载的gem信息 查看版本sass -v 更新：gem update sass 删除gem uninstall sass 后缀sass 和scss 的区别： sass 不用{} 包裹， 而scss可以包裹。建议使用scss。 示例： 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 二、Sass编译 命令编译 GUI工具编译 自动化编译 1、命令编译单文件编译： sass &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css 多文件编译： sass sass/:css/ 上面的命令表示将项目中“sass”文件夹中所有“.scss”(“.sass”)文件编译成“.css”文件，并且将这些 CSS 文件都放在项目中“css”文件夹中。 2、GUI 界面工具编译就推荐Koala 其他就不介绍了。 3、自动化编译 Grunt Gulp 具体配置自行查看文档 三、常见错误： 最为常见的一个错误就是字符编译引起的。在Sass的编译的过程中，是不是支持“GBK”编码的。所以在创建 Sass 文件时，就需要将文件编码设置为“utf-8”。 另外一个错误就是路径中的中文字符引起的。建议在项目中文件命名或者文件目录命名不要使用中文字符。而至于人为失误造成的编译失败，在编译过程中都会有具体的说明，大家可以根据编译器提供的错误信息进行对应的修改。 四、不同样式风格的输出方法 嵌套输出方式 nested 展开输出方式 expanded 紧凑输出方式 compact 压缩输出方式 compressed 4.1嵌套输出方式 nested语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style nested”:sass –watch test.scss:test.css –style nested 编译出来的 CSS 样式风格：12345678910nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; 4.2 展开输出方式 expanded语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style expanded”: sass –watch test.scss:test.css –style expanded 这个输出的 CSS 样式风格和 nested 类似，只是大括号在另起一行，同样上面的代码，编译出来：12345678910111213nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 4.3 紧凑输出方式 compact语法：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 在编译的时候带上参数“ –style compact”: sass –watch test.scss:test.css –style compact 该方式适合那些喜欢单行 CSS 样式格式的朋友，编译后的代码如下： 123nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; 4.4 压缩输出方式 compressed在编译的时候带上参数“ –style compressed”: sass –watch test.scss:test.css –style compressed 压缩输出方式会去掉标准的 Sass 和 CSS 注释及空格。也就是压缩好的 CSS 代码样式风格：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Sass","slug":"技术/Sass","permalink":"http://yoursite.com/categories/技术/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"}]},{"title":"Sass学习2","slug":"Sass.1","date":"2018-06-23T09:31:49.788Z","updated":"2018-06-13T07:07:34.096Z","comments":true,"path":"2018/06/23/Sass.1/","link":"","permalink":"http://yoursite.com/2018/06/23/Sass.1/","excerpt":"一、Sass的基本特性 上图非常清楚告诉了大家，Sass 的变量包括三个部分： 1.声明变量的符号“$”2.变量名称3.赋予变量的值","text":"一、Sass的基本特性 上图非常清楚告诉了大家，Sass 的变量包括三个部分： 1.声明变量的符号“$”2.变量名称3.赋予变量的值 1.1普通变量和默认变量：1、普通变量定义之后可以在全局范围内使用。 2、默认变量sass 的默认变量仅需要在值后面加上 !default 即可。 sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。12345$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight; &#125; 1.2变量的调用1.3 全局比那里和局部变量1234567891011121314//SCSS$color: orange !default;//定义全局变量(在选择器、函数、混合宏...的外面定义的变量为全局变量).block &#123; color: $color;//调用全局变量&#125;em &#123; $color: red;//定义局部变量 a &#123; color: $color;//调用局部变量 &#125;&#125;span &#123; color: $color;//调用全局变量&#125; 什么时候声明变量？ 我的建议，创建变量只适用于感觉确有必要的情况下。不要为了某些骇客行为而声明新变量，这丝毫没有作用。只有满足所有下述标准时方可创建新变量： 该值至少重复出现了两次； 该值至少可能会被更新一次； 该值所有的表现都与变量有关（非巧合）。基本上，没有理由声明一个永远不需要更新或者只在单一地方使用变量。 嵌套-选择器嵌套 Sass 中还提供了选择器嵌套功能，但这也并不意味着你在 Sass 中的嵌套是无节制的，因为你嵌套的层级越深，编译出来的 CSS 代码的选择器层级将越深，这往往是大家不愿意看到的一点。这个特性现在正被众多开发者滥用。 Sass 的嵌套分为三种： 选择器嵌套 属性嵌套 伪类嵌套 选择器嵌套假设我们有一段这样的结构：1234567&lt;header&gt;&lt;nav&gt; &lt;a href=“##”&gt;Home&lt;/a&gt; &lt;a href=“##”&gt;About&lt;/a&gt; &lt;a href=“##”&gt;Blog&lt;/a&gt;&lt;/nav&gt;&lt;header&gt; 想选中 header 中的 a 标签，在 Sass 中，就可以使用选择器的嵌套来实现：123456789nav &#123; a &#123; color: red; header &amp; &#123; color:green; &#125; &#125; &#125; 属性嵌套Sass 中还提供属性嵌套，CSS 有一些属性前缀相同，只是后缀不一样，比如：border-top/border-right，与这个类似的还有 margin、padding、font 等属性。假设你的样式中用到了： 1234.box &#123; border-top: 1px solid red; border-bottom: 1px solid green;&#125; 在 Sass 中我们可以这样写：123456.box &#123; border: &#123; top: 1px solid red; bottom: 1px solid green; &#125;&#125; 伪类嵌套1234567891011.clearfix&#123;&amp;:before,&amp;:after &#123; content:\"\"; display: table; &#125;&amp;:after &#123; clear:both; overflow: hidden; &#125;&#125; 避免选择器嵌套： 选择器嵌套最大的问题是将使最终的代码难以阅读。开发者需要花费巨大精力计算不同缩进级别下的选择器具体的表现效果。选择器越具体则声明语句越冗长，而且对最近选择器的引用(&amp;)也越频繁。在某些时候，出现混淆选择器路径和探索下一级选择器的错误率很高，这非常不值得。 混合宏-声明混合宏如果你的整个网站中有几处小样式类似，比如颜色，字体等，在 Sass 可以使用变量来统一处理，那么这种选择还是不错的。但当你的样式变得越来越复杂，需要重复使用大段的样式时，使用变量就无法达到我们目了。这个时候 Sass 中的混合宏就会变得非常有意义。 1、声明混合宏 不带参数混合宏： 在 Sass 中，使用“@mixin”来声明一个混合宏。如： 1234@mixin border-radius&#123; -webkit-border-radius: 5px; border-radius: 5px;&#125; 其中 @mixin 是用来声明混合宏的关键词，有点类似 CSS 中的 @media、@font-face 一样。border-radius 是混合宏的名称。大括号里面是复用的样式代码。 带参数混合宏： 除了声明一个不带参数的混合宏之外，还可以在定义混合宏时带有参数，如：1234@mixin border-radius($radius:5px)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 复杂的混合宏： 上面是一个简单的定义混合宏的方法，当然， Sass 中的混合宏还提供更为复杂的，你可以在大括号里面写上带有逻辑关系，帮助更好的做你想做的事情,如：12345678@mixin box-shadow($shadow...) &#123; @if length($shadow) &gt;= 1 &#123; @include prefixer(box-shadow, $shadow); &#125; @else&#123; $shadow:0 0 4px rgba(0,0,0,.3); @include prefixer(box-shadow, $shadow); &#125;&#125; 混合宏-调用混合宏在 Sass 中通过 @mixin 关键词声明了一个混合宏，那么在实际调用中，其匹配了一个关键词“@include”来调用声明好的混合宏。例如在你的样式中定义了一个圆角的混合宏“border-radius”: 1234@mixin border-radius&#123; -webkit-border-radius: 3px; border-radius: 3px;&#125; 在一个按钮中要调用定义好的混合宏“border-radius”，可以这样使用: 123button &#123; @include border-radius;&#125; 混合宏的参数–传一个不带值的参数1234@mixin border-radius($radius)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 在混合宏“border-radius”中定义了一个不带任何值的参数“$radius”。 在调用的时候可以给这个混合宏传一个参数值：123.box &#123; @include border-radius(3px);&#125; 混合宏的参数–传一个带值的参数Sass 混合宏除了能传一个参数之外，还可以传多个参数，如：123456789@mixin center($width,$height)&#123; width: $width; height: $height; position: absolute; top: 50%; left: 50%; margin-top: -($height) / 2; margin-left: -($width) / 2;&#125; 有一个特别的参数“…”。当混合宏传的参数过多之时，可以使用参数来替代，如： 12345678910@mixin box-shadow($shadows...)&#123; @if length($shadows) &gt;= 1 &#123; -webkit-box-shadow: $shadows; box-shadow: $shadows; &#125; @else &#123; $shadows: 0 0 2px rgba(#000,.25); -webkit-box-shadow: $shadow; box-shadow: $shadow; &#125;&#125; 继承在 Sass 中是通过关键词 “@extend”来继承已存在的类样式块，从而实现代码的继承。如下所示： 123456789101112131415161718//SCSS.btn &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff; @extend .btn;&#125;.btn-second &#123; background-color: orange; color: #fff; @extend .btn;&#125; 占位符 （重点）Sass 中的占位符 %placeholder 功能是一个很强大，很实用的一个功能，这也是我非常喜欢的功能。他可以取代以前 CSS 中的基类造成的代码冗余的情形。因为 %placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码。来看一个演示： 123456%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125; 这段代码没有被 @extend 调用，他并没有产生任何代码块，只是静静的躺在你的某个 SCSS 文件中。只有通过 @extend 调用才会产生代码： 1234567891011121314151617181920//SCSS%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125;.btn &#123; @extend %mt5; @extend %pt5;&#125;.block &#123; @extend %mt5; span &#123; @extend %pt5; &#125;&#125; 混合宏 VS 继承 VS 占位符a) Sass 中的混合宏使用 编译出来的 CSS 清晰告诉了大家，他不会自动合并相同的样式代码，如果在样式文件中调用同一个混合宏，会产生多个对应的样式代码，造成代码的冗余，这也是 CSSer 无法忍受的一件事情。不过他并不是一无事处，他可以传参数。 个人建议：如果你的代码块中涉及到变量，建议使用混合宏来创建相同的代码块。 b) Sass 中继承 总结：使用继承后，编译出来的 CSS 会将使用继承的代码块合并到一起，通过组合选择器的方式向大家展现，比如 .mt, .block, .block span, .header, .header span。这样编译出来的代码相对于混合宏来说要干净的多，也是 CSSer 期望看到。但是他不能传变量参数。 个人建议：如果你的代码块不需要专任何变量参数，而且有一个基类已在文件中存在，那么建议使用 Sass 的继承。 c) 占位符 总结：编译出来的 CSS 代码和使用继承基本上是相同，只是不会在代码中生成占位符 mt 的选择器。那么占位符和继承的主要区别的，“占位符是独立定义，不调用的时候是不会在 CSS 中产生任何代码；继承是首先有一个基类存在，不管调用与不调用，基类的样式都将会出现在编译出来的 CSS 代码中。” [Sass]插值#{}123456789$properties: (margin, padding);@mixin set-value($side, $value) &#123; @each $prop in $properties &#123; #&#123;$prop&#125;-#&#123;$side&#125;: $value; &#125;&#125;.login-box &#123; @include set-value(top, 14px);&#125; 它可以让变量和属性工作的很完美，上面的代码编译成 CSS： 12345.login-box &#123; margin-top: 14px; padding-top: 14px;&#125; Sass的基本特性-运算[Sass运算]加法加法运算是 Sass 中运算中的一种，在变量或属性中都可以做加法运算。如： 123.box &#123; width: 20px + 8in;&#125; 编译出来的 CSS:123.box &#123; width: 788px;&#125; 但对于携带不同类型的单位时，在 Sass 中计算会报错，如下例所示：123.box &#123; width: 20px + 1em;&#125; [Sass运算]减法Sass 的减法运算和加法运算类似，我们通过一个简单的示例来做阐述： 123456$full-width: 960px;$sidebar-width: 200px;.content &#123; width: $full-width - $sidebar-width;&#125; [Sass运算]乘法Sass 中的乘法运算和前面介绍的加法与减法运算还略有不同。虽然他也能够支持多种单位（比如 em ,px , %），但当一个单位同时声明两个值时会有问题。比如下面的示例： 123.box &#123; width:10px * 2px; &#125; 如果进行乘法运算时，两个值单位相同时，只需要为一个数值提供单位即可。上面的示例可以修改成： 123.box &#123; width: 10px * 2;&#125; [Sass运算]除法Sass 的乘法运算规则也适用于除法运算。不过除法运算还有一个特殊之处。众所周知“/”符号在 CSS 中已做为一种符号使用。因此在 Sass 中做除法运算时，直接使用“/”符号做为除号时，将不会生效，编译时既得不到我们需要的效果，也不会报错。一起先来看一个简单的示例： 123.box &#123; width: 100px / 2; &#125; 这样的结果对于大家来说没有任何意义。要修正这个问题，只需要给运算的外面添加一个小括号( )即可： 123.box &#123; width: (100px / 2); &#125; 除了上面情况带有小括号，“/”符号会当作除法运算符之外，如果“/”符号在已有的数学表达式中时，也会被认作除法符号。如下面示例： 123.box &#123; width: 100px / 2 + 2in; &#125; 另外，在 Sass 除法运算中，当用变量进行除法运算时，“/”符号也会自动被识别成除法，如下例所示： 12345678910$width: 1000px;$nums: 10;.item &#123; width: $width / 10; &#125;.list &#123; width: $width / $nums;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Sass","slug":"技术/Sass","permalink":"http://yoursite.com/categories/技术/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"}]},{"title":"React4-React事件与数据的双向绑定","slug":"React系列文章6","date":"2018-06-23T09:31:49.776Z","updated":"2018-06-10T02:42:32.388Z","comments":true,"path":"2018/06/23/React系列文章6/","link":"","permalink":"http://yoursite.com/2018/06/23/React系列文章6/","excerpt":"事件的绑定 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: \"IMOOC\",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"提交\" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125;","text":"事件的绑定 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: \"IMOOC\",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"提交\" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125; Props 属性： props 对于模块属于外来属性 传递参数： 在被引入模块中添加{this.props.userid} 这里面的userid就是你引用的一个参数，然后你就可以在引入该模块的文件中给这个userid进行赋值了：&lt;’被引入的模块’ userid={1220}/&gt;，这样就可以顺利的传递参数了。 模块中接受参数：this.props.username 被引入模块的示例代码：123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : \"Parry\", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 引入模块文件的示例代码：1234567891011121314151617var React = require('react');var ReactDOM = require('react-dom');import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;\"nick\"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React4-React 属性与事件","slug":"React系列文章5","date":"2018-06-23T09:31:49.759Z","updated":"2018-06-10T02:31:27.249Z","comments":true,"path":"2018/06/23/React系列文章5/","link":"","permalink":"http://yoursite.com/2018/06/23/React系列文章5/","excerpt":"State属性 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\", age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;","text":"State属性 表示页面状态的值 state 对于模块属于自身的属性 首先需要进行初始化 this.state = {username: “Parry”}; 初始化可以放置在构造函数 constructor 里 修改 state：this.setState({username:”IMOOC”}); state 的作用域只属于当前的类，不污染其他模块 代码示例:12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: \"Parry\", age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\", age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; Props 属性： props 对于模块属于外来属性 传递参数： 在被引入模块中添加{this.props.userid} 这里面的userid就是你引用的一个参数，然后你就可以在引入该模块的文件中给这个userid进行赋值了：&lt;’被引入的模块’ userid={1220}/&gt;，这样就可以顺利的传递参数了。 模块中接受参数：this.props.username 被引入模块的示例代码：123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : \"Parry\", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: \"IMOOC\",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 引入模块文件的示例代码：1234567891011121314151617var React = require('react');var ReactDOM = require('react-dom');import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;\"nick\"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React4-React生命周期","slug":"React系列文章4","date":"2018-06-23T09:31:49.745Z","updated":"2018-06-12T00:25:56.288Z","comments":true,"path":"2018/06/23/React系列文章4/","link":"","permalink":"http://yoursite.com/2018/06/23/React系列文章4/","excerpt":"React生命周期官方文档React生命周期图例：","text":"React生命周期官方文档React生命周期图例： React生命周期代码示例：12345678910111213141516171819202122232425262728293031import React from 'react';export default class BodyIndex extends React.Component&#123;//定义页面将要加载 componentWillMount()&#123; //定义你的逻辑即可 console.log(\"BodyIndex - componentWillMount\"); &#125;//定义页面加载完成 componentDidMount()&#123; console.log(\"BodyIndex - componentDidMount\"); &#125; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React3-React内置表达式","slug":"React系列文章3","date":"2018-06-23T09:31:49.729Z","updated":"2018-06-12T00:30:36.755Z","comments":true,"path":"2018/06/23/React系列文章3/","link":"","permalink":"http://yoursite.com/2018/06/23/React系列文章3/","excerpt":"三元表达式：12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component&#123; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125;","text":"三元表达式：12345678910111213141516171819202122import React from 'react';export default class BodyIndex extends React.Component&#123; render()&#123; var userName = ''; var boolInput = false; var html = \"IMOOC&amp;nbsp;LESSON\"; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName=='' ? '用户还没有登录' : '用户名：' + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type='button' value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;/div&gt; ) &#125;&#125; React 三元表达式 {window.userName == ‘’ ? ‘默认用户名’ : ‘用户名： ‘ + userName} 注意是== ， 而不是”=” React 传参 disabled={boolInput} 不要用”” 而是用{}; React注释如何来写 如果在代码块里面： {/注释/} 在代码块外面： //comments React如果要显示html里面的空格 HTML 要显示可以进行 Unicode 转码","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React2-React组件化","slug":"React系列文章2","date":"2018-06-23T09:31:49.717Z","updated":"2018-06-09T07:01:36.714Z","comments":true,"path":"2018/06/23/React系列文章2/","link":"","permalink":"http://yoursite.com/2018/06/23/React系列文章2/","excerpt":"React 机制","text":"React 机制 React 组件 组件是 React 的一个主要特性 组件对于模块化开发的重要性 组件的 return 函数里返回的 HTML 节点必须是一个 可以给外部使用的组件定义：export default class ComponentHeader extends React.Component{} 入口的定义：ReactDOM.render(, document.getElementById(‘example’)); 组件return 函数返回Html的节点必须是一个 index.js 里面代码示例:12345678910111213141516import React from 'react';import PCHeader from './pc_header';import PCFooter from './pc_footer';import PCNewsContainer from './pc_newscontainer';export default class PCIndex extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;PCHeader&gt;&lt;/PCHeader&gt; &lt;PCNewsContainer&gt;&lt;/PCNewsContainer&gt; &lt;PCFooter&gt;&lt;/PCFooter&gt; &lt;/div&gt; ); &#125;;&#125; pc_header.js 里面代码示例:1234567891011import React from 'react';import &#123;Row, Col&#125; from 'antd';import &#123;Router, Route, Link, browserHistory&#125; from 'react-router'class PCHeader extends React.Component &#123;render()&#123; return( &lt;h1&gt;这是页头&lt;/h1&gt; );&#125; &#125; React 多组件嵌套通过上面的示例我们可以看到：组件也可以通过参数的形式传递。把pc_header.js 组件作为一个参数传递到index.js里面。 这样我们可以分别开发页面不同的部分，非常方便。 需要注意的有两点： 命名的规范化。 项目搭建的规范化。 这里我们需要注意一个项目怎么去搭建项目的结构，下面是示例图片，可以参考下：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"React1-react简介及安装","slug":"react系列1","date":"2018-06-23T09:31:49.705Z","updated":"2018-06-09T06:40:55.284Z","comments":true,"path":"2018/06/23/react系列1/","link":"","permalink":"http://yoursite.com/2018/06/23/react系列1/","excerpt":"本文主要讲述使用react创建一个新闻站点的技术教程，本文主要技术来源于：慕课网。如果你感兴趣，可以跟着一起来完成。 React的简介 Facebook 内部用来开发Instagram JavaScript MVC框架 React 开源网址：React github React 中文文档：React中文文档","text":"本文主要讲述使用react创建一个新闻站点的技术教程，本文主要技术来源于：慕课网。如果你感兴趣，可以跟着一起来完成。 React的简介 Facebook 内部用来开发Instagram JavaScript MVC框架 React 开源网址：React github React 中文文档：React中文文档 学习React需要掌握的知识 JS ES5/Es6 ——会使用babel ——&gt; 中文文档：babel NodeJS CSS HTML React 安装及管理 确保先安装了node.js —-最新的node.js包已经包含了npm 怎么查看是否安装？ node -v npm -v npm 换镜像源 （用淘宝的源就可以） 这样下载就比较快了 最好采用npm 安装管理 （官方推荐方式） 用npm 安装React 项目初始化 1npm init 通过初始化就建立了一个react的配置文件，下面再进行安装react需要的其他依赖包。 安装依赖包可以有两种方式：1、先在配置文件里加入需要安装的文件包名和版本，然后通过npm install 来进行安装2、直接用npm来安装 方式如下：npm install babel-preset-es2015@版本号 –save 这样你安装的包就可以把安装依赖的信息存储到配置文件里了 这里我们需要安装的依赖包有babel-preset-es2015 、babelify、babel-preset-react、react、react-dom 等 其他需要的依赖包可以在后续不断加入 注： 如果要全局安装的话可以这样 npm install -g react 至此，我们还不能实现react的正常输出，我们还需要通过webpack来打包。 webpack 的安装 在安装webpack之前，先了解下react的写作流程：先在项目文件里建立一个src文件夹在里面建一个index.js文件 这个文件要传到外面的文件index.html。index.js里这样写： 12345678910var React = require(\"react\");var ReactDOM = require(\"react-dom\");class Index extends React.Component &#123; render() &#123; return( &lt;h1&gt;hello world&lt;/h1&gt; document.getElementById('example') ); &#125;&#125; index.html里这样写：12&lt;div id=\"example\"&gt;123&lt;/div&gt;&lt;script src=\"./src/bundle.js\"&gt;&lt;/script&gt; 这里引入的bundle.js 就是webpack 生成的，他是把我们之前写的index.js生成了浏览器能识别的js文件，这样才能被浏览器识别。 webpack正式安装首先定义一个webpack的配置文件：webpack config.js 通过官方文档来配置。安装：全局安装一下：12npm install -g webpacknpm install -g webpack-dev-server //服务器 项目目录里安装一下：12npm install webpack --savenpm install webpack-dev-server --save //服务器 注： 一定要注意版本的问题，要和react等合适，如果都是最新的应该没问题。 下面来运行： webpack //在命令行执行就会把我们的index.js生成可识别的js文件了。 怎样自动加载呢： webpack-dev-server --contentbase -src --inline //执行后就可以自动加载了","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"react系列文章","slug":"技术/react系列文章","permalink":"http://yoursite.com/categories/技术/react系列文章/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"node.js 入门系列","slug":"node学习","date":"2018-06-23T09:31:49.699Z","updated":"2018-06-25T02:46:42.258Z","comments":true,"path":"2018/06/23/node学习/","link":"","permalink":"http://yoursite.com/2018/06/23/node学习/","excerpt":"一、搭建node.js开发环境二、模块使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。","text":"一、搭建node.js开发环境二、模块使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。在上一节，我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。 我们把hello.js改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数： 123456789'use strict';var s = 'Hello';function greet(name) &#123; console.log(s + ', ' + name + '!');&#125;module.exports = greet; 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。 问题是其他模块怎么使用hello模块的这个greet函数呢？我们再编写一个main.js文件，调用hello模块的greet函数： 12345678'use strict';// 引入hello模块:var greet = require('./hello');var s = 'Michael';greet(s); // Hello, Michael! 注意到引入hello模块用Node提供的require函数： var greet = require(‘./hello’); 引入的模块作为变量保存在greet变量中，那greet变量到底是什么东西？其实变量greet就是在hello.js中我们用module.exports = greet;输出的greet函数。所以，main.js就成功地引用了hello.js模块中定义的greet()函数，接下来就可以直接使用它了。 在使用require()引入模块的时候，请注意模块的相对路径。因为main.js和hello.js位于同一个目录，所以我们用了当前目录.： var greet = require(‘./hello’); // 不要忘了写相对目录! CommonJS规范这种模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，hello.js和main.js都申明了全局变量var s = ‘xxx’，但互不影响。 一个模块想要对外暴露变量（函数也是变量），可以用module.exports = variable;，一个模块要引用其他模块暴露的变量，用var ref = require(‘module_name’);就拿到了引用模块的变量。 三、深入了解模块原理其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。 请注意我们编写的hello.js代码是这样的：1234var s = 'Hello';var name = 'world';console.log(s + ' ' + name + '!'); Node.js加载了hello.js后，它可以把代码包装一下，变成这样执行： 12345678(function () &#123; // 读取的hello.js代码: var s = 'Hello'; var name = 'world'; console.log(s + ' ' + name + '!'); // hello.js代码结束&#125;)(); 这样一来，原来的全局变量s现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义的“全局”变量s也互不干扰。 所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。 但是，模块的输出module.exports怎么实现？ 这个也很容易实现，Node可以先准备一个对象module： 123456789101112131415161718// 准备module对象:var module = &#123; id: 'hello', exports: &#123;&#125;&#125;;var load = function (module) &#123; // 读取的hello.js代码: function greet(name) &#123; console.log('Hello, ' + name + '!'); &#125; module.exports = greet; // hello.js代码结束 return module.exports;&#125;;var exported = load(module);// 保存module:save(module, exported); 可见，变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在hello.js中可以直接使用变量module原因就在于它实际上是函数的一个参数： module.exports = greet;通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。 由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出： var greet = require(‘./hello’); 四、基本模块4.1 global在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫window对象。而在Node.js环境中，也有唯一的全局对象，但不叫window，而叫global，这个对象的属性和方法也和浏览器环境的window不同。 4.2 processprocess也是Node.js提供的一个对象，它代表当前Node.js进程。通过process对象可以拿到许多有用信息： 4.3 fs基本模块Node.js内置的fs模块就是文件系统模块，负责读写文件。 和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。 异步读文件按照JavaScript的标准，异步读取一个文本文件的代码如下： 1234567891011'use strict';var fs = require('fs');fs.readFile('sample.txt', 'utf-8', function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。 如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？ 下面的例子演示了如何读取一个图片文件： 123456789101112'use strict';var fs = require('fs');fs.readFile('sample.png', function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + ' bytes'); &#125;&#125;); 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。 Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String：123// Buffer -&gt; Stringvar text = data.toString('utf-8');console.log(text); 或者把一个String转换成Buffer： 123// String -&gt; Buffervar buf = Buffer.from(text, 'utf-8');console.log(buf); 写文件将数据写入文件是通过fs.writeFile()实现的： 123456789101112'use strict';var fs = require('fs');var data = 'Hello, Node.js';fs.writeFile('output.txt', data, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('ok.'); &#125;&#125;); writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。 stat如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息： 12345678910111213141516171819202122'use strict';var fs = require('fs');fs.stat('sample.txt', function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log('isFile: ' + stat.isFile()); // 是否是目录: console.log('isDirectory: ' + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log('size: ' + stat.size); // 创建时间, Date对象: console.log('birth time: ' + stat.birthtime); // 修改时间, Date对象: console.log('modified time: ' + stat.mtime); &#125; &#125;&#125;); stream模块stream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。 什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。 如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。 有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。 在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。 下面是一个从文件流读取文本内容的示例： 1234567891011121314151617181920'use strict';var fs = require('fs');// 打开一个流:var rs = fs.createReadStream('sample.txt', 'utf-8');rs.on('data', function (chunk) &#123; console.log('DATA:') console.log(chunk);&#125;);rs.on('end', function () &#123; console.log('END');&#125;);rs.on('error', function (err) &#123; console.log('ERROR: ' + err);&#125;); 要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。 要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束：12345678910111213'use strict';var fs = require('fs');var ws1 = fs.createWriteStream('output1.txt', 'utf-8');ws1.write('使用Stream写入文本数据...\\n');ws1.write('END.');ws1.end();var ws2 = fs.createWriteStream('output2.txt');ws2.write(new Buffer('使用Stream写入二进制数据...\\n', 'utf-8'));ws2.write(new Buffer('END.', 'utf-8'));ws2.end(); 所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。 pipe就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。 在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。 让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：12345678'use strict';var fs = require('fs');var rs = fs.createReadStream('sample.txt');var ws = fs.createWriteStream('copied.txt');rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： readable.pipe(writable, { end: false }); http模块HTTP服务器要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。 request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息； response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!： 1234567891011121314151617181920'use strict';// 导入http模块:var http = require('http');// 创建http server，并传入回调函数:var server = http.createServer(function (request, response) &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(request.method + ': ' + request.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 将HTTP响应的HTML内容写入response: response.end('&lt;h1&gt;Hello world!&lt;/h1&gt;');&#125;);// 让服务器监听8080端口:server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); 在命令提示符下运行该程序，可以看到以下输出： $ node hello.jsServer is running at http://127.0.0.1:8080/ 文件服务器让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。 解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象： 12345678910111213141516171819202122232425'use strict';var url = require('url');console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));``` 结果如下：```jsUrl &#123; protocol: 'http:', slashes: true, auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/path/to/file', path: '/path/to/file?query=string', href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' &#125; 处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960'use strict';var path = require('path');// 解析当前目录:var workDir = path.resolve('.'); // '/Users/michael'// 组合完整的文件路径:当前目录+'pub'+'index.html':var filePath = path.join(workDir, 'pub', 'index.html');// '/Users/michael/pub/index.html'``` 使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于C:\\Users\\michael\\static\\index.html，这样，我们就不关心怎么拼接路径了。最后，我们实现一个文件服务器file_server.js：```js'use strict';var fs = require('fs'), url = require('url'), path = require('path'), http = require('http');// 从命令行参数获取root目录，默认是当前目录:var root = path.resolve(process.argv[2] || '.');console.log('Static root dir: ' + root);// 创建服务器:var server = http.createServer(function (request, response) &#123; // 获得URL的path，类似 '/css/bootstrap.css': var pathname = url.parse(request.url).pathname; // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css': var filepath = path.join(root, pathname); // 获取文件状态: fs.stat(filepath, function (err, stats) &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在: console.log('200 ' + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filepath).pipe(response); &#125; else &#123; // 出错了或者文件不存在: console.log('404 ' + request.url); // 发送404响应: response.writeHead(404); response.end('404 Not Found'); &#125; &#125;);&#125;);server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); crypto模块crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。 MD5和SHA1MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示： 123456789const crypto = require('crypto');const hash = crypto.createHash('md5');// 可任意多次调用update():hash.update('Hello, world!');hash.update('Hello, nodejs!');console.log(hash.digest('hex')); // 7e1977739c748beac0c0fd14fd26a544 update()方法默认字符串编码为UTF-8，也可以传入Buffer。 如果要计算SHA1，只需要把’md5’改成’sha1’，就可以得到SHA1的结果1f32b9c9932c02227819a4151feed43e131aca40。 还可以使用更安全的sha256和sha512。 HmacHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥： 123456789const crypto = require('crypto');const hmac = crypto.createHmac('sha256', 'secret-key');hmac.update('Hello, world!');hmac.update('Hello, nodejs!');console.log(hmac.digest('hex')); // 80f7e22570... 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"node.js","slug":"技术/node-js","permalink":"http://yoursite.com/categories/技术/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]},{"title":"JS Map 和 Set","slug":"JS系列Map和Set","date":"2018-06-23T09:31:49.685Z","updated":"2018-06-15T01:14:22.249Z","comments":true,"path":"2018/06/23/JS系列Map和Set/","link":"","permalink":"http://yoursite.com/2018/06/23/JS系列Map和Set/","excerpt":"MapJavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。 为了解决这个问题，最新的ES6规范引入了新的数据类型Map。 Map是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85];","text":"MapJavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。 为了解决这个问题，最新的ES6规范引入了新的数据类型Map。 Map是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 注意数字3和字符串’3’是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素：1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for … of循环来遍历。 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： 123456789'use strict';var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"Map和Set","slug":"技术/JavaScript/Map和Set","permalink":"http://yoursite.com/categories/技术/JavaScript/Map和Set/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Map和Set","slug":"Map和Set","permalink":"http://yoursite.com/tags/Map和Set/"}]},{"title":"JS条件判断和循环","slug":"JS系列3","date":"2018-06-23T09:31:49.675Z","updated":"2018-06-15T01:00:48.804Z","comments":true,"path":"2018/06/23/JS系列3/","link":"","permalink":"http://yoursite.com/2018/06/23/JS系列3/","excerpt":"条件判断JavaScript使用if () { … } else { … }来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下： 多行条件判断如果还要更细致地判断条件，可以使用多个if…else…的组合： 12345678var age = 3;if (age &gt;= 18) &#123; alert('adult');&#125; else if (age &gt;= 6) &#123; alert('teenager');&#125; else &#123; alert('kid');&#125;","text":"条件判断JavaScript使用if () { … } else { … }来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下： 多行条件判断如果还要更细致地判断条件，可以使用多个if…else…的组合： 12345678var age = 3;if (age &gt;= 18) &#123; alert('adult');&#125; else if (age &gt;= 6) &#123; alert('teenager');&#125; else &#123; alert('kid');&#125; 循环计算1+2+3，我们可以直接写表达式： 1 + 2 + 3; // 6要计算1+2+3+…+10，勉强也能写出来。 但是，要计算1+2+3+…+10000，直接写表达式就不可能了。 为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。 JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块： 123456var x = 0;var i;for (i=1; i&lt;=10000; i++) &#123; x = x + i;&#125;x; // 50005000 for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环： for … infor循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来： 12345678var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; console.log(key); // 'name', 'age', 'city'&#125; 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for … in循环可以直接循环出Array的索引： 12345var a = ['A', 'B', 'C'];for (var i in a) &#123; console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'&#125; 请注意，for … in对Array的循环得到的是String而不是Number。 whilefor循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的for循环容易让人看不清循环的逻辑，此时用while循环更佳。 while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：1234567var x = 0;var n = 99;while (n &gt; 0) &#123; x = x + n; n = n - 2;&#125;x; // 2500 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 do … while最后一种循环是do { … } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件： 12345var n = 0;do &#123; n = n + 1;&#125; while (n &lt; 100);n; // 100","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"条件判断和循环","slug":"技术/JavaScript/条件判断和循环","permalink":"http://yoursite.com/categories/技术/JavaScript/条件判断和循环/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"条件判断和循环","slug":"条件判断和循环","permalink":"http://yoursite.com/tags/条件判断和循环/"}]},{"title":"JS数据类型和变量","slug":"JS系列2","date":"2018-06-23T09:31:49.662Z","updated":"2018-06-15T00:33:40.459Z","comments":true,"path":"2018/06/23/JS系列2/","link":"","permalink":"http://yoursite.com/2018/06/23/JS系列2/","excerpt":"NumberJavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型： 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity","text":"NumberJavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型： 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。 如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。 如果字符串内部既包含’又包含”怎么办？可以用转义字符\\来标识，比如： 1'I\\'m \\\"OK\\\"!'; 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\表示的字符就是\\。 多行字符串由于多行字符串用\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ... 表示： 要把多个字符串连接起来，可以用+号连接 要把多个字符串连接起来，可以用+号连接： 1234var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 操作字符串1、 .length2、 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始： 1234567var s = 'Hello, world!';s[0]; // 'H's[6]; // ' 's[7]; // 'w's[12]; // '!'s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 3、 toUpperCase toLowerCase 4、 indexOf indexOf()会搜索指定字符串出现的位置： 123var s = 'hello, world';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1 5、 substring substring()返回指定索引区间的子串： 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值，要么是true，要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来： 1234true; // 这是一个true值false; // 这是一个false值2 &gt; 1; // 这是一个true值2 &gt;= 3; // 这是一个false值 比较运算符当我们对Number做比较时，可以通过比较运算符得到一个布尔值： 1232 &gt; 5; // false5 &gt;= 2; // true7 == 7; // true 实际上，JavaScript允许对任意数据类型做比较： 12false == 0; // truefalse === 0; // false 要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： 1NaN === NaN; // false 最后要注意浮点数的相等比较： 11 / 3 === (1 - 2 / 3); // false 浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true null和undefinednull表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。 在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：1[1, 2, 3.14, &apos;Hello&apos;, null, true]; 数组的元素可以通过索引来访问。请注意，索引的起始值为0： 1234var arr = [1, 2, 3.14, 'Hello', null, true];arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined 操作数组indexOf与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： 12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 注意了，数字30和字符串’30’是不同的元素。 sliceslice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false push和poppush()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift和shift如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： sortsort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] reversereverse()把整个Array的元素给掉个个，也就是反转： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splicesplice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concatconcat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] joinjoin()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 多维数组如果数组的某个元素又是一个Array，则可以形成多维数组，例如： 1var arr = [[1, 2, 3], [400, 500, 600], '-']; 上述Array包含3个元素，其中头两个元素本身也是Array。 对象JavaScript的对象是一组由键-值组成的无序集合，例如： 12345678var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;; 要获取一个对象的属性，我们用对象变量.属性名的方式： 12person.name; // 'Bob'person.zipcode; // null 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如： 12345var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = '007'; // s_007是一个字符串var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null strict模式JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：1i = 10; // i现在是全局变量","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"http://yoursite.com/categories/技术/JavaScript/"},{"name":"数据类型和变量","slug":"技术/JavaScript/数据类型和变量","permalink":"http://yoursite.com/categories/技术/JavaScript/数据类型和变量/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"数据类型和变量","slug":"数据类型和变量","permalink":"http://yoursite.com/tags/数据类型和变量/"}]},{"title":"JS-AJAX","slug":"JS-AJAX","date":"2018-06-23T09:31:49.645Z","updated":"2018-06-20T07:44:17.204Z","comments":true,"path":"2018/06/23/JS-AJAX/","link":"","permalink":"http://yoursite.com/2018/06/23/JS-AJAX/","excerpt":"","text":"如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。 这就是Web的运作原理：一次HTTP请求对应一个页面。 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象： 1234567891011121314151617181920212223242526272829303132function success(text) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = text;&#125;function fail(code) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code;&#125;var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。 XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 安全限制上面代码的URL使用的是相对路径。如果你把它改为’http://www.sina.com.cn/&#39;，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。 这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。 完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。 那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的: 第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JS-AJAX","slug":"技术/JS-AJAX","permalink":"http://yoursite.com/categories/技术/JS-AJAX/"}],"tags":[{"name":"JS-AJAX","slug":"JS-AJAX","permalink":"http://yoursite.com/tags/JS-AJAX/"}]},{"title":"jQuery动画","slug":"jQuery4","date":"2018-06-23T09:31:49.632Z","updated":"2018-06-20T07:11:38.801Z","comments":true,"path":"2018/06/23/jQuery4/","link":"","permalink":"http://yoursite.com/2018/06/23/jQuery4/","excerpt":"show / hide直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画： toggle()方法则根据当前状态决定是show()还是hide()。 slideUp / slideDownshow()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的。 slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作。","text":"show / hide直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画： toggle()方法则根据当前状态决定是show()还是hide()。 slideUp / slideDownshow()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的。 slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作。 fadeIn / fadeOutfadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断设置DOM元素的opacity属性来实现，而fadeToggle()则根据元素是否可见来决定下一步动作 自定义动画animate()，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值： 123456var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000); // 在3秒钟内CSS过渡到设定值 animate()还可以再传入一个函数，当动画结束时，该函数将被调用： 12345678910var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000, function () &#123; console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');&#125;); 串行动画jQuery的动画效果还可以串行执行，通过delay()方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单： 123456789101112131415var div = $('#test-animates');// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小div.slideDown(2000) .delay(1000) .animate(&#123; width: '256px', height: '256px' &#125;, 2000) .delay(1000) .animate(&#123; width: '128px', height: '128px' &#125;, 2000);&#125;&lt;/script&gt; 为什么有的动画没有效果你可能会遇到，有的动画如slideUp()根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如height从100px逐渐变为0。但是很多不是block性质的DOM元素，对它们设置height根本就不起作用，所以动画也就没有效果。 此外，jQuery也没有实现对background-color的动画效果，用animate()设置background-color也没有效果。这种情况下可以使用CSS3的transition实现动画效果。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"jQuery动画","slug":"技术/jQuery动画","permalink":"http://yoursite.com/categories/技术/jQuery动画/"}],"tags":[{"name":"jQuery动画","slug":"jQuery动画","permalink":"http://yoursite.com/tags/jQuery动画/"}]},{"title":"jQuery事件","slug":"jQuery3","date":"2018-06-23T09:31:49.617Z","updated":"2018-06-20T00:06:22.551Z","comments":true,"path":"2018/06/23/jQuery3/","link":"","permalink":"http://yoursite.com/2018/06/23/jQuery3/","excerpt":"jQuery能够绑定的事件主要包括：鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。","text":"jQuery能够绑定的事件主要包括：鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件键盘事件仅作用在当前焦点的DOM上，通常是 &lt;input&gt; 和 &lt;textarea&gt; 。 keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 其他事件 focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发； submit：当&lt;form&gt;提交时触发； ready：当页面被载入并且DOM树完成初始化后触发。 其中，ready仅作用于document对象。由于ready事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。 因为JavaScript在此执行的时候，&lt;form&gt;尚未载入浏览器，所以$(‘#testForm)返回[]，并没有绑定事件到任何DOM上。 所以我们自己的初始化代码必须放到document对象的ready事件中，保证DOM已完成初始化： 12345$(document).on('ready', function () &#123; $('#testForm).on('submit', function () &#123; alert('submit!'); &#125;); &#125;); 由于ready事件使用非常普遍，所以可以这样简化：123456$(document).ready(function () &#123; // on('submit', function)也可以简化: $('#testForm).submit(function () &#123; alert('submit!'); &#125;);&#125;); 甚至还可以再简化为：123$(function () &#123; // init...&#125;); 上面的这种写法最为常见。如果你遇到$(function () {…})的形式，牢记这是document对象的ready事件处理函数。 事件参数有些事件，如mousemove和keypress，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入Event对象作为参数，可以从Event对象上获取到更多的信息：12345$(function () &#123; $('#testMouseMoveDiv').mousemove(function (e) &#123; $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); &#125;);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"jQuery事件","slug":"技术/jQuery事件","permalink":"http://yoursite.com/categories/技术/jQuery事件/"}],"tags":[{"name":"jQuery事件","slug":"jQuery事件","permalink":"http://yoursite.com/tags/jQuery事件/"}]},{"title":"jQuery操作DOM","slug":"jQuery2","date":"2018-06-23T09:31:49.602Z","updated":"2018-06-19T06:56:10.980Z","comments":true,"path":"2018/06/23/jQuery2/","link":"","permalink":"http://yoursite.com/2018/06/23/jQuery2/","excerpt":"一、修改Text和HTMLjQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构： 12345&lt;!-- HTML结构 --&gt;&lt;ul id=\"test-ul\"&gt; &lt;li class=\"js\"&gt;JavaScript&lt;/li&gt; &lt;li name=\"book\"&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 分别获取文本和HTML：12$('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript'$('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript' 如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作。","text":"一、修改Text和HTMLjQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构： 12345&lt;!-- HTML结构 --&gt;&lt;ul id=\"test-ul\"&gt; &lt;li class=\"js\"&gt;JavaScript&lt;/li&gt; &lt;li name=\"book\"&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 分别获取文本和HTML：12$('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript'$('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript' 如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作。 修改CSSjQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构 12345678&lt;!-- HTML结构 --&gt;&lt;ul id=\"test-css\"&gt; &lt;li class=\"lang dy\"&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang\"&gt;&lt;span&gt;Java&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang dy\"&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang\"&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;li class=\"lang dy\"&gt;&lt;span&gt;Scheme&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; 要高亮显示动态语言，调用jQuery对象的css(‘name’, ‘value’)方法，我们用一行语句实现： $(‘#test-css li.dy&gt;span’).css(‘background-color’, ‘#ffd351’).css(‘color’, ‘red’); 为了和JavaScript保持一致，CSS属性可以用’background-color’和’backgroundColor’两种格式。 css()方法将作用于DOM节点的style属性，具有最高优先级。如果要修改class属性，可以用jQuery提供的下列方法： 1234var div = $('#test-div');div.hasClass('highlight'); // false， class是否包含highlightdiv.addClass('highlight'); // 添加highlight这个classdiv.removeClass('highlight'); // 删除highlight这个class 显示和隐藏DOM要隐藏一个DOM，我们可以设置CSS的display属性为none，利用css()方法就可以实现。不过，要显示这个DOM就需要恢复原有的display属性，这就得先记下来原有的display属性到底是block还是inline还是别的值。 考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供show()和hide()方法，我们不用关心它是如何修改display属性的，总之它能正常工作： var a = $(‘a[target=_blank]’);a.hide(); // 隐藏a.show(); // 显示 隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。 获取DOM信息利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码： 1234567891011121314// 浏览器可视窗口大小:$(window).width(); // 800$(window).height(); // 600// HTML文档大小:$(document).width(); // 800$(document).height(); // 3500// 某个div的大小:var div = $('#test-div');div.width(); // 600div.height(); // 300div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效 attr()和removeAttr()方法用于操作DOM节点的属性： // …var div = $(‘#test-div’);div.attr(‘data’); // undefined, 属性不存在div.attr(‘name’); // ‘Test’div.attr(‘name’, ‘Hello’); // div的name属性变为’Hello’div.removeAttr(‘name’); // 删除name属性div.attr(‘name’); // undefined 操作表单对于表单元素，jQuery对象统一提供val()方法获取和设置对应的value属性： 12345678910111213141516171819202122/* &lt;input id=\"test-input\" name=\"email\" value=\"\"&gt; &lt;select id=\"test-select\" name=\"city\"&gt; &lt;option value=\"BJ\" selected&gt;Beijing&lt;/option&gt; &lt;option value=\"SH\"&gt;Shanghai&lt;/option&gt; &lt;option value=\"SZ\"&gt;Shenzhen&lt;/option&gt; &lt;/select&gt; &lt;textarea id=\"test-textarea\"&gt;Hello&lt;/textarea&gt;*/var input = $('#test-input'), select = $('#test-select'), textarea = $('#test-textarea');input.val(); // 'test'input.val('abc@example.com'); // 文本框的内容已变为abc@example.comselect.val(); // 'BJ'select.val('SH'); // 选择框已变为Shanghaitextarea.val(); // 'Hello'textarea.val('Hi'); // 文本区域已更新为'Hi' 修改DOM要添加新的DOM节点，除了通过jQuery的html()这种暴力方法外，还可以用append()方法，例如：1234567&lt;div id=\"test-div\"&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如何向列表新增一个语言？首先要拿到节点： var ul = $(‘#test-div&gt;ul’); 然后，调用append()传入HTML片段：1ul.append('&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'); 除了接受字符串，append()还可以传入原始的DOM对象，jQuery对象和函数对象： append()把DOM添加到最后，prepend()则把DOM添加到最前。 删除节点要删除DOM节点，拿到jQuery对象后直接调用remove()方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点： var li = $(‘#test-div&gt;ul&gt;li’);li.remove(); // 所有全被删除","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"jQuery操作DOM","slug":"技术/jQuery操作DOM","permalink":"http://yoursite.com/categories/技术/jQuery操作DOM/"}],"tags":[{"name":"jQuery操作DOM","slug":"jQuery操作DOM","permalink":"http://yoursite.com/tags/jQuery操作DOM/"}]},{"title":"jQuery选择器","slug":"jQuery","date":"2018-06-23T09:31:49.586Z","updated":"2018-06-19T05:48:52.691Z","comments":true,"path":"2018/06/23/jQuery/","link":"","permalink":"http://yoursite.com/2018/06/23/jQuery/","excerpt":"一、选择器按ID查找// 查找:var div = $(‘#abc’); #abc以#开头。返回的对象是jQuery对象。 什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。 以上面的查找为例，如果id为abc的存在，返回的jQuery对象如下： […] 如果id为abc的不存在，返回的jQuery对象如下： []","text":"一、选择器按ID查找// 查找:var div = $(‘#abc’); #abc以#开头。返回的对象是jQuery对象。 什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。 以上面的查找为例，如果id为abc的存在，返回的jQuery对象如下： […] 如果id为abc的不存在，返回的jQuery对象如下： [] 按tag查找按tag查找只需要写上tag名称就可以了： var ps = $(‘p’); // 返回所有节点ps.length; // 数一数页面有多少个节点 按class查找按class查找注意在class名称前加一个.： var a = $(‘.red’); // 所有节点包含class=&quot;red&quot;都将返回// 例如:// …// … 通常很多节点有多个class，我们可以查找同时包含red和green的节点： var a = $(‘.red.green’); // 注意没有空格！// 符合条件的节点：// …// … 按属性查找一个DOM节点除了id和class外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找： var email = $(‘[name=email]’); // 找出&lt;??? name=”email”&gt;var passwordInput = $(‘[type=password]’); // 找出&lt;??? type=”password”&gt;var a = $(‘[items=”A B”]’); // 找出&lt;??? items=”A B”&gt; 当属性的值包含空格等特殊字符时，需要用双引号括起来。 按属性查找还可以使用前缀查找或者后缀查找： var icons = $(‘[name^=icon]’); // 找出所有name属性值以icon开头的DOM// 例如: name=”icon-1”, name=”icon-2”var names = $(‘[name$=with]’); // 找出所有name属性值以with结尾的DOM// 例如: name=”startswith”, name=”endswith”这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响： var icons = $(‘[class^=”icon-“]’); // 找出所有class包含至少一个以icon-开头的DOM// 例如: class=”icon-clock”, class=”abc icon-home” 组合查找组合查找就是把上述简单选择器组合起来使用。如果我们查找$(‘[name=email]’)，很可能把表单外的也找出来，但我们只希望查找，就可以这么写： var emailInput = $(‘input[name=email]’); // 不会找出 同样的，根据tag和class来组合查找也很常见： var tr = $(‘tr.red’); // 找出… 多项选择器多项选择器就是把多个选择器用,组合起来一块选：$(‘p,div’); // 把和都选出来$(‘p.red,p.green’); // 把和都选出来 层级选择器（Descendant Selector）如果两个DOM元素具有层级关系，就可以用$(‘ancestor descendant’)来选择，层级之间用空格隔开。 子选择器（Child Selector）子选择器$(‘parent&gt;child’)类似层级选择器，但是限定了层级关系必须是父子关系，就是节点必须是节点的直属子节点。 过滤器（Filter）过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果： 1234567$('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点$('ul.lang li:first-child'); // 仅选出JavaScript$('ul.lang li:last-child'); // 仅选出Lua$('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始$('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素 表单相关针对表单元素，jQuery还有一组特殊的选择器： :input：可以选择，，和； :file：可以选择，和input[type=file]一样； :checkbox：可以选择复选框，和input[type=checkbox]一样； :radio：可以选择单选框，和input[type=radio]一样； :focus：可以选择当前输入焦点的元素，例如把光标放到一个上，用$(‘input:focus’)就可以选出； :checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$(‘input[type=radio]- :checked’)； :enabled：可以选择可以正常输入的、等，也就是没有灰掉的输入； :disabled：和:enabled正好相反，选择那些不能输入的。 查找和过滤通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。 最常见的查找是在某个节点的所有子节点中查找，使用find()方法，它本身又接收一个任意的选择器。 12345678&lt;!-- HTML结构 --&gt;&lt;ul class=\"lang\"&gt; &lt;li class=\"js dy\"&gt;JavaScript&lt;/li&gt; &lt;li class=\"dy\"&gt;Python&lt;/li&gt; &lt;li id=\"swift\"&gt;Swift&lt;/li&gt; &lt;li class=\"dy\"&gt;Scheme&lt;/li&gt; &lt;li name=\"haskell\"&gt;Haskell&lt;/li&gt;&lt;/ul&gt; 用find()查找：1234var ul = $('ul.lang'); // 获得&lt;ul&gt;var dy = ul.find('.dy'); // 获得JavaScript, Python, Schemevar swf = ul.find('#swift'); // 获得Swiftvar hsk = ul.find('[name=haskell]'); // 获得Haskell 如果要从当前节点开始向上查找，使用parent()方法; 对于位于同一层级的节点，可以通过next()和prev()方法; 过滤和函数式编程的map、filter类似，jQuery对象也有类似的方法。 filter()方法可以过滤掉不符合选择器条件的节点： var langs = $(‘ul.lang li’); // 拿到JavaScript, Python, Swift, Scheme和Haskellvar a = langs.filter(‘.dy’); // 拿到JavaScript, Python, Scheme","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"jQuery选择器","slug":"技术/jQuery选择器","permalink":"http://yoursite.com/categories/技术/jQuery选择器/"}],"tags":[{"name":"jQuery选择器","slug":"jQuery选择器","permalink":"http://yoursite.com/tags/jQuery选择器/"}]},{"title":"jQuery-AJAX","slug":"jQuery-AJAX","date":"2018-06-23T09:31:49.553Z","updated":"2018-06-20T07:28:29.394Z","comments":true,"path":"2018/06/23/jQuery-AJAX/","link":"","permalink":"http://yoursite.com/2018/06/23/jQuery-AJAX/","excerpt":"jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求。ajax(url, settings)函数需要接收一个URL和一个可选的settings对象，常用的选项如下： async：是否异步执行AJAX请求，默认为true，千万不要指定为false； method：发送的Method，缺省为’GET’，可指定为’POST’、’PUT’等； contentType：发送POST请求的格式，默认值为’application/x-www-form-urlencoded; charset=UTF-8’，也可以指定为text/plain、- application/json； data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据- contentType把data序列化成合适的格式； headers：发送的额外的HTTP头，必须是一个object； dataType：接收的数据格式，可以指定为’html’、’xml’、’json’、’text’等，缺省情况下根据响应的Content-Type猜测。 下面的例子发送一个GET请求，并返回一个JSON格式的数据：","text":"jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求。ajax(url, settings)函数需要接收一个URL和一个可选的settings对象，常用的选项如下： async：是否异步执行AJAX请求，默认为true，千万不要指定为false； method：发送的Method，缺省为’GET’，可指定为’POST’、’PUT’等； contentType：发送POST请求的格式，默认值为’application/x-www-form-urlencoded; charset=UTF-8’，也可以指定为text/plain、- application/json； data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据- contentType把data序列化成合适的格式； headers：发送的额外的HTTP头，必须是一个object； dataType：接收的数据格式，可以指定为’html’、’xml’、’json’、’text’等，缺省情况下根据响应的Content-Type猜测。 下面的例子发送一个GET请求，并返回一个JSON格式的数据： 1234var jqxhr = $.ajax('/api/categories', &#123; dataType: 'json'&#125;);// 请求已经发送了 不过，如何用回调函数处理返回的数据和出错时的响应呢？ 还记得Promise对象吗？jQuery的jqXHR对象类似一个Promise对象，我们可以用链式写法来处理各种回调： 12345678910111213141516171819'use strict';function ajaxLog(s) &#123; var txt = $('#test-response-text'); txt.val(txt.val() + '\\n' + s);&#125;$('#test-response-text').val('');var jqxhr = $.ajax('/api/categories', &#123; dataType: 'json'&#125;).done(function (data) &#123; ajaxLog('成功, 收到的数据: ' + JSON.stringify(data));&#125;).fail(function (xhr, status) &#123; ajaxLog('失败: ' + xhr.status + ', 原因: ' + status);&#125;).always(function () &#123; ajaxLog('请求完成: 无论成功或失败都会调用');&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"jQuery-AJAX","slug":"技术/jQuery-AJAX","permalink":"http://yoursite.com/categories/技术/jQuery-AJAX/"}],"tags":[{"name":"jQuery-AJAX","slug":"jQuery-AJAX","permalink":"http://yoursite.com/tags/jQuery-AJAX/"}]},{"title":"JavaScript 基础知识总结","slug":"javaScript系列文章","date":"2018-06-23T09:31:49.547Z","updated":"2018-06-12T12:35:07.912Z","comments":true,"path":"2018/06/23/javaScript系列文章/","link":"","permalink":"http://yoursite.com/2018/06/23/javaScript系列文章/","excerpt":"本文主要是一些基础性的知识回顾，后续吧深入理解的东西发表出来。现在先学习基础性的东西吧。 下面是我总结的一些思维导图：","text":"本文主要是一些基础性的知识回顾，后续吧深入理解的东西发表出来。现在先学习基础性的东西吧。 下面是我总结的一些思维导图：","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"JavaScript系列文章","slug":"技术/JavaScript系列文章","permalink":"http://yoursite.com/categories/技术/JavaScript系列文章/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS布局知识","slug":"css布局","date":"2018-06-23T09:31:49.525Z","updated":"2018-06-20T00:10:13.244Z","comments":true,"path":"2018/06/23/css布局/","link":"","permalink":"http://yoursite.com/2018/06/23/css布局/","excerpt":"display设置元素的显示方式 display 默认宽度 可设置宽高 起始位置 block 父元素宽度 是 换行 inline 内容宽度 否 同行 inline-block 内容宽度 是 同行","text":"display设置元素的显示方式 display 默认宽度 可设置宽高 起始位置 block 父元素宽度 是 换行 inline 内容宽度 否 同行 inline-block 内容宽度 是 同行 display:block默认为block的元素：, , ~ , , display:inline默认为inline的元素：, , , , display:inline-block默认为inline-block的元素：&lt;input&gt;, &lt;textarea&gt;, &lt;select&gt;, &lt;button&gt; display:none设置元素不显示 display:none 与 visibility:hidden 的区别为 display:none 不显示且不占位，但 visibility:hidden 不显示但占位。 positionposition 用于设置定位的方式与top right bottom left z-index 则用于设置参照物位置（必须配合定位一同使用）。 三种定位形式 静态定位（static） 相对定位（relative） 绝对定位（absolute、fixed） position:relative相对定位的元素仍在文档流之中，并按照文档流中的顺序进行排列。参照物为元素本身的位置。 最常用的目的为改变元素层级和设置为绝对定位的参照物 position:absolute建立以包含块为基准的定位，其随即拥有偏移属性和 z-index 属性。 默认宽度为内容宽度 脱离文档流 参照物为第一个定位祖先或根元素（ 元素） position:fixed 默认宽度为内容宽度 脱离文档流 参照物为视窗 z-index其用于设置 Z 轴上得排序，默认值为 0 但可设置为负值。（如不做设置，则按照文档流的顺序排列。后面的元素将置于前面的元素之上） floatCSS 中规定的定位机制，其可实现块级元素同行显示并存在于文档流之中。浮动仅仅影响文档流中下一个紧邻的元素。 clearclear: both | left | right | none | inherit 应用于后续元素 应用于块级元素（block） 使用方法： 优先级自上而下 clearfix 于父元素 浮动后续空白元素 .emptyDiv {clear: both} 为受到影响的元素设置 width: 100% overflow: hidden 也可 块级元素可以使用 不建议使用，影响 HTML 结构 flex专门文章介绍了，在这里不做介绍。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"css布局","slug":"技术/css布局","permalink":"http://yoursite.com/categories/技术/css布局/"}],"tags":[{"name":"css布局","slug":"css布局","permalink":"http://yoursite.com/tags/css布局/"}]},{"title":"CSS 实现各种居中","slug":"CSS实现各种居中方法","date":"2018-06-23T09:31:49.501Z","updated":"2018-06-14T14:15:55.931Z","comments":true,"path":"2018/06/23/CSS实现各种居中方法/","link":"","permalink":"http://yoursite.com/2018/06/23/CSS实现各种居中方法/","excerpt":"一、水平居中1、行内元素居中 顾名思义，行内元素居中是只针对行内元素的，比如文本（text）、图片（img）、按钮等行内元素，可通过给父元素设置 text-align:center 来实现。另外，如果块状元素属性display 被设置为inline时，也是可以使用这种方法。但有个首要条件是子元素必须没有被float影响，否则一切都是无用功。 1234 .div1&#123; text-align:center; &#125;&lt;div class=\"div1\"&gt;Hello world&lt;/div&gt;","text":"一、水平居中1、行内元素居中 顾名思义，行内元素居中是只针对行内元素的，比如文本（text）、图片（img）、按钮等行内元素，可通过给父元素设置 text-align:center 来实现。另外，如果块状元素属性display 被设置为inline时，也是可以使用这种方法。但有个首要条件是子元素必须没有被float影响，否则一切都是无用功。 1234 .div1&#123; text-align:center; &#125;&lt;div class=\"div1\"&gt;Hello world&lt;/div&gt; 2、块状元素居中（1）、定宽块状元素居中 满足定宽（块状元素的宽度width为固定值）和块状两个条件的元素可以通过设置“左右margin”值为“auto”来实现居中。 123456 .div1&#123; width:200px; border:1px solid red; margin:0 auto; &#125;&lt;div class=\"div1\"&gt;Hello world&lt;/div&gt; （2）、不定宽块状元素居中在实际工作中我们会遇到需要为“不定宽度的块状元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。(不定宽块状元素：块状元素的宽度width不固定。) 有三种方法可以对不定宽块状元素进行居中： 方法1： 将要显示的元素加入到 table 标签当中，然后为 table 标签设置“左右margin”值为“auto”来实现居中； 或使用 display : table；然后设该元素“左右margin”值为“auto”来实现居中。后面的display:table; 方法会更简洁。 为什么加入table标签? 是利用table标签的长度自适应性—即不定义其长度也不默认父元素body的长度（table其长度根据其内文本长度决定），因此可以看做一个定宽度块元素，然后再利用定宽度块状居中的margin的方法，使其水平居中。 12345678910111213141516table&#123; margin:0 auto;&#125;&lt;div&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt; &lt;ul&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt; 123456789.wrap&#123; background:#ccc; display:table; margin:0 auto;&#125;&lt;div class=\"wrap\"&gt; Hello world &lt;/div&gt; 方法2： 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。 这种方法相比第一种方法的优势是不用增加无语义标签，但也存在着一些问题：它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值（变成inline-block就可以设置宽高）。 12345678910111213141516.container&#123; text-align:center; &#125;.container ul&#123; list-style:none; margin:0; padding:0; display:inline; //怎么这一句用不用都是一样效果的？ &#125;&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;li&gt;Hello world&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 方法3： 通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。 先设置父元素wrap清除浮动，然后左浮动。定位让wrap向右偏移50%。然后定义子元素相对于父元素向左偏移50%。脱离父元素。加个边框就可以明白一些了。另外用绝对定位也是可以的。123456789101112131415 .wrap&#123; float:left; position:relative; left:50%; clear:both;&#125;.wrap-center&#123; background:#ccc; position:relative; left:-50%;&#125;&lt;div class=\"wrap\"&gt; &lt;div class=\"wrap-center\"&gt;Hello world&lt;/div&gt;&lt;/div&gt; 二、垂直居中垂直居中可分为父元素高度确定的单行文本，以及父元素高度确定的多行文本。 1、父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高，指在文本中，行与行之间的 基线间的距离 )。 12345678910.wrap h2&#123; margin:0; height:100px; line-height:100px; background:#ccc;&#125;&lt;div class=\"wrap\"&gt; &lt;h2&gt;Hello world&lt;/h2&gt;&lt;/div&gt; 2、父元素高度确定的多行文本 有两种方法： 方法1：使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。 css12345678910111213141516171819.wrap&#123; height:300px; background:#ccc; vertical-align:middle; /* td 标签默认情况下就默认设置了 vertical-align 为 middle，可以不需要显式地设置 */&#125;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"wrap\"&gt; &lt;div&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 方法2： 设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性。但这种方法兼容性比较差， IE6、7 并不支持这个样式。 12345678910111213.wrap&#123; height:300px; background:#ccc; display:table-cell;/*IE8以上及Chrome、Firefox*/ vertical-align:middle;/*IE8以上及Chrome、Firefox*/&#125;&lt;div class=\"wrap\"&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Hello world&lt;/p&gt;&lt;/div&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"css","slug":"技术/前端基础知识/css","permalink":"http://yoursite.com/categories/技术/前端基础知识/css/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"居中","slug":"居中","permalink":"http://yoursite.com/tags/居中/"}]},{"title":"CSS3","slug":"CSS3","date":"2018-06-23T09:31:49.479Z","updated":"2018-06-19T02:54:14.788Z","comments":true,"path":"2018/06/23/CSS3/","link":"","permalink":"http://yoursite.com/2018/06/23/CSS3/","excerpt":"引入方式：1、内联方式 Inline Styles 这一行的字体颜色将显示为红色 2、内部样式块对象 Embedding a Style Block 12345&lt;style&gt; .test2 &#123; color: #000; &#125;&lt;/style&gt;","text":"引入方式：1、内联方式 Inline Styles 这一行的字体颜色将显示为红色 2、内部样式块对象 Embedding a Style Block 12345&lt;style&gt; .test2 &#123; color: #000; &#125;&lt;/style&gt; 3、外部样式表 Linking to a Style Sheet 你可以先建立外部样式表文件*.css，然后使用 HTML 的 link 对象。或者使用 @import 来引入。 示例代码： 1234567&lt;!-- Use link elements --&gt;&lt;link rel=\"stylesheet\" href=\"core.css\"&gt;&lt;!-- Use @imports --&gt;&lt;style&gt; @import url(\"more.css\");&lt;/style&gt; 二、选择器权重权重主要分为 4 个等级： 第一等：代表内联样式，如: style=””，权值为1000 第二等：代表ID选择器，如：#content，权值为100 第三等：代表类，伪类和属性选择器，如.content，权值为10 第四等：代表类型选择器和伪元素选择器，如div p，权值为1 动画CSS3 @keyframes 规则要创建CSS3动画，你将不得不了解@keyframes规则。@keyframes规则是用来创建动画。 @keyframes规则内指定一个 CSS样式和动画将逐步从目前的样式更改为新的样式。 CSS3 动画当在@keyframe创建动画，把它绑定到一个选择器，否则动画不会有任何效果。指定至少这两个 CSS3 的动画属性绑定向一个选择器： 规定动画的名称 规定动画的时长 例子： 12345#animated_div &#123; animation: animated_div 5s infinite; -moz-animation: animated_div 5s infinite; -webkit-animation: animated_div 5s infinite;&#125; 常用属性 第一部分：CSS Transition在CSS 3引入Transition（过渡）这个概念之前，CSS是没有时间轴的。也就是说，所有的状态变化，都是即时完成。 123456789img&#123; height:15px; width:15px;&#125;img:hover&#123; height: 450px; width: 450px;&#125; transition的作用在于，指定状态变化所需要的时间。 123img&#123; transition: 1s;&#125; 我们还可以指定transition适用的属性，比如只适用于height。 123img&#123; transition: 1s height;&#125; transition-delay在同一行transition语句中，可以分别指定多个属性。 123img&#123; transition: 1s height, 1s width;&#125; 我们希望，让height先发生变化，等结束以后，再让width发生变化。实现这一点很容易，就是为width指定一个delay参数。123img&#123; transition: 1s height, 1s 1s width;&#125; transition-timing-functionransition的状态变化速度（又称timing function），默认不是匀速的，而是逐渐放慢，这叫做ease。 除了ease以外，其他模式还包括: （1）linear：匀速 （2）ease-in：加速 （3）ease-out：减速 （4）cubic-bezier函数：自定义速度模式 transition的各项属性:transition的完整写法如下 123img&#123; transition: 1s 1s height ease;&#125; transition的局限transition的优点在于简单易用，但是它有几个很大的局限。 （1）transition需要事件触发，所以没法在网页加载时自动发生。 （2）transition是一次性的，不能重复发生，除非一再触发。 （3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 （4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 CSS Animation就是为了解决这些问题而提出的。 第二部分：CSS Animation首先，CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。123div:hover &#123; animation: 1s rainbow;&#125; 上面代码表示，当鼠标悬停在div元素上时，会产生名为rainbow的动画效果，持续时间为1秒。为此，我们还需要用keyframes关键字，定义rainbow效果。 12345@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 默认情况下，动画只播放一次。加入infinite关键字，可以让动画无限次播放。 123div:hover &#123; animation: 1s rainbow infinite;&#125; 也可以指定动画具体播放的次数，比如3次。 123div:hover &#123; animation: 1s rainbow 3;&#125; animation-fill-mode动画结束以后，会立即从结束状态跳回到起始状态。如果想让动画保持在结束状态，需要使用animation-fill-mode属性。123div:hover &#123; animation: 1s rainbow forwards;&#125; forwards表示让动画停留在结束状态，效果如下。 animation-fill-mode还可以使用下列值: （1）none：默认值，回到动画没开始时的状态。 （2）backwards：让动画回到第一帧的状态。 （3）both: 根据animation-direction（见后）轮流应用forwards和backwards规则。 animation-direction动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变这种行为。 下面看一个例子，来说明如何使用animation-direction。假定有一个动画是这样定义的。 1234@keyframes rainbow &#123; 0% &#123; background-color: yellow; &#125; 100% &#123; background: blue; &#125;&#125; 默认情况是，animation-direction等于normal。此外，还可以等于取alternate、reverse、alternate-reverse等值。它们的含义见下图（假定动画连续播放三次）。简单说，animation-direction指定了动画播放的方向，最常用的值是normal和reverse。浏览器对其他值的支持情况不佳，应该慎用。 animation的各项属性同transition一样，animation也是一个简写形式。 123div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125; 下面来介绍下边框：CSS3 Border（边框）主要有以下属性： border-radius box-shadow border-image border-radius （圆角边框） 1border-radius: 25px; box-shadow （边框阴影）1box-shadow: 15px 15px 5px #888245; border-image （边框图片） 1234-moz-border-image: url(/images/border.png) 30 30 round; /* Firefox */ -webkit-border-image: url(/images/border.png) 30 30 round; /* Safari and Chrome */ -o-border-image: url(/images/border.png) 30 30 round; /* Opera */ border-image: url(/images/border.png) 30 30 round; 接下来是背景知识：主要是2个背景属性： background-size background-origin background-size 该属性规定背景图片的尺寸。在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以规定背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。您能够以像素或百分比规定尺寸。如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。 background-origin 该属性指定了背景图像的位置区域。content-box, padding-box,和 border-box 区域内可以放置背景图像。 字体以前 CSS3 的版本，网页设计师不得不使用用户计算机上已经安装的字体。使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。您所选择的字体在新的 CSS3 版本有关于@font-face规则描述。您”自己的”的字体是在 CSS3 @font-face 规则中定义的。 在 @font-face 规则中，您必须首先定义字体的名称（比如 FontAwesome ），然后指向该字体文件 fontawesome-webfont.woff 。 1234@font-face &#123; font-family: 'FontAwesome'; src: url('fonts/fontawesome-webfont.woff');&#125; 文本效果SS3 文本效果是这样一个术语用来在正常的文本中实现一些额外的特性。主要是两个属性的 CSS3 文本效果,如下: text-shadow word-wrap text-shadow 文本阴影。 您指定了水平阴影，垂直阴影，模糊的距离，以及阴影的颜色：123.text-shadow &#123; text-shadow: 10px 10px 10px #6AAFCF;&#125; word-wrap换行。 CSS3中，自动换行属性允许您强制文本换行 - 即使这意味着分裂它中间的一个字： 12345.word-wrap &#123; word-wrap: break-word; width: 150px; border: 1px solid #ff0000;&#125; 2D 转换CSS3 2D转换，我们可以斜拉(skew)，缩放(scale)，旋转(rotate)以及位移(translate)元素。 常用 2D 变换方法： translate() rotate() scale() skew() matrix() translate()translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动 rotate()rotate()方法，在一个给定度数沿着元素中心顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。 123456.rotate&#123; transform:rotate(30deg); -ms-transform:rotate(30deg); /* IE 9 */ -webkit-transform:rotate(30deg); /* Safari and Chrome */&#125; scale()scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数：123456.scale&#123; transform: scale(2,4); -ms-transform: scale(2,4); /* IE 9 */ -webkit-transform: scale(2,4); /* Safari and Chrome */&#125; skew()skew()方法，该元素会根据横向（X轴）和垂直（Y轴）线参数给定角度：123456.skew&#123; transform:skew(30deg,20deg); -ms-transform:skew(30deg,20deg); /* IE 9 */ -webkit-transform:skew(30deg,20deg); /* Safari and Chrome */&#125; matrix()matrix()方法和2D变换方法合并成一个。matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。 3D 转换CSS3 3D Transform,用于 3 维动画或旋转。CSS3 3D 转换是一个属性,用于改变元素的实际形式。这个特性可以改变元素的形状、大小和位置。主要有下列方法： rotateX() rotateY() rotateZ() 注意：Internet Explorer 10 和 Firefox 支持 3D 转换； Chrome 和 Safari 必须添加前缀 -webkit-； Opera 还不支持 3D 转换(支持 2D 转换 ) rotateX()rotateX()方法，围绕其在一个给定度数X轴旋转的元素。1234.rotate-x &#123; transform: rotateX(60deg); -webkit-transform: rotateX(120deg); /* Safari and Chrome */&#125; y、z轴 类似。 rotate3d()otate3d(x,y,z,a)中取值说明： x：是一个0到１之间的数值，主要用来描述元素围绕X轴旋转的矢量值； y：是一个０到１之间的数值，主要用来描述元素围绕Y轴旋转的矢量值； z：是一个０到１之间的数值，主要用来描述元素围绕Z轴旋转的矢量值； a：是一个角度值，主要用来指定元素在3D空间旋转的角度，如果其值为正值，元素顺时针旋转，反之元素逆时针旋转。 面介绍的三个旋转函数功能等同： &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"css3","slug":"技术/前端基础知识/css3","permalink":"http://yoursite.com/categories/技术/前端基础知识/css3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"Chrome DevTools 技巧","slug":"Chrome DevTools技巧2","date":"2018-06-23T09:31:49.435Z","updated":"2018-06-21T02:00:14.982Z","comments":true,"path":"2018/06/23/Chrome DevTools技巧2/","link":"","permalink":"http://yoursite.com/2018/06/23/Chrome DevTools技巧2/","excerpt":"","text":"1、调试窗口切换： mac： command+alt+i win: F12 2、页面元素调试 保持住 hover 的状态，右键可以看到 hover: 单击选中即可。 3、元素状态改变的监控方法 右键 4、样式调试 盒模型调试 5、查看元素最终样式 选 computed 6、元素事件监听查看 event Listeners 7、console 8、如何查看被压缩 js css 的源码 点下面的{} format 9、查看整站加载的资源 sources 10、调试 JavaScript 的 call stack 堆栈 11、编辑源文件同步到本地文件里 source—-filesystem—+ ——添加本地文件 12、网络请求监控 network 13、监控页面重绘的方法 More tools—-Rendering—-paint flashing 14、如何监控并统计没有使用的脚本 More tools—-coverage —点小黑点变红 15、如何监控页面的动画变更 More tools—-Animation 16、网络条件与 user-Agent 的设置 More tools—-Network condition 17、快速以编辑状态查看一个站点加载的所有资源 scource—-ctr+p 18、调试 Android 设备的方法 More tools—Remote devices 19、如何让浏览器阻止请求某些资源 More tools–Request blocking 用正则的方法css 去掉包含css的文件 ad 去掉广告 20、如何对站点下所有的资源进行全部搜索 More tools–Search 21、如何在浏览器中模拟一些传感器数据 22、性能分析 Performance CPU设置 recoding 帧率fps 一秒改变多少 页面加载的过程中那部分比较卡 Call Tree 跳到源码里看看哪里比较耗时。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Chrome DevTools","slug":"技术/Chrome-DevTools","permalink":"http://yoursite.com/categories/技术/Chrome-DevTools/"}],"tags":[{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://yoursite.com/tags/Chrome-DevTools/"}]},{"title":"Chrome DevTools 技巧","slug":"Chrome DevTools技巧","date":"2018-06-23T09:31:49.384Z","updated":"2018-06-12T12:21:09.152Z","comments":true,"path":"2018/06/23/Chrome DevTools技巧/","link":"","permalink":"http://yoursite.com/2018/06/23/Chrome DevTools技巧/","excerpt":"1、拖拽面板中的元素","text":"1、拖拽面板中的元素 2、在控制台控制选中的元素 3、添加CSS并编辑元素的状态在元素面板有两个很好用的按钮add css: 4、找到css属性被定义在什么位置ctrl-click on Windows ctrl 键点击属性，可以定位","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"Chrome DevTools","slug":"技术/Chrome-DevTools","permalink":"http://yoursite.com/categories/技术/Chrome-DevTools/"}],"tags":[{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://yoursite.com/tags/Chrome-DevTools/"}]},{"title":"CSS 媒体查询","slug":"前端基础知识整理6","date":"2018-06-11T13:08:25.000Z","updated":"2018-06-12T12:22:09.690Z","comments":true,"path":"2018/06/11/前端基础知识整理6/","link":"","permalink":"http://yoursite.com/2018/06/11/前端基础知识整理6/","excerpt":"&ensp; &ensp;所谓的媒体查询就是指，不同的条件使用不同的样式或样式集合。 @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式","text":"&ensp; &ensp;所谓的媒体查询就是指，不同的条件使用不同的样式或样式集合。 @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式 一、CSS 语法 device-width 和 width的区别： device-width表示的是设备的宽度，即屏幕的宽度。width所代表的是文档宽度，与屏幕大小没有关系，如果是在移动设备上，width表示的是布局视口的宽度。 必要的空格。 12//空格是有必要的，在某些情况下该样式永远不起作用。&lt;link rel=\"stylesheet\" media=\"(min-device-width:400px)【空格】and【空格】(max-device-width:900px)\" href=\"css/style1.css\"&gt; 语法示例： 12345678910&lt;!-- link元素中的CSS媒体查询 --&gt;&lt;link rel=\"stylesheet\" media=\"(max-width: 800px)\" href=\"example.css\" /&gt; //对什么状况下使用&lt;!-- 样式表中的CSS媒体查询 --&gt;&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 二、可供媒体查询检测的特性 width:视口宽度 height:视口高度 device-width:设备屏幕的宽度 device-height:设备屏幕的高度 orientation:检测设备处于横向还是纵向 aspect-radio:基于视口宽度和高度的宽高比 device-sapect-radio:基于设备渲染平面宽度和高度的宽高比 color:每种颜色的位数 color-index:设备的颜色索引表中的颜色数 monochrome:检测单色帧缓冲区中每像素所使用的位数 resolution:用来检测屏幕或打印机的分辨率， scan:电视机的烧苗方式，值可设为progressive(逐行扫描)或interlace(隔行扫描) 用来检测输出设备是网格设备还是位图设备 三、逻辑操作 and，且的关系，当所有的条件满足的时候返回true12345678//一个基本的媒体查询，即一个媒体属性和默认指定的all媒体类型@media (min-width:700px)&#123;&#125;//如果你只想再横屏时候应用,你可以使用and操作符合并媒体属性(min-width:700px)and(orientation:landscape)&#123;&#125;//如果你仅想在电视媒体上应用@media tv and (min-width:700px) and (orientation:landscape)&#123;&#125; 逗号分割列表，或的关系，只要有条件满足就返回ture not，类似于取反，最后参与运算的运算符 only，only关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"媒体查询","slug":"技术/前端基础知识/媒体查询","permalink":"http://yoursite.com/categories/技术/前端基础知识/媒体查询/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"媒体查询","slug":"媒体查询","permalink":"http://yoursite.com/tags/媒体查询/"}]},{"title":"CSS 弹性盒子Flexbox","slug":"前端基础知识整理5","date":"2018-06-11T13:08:25.000Z","updated":"2018-06-12T07:11:23.380Z","comments":true,"path":"2018/06/11/前端基础知识整理5/","link":"","permalink":"http://yoursite.com/2018/06/11/前端基础知识整理5/","excerpt":"&ensp; &ensp;布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 一、Flex 布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。","text":"&ensp; &ensp;布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 一、Flex 布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 ####二、基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 ####三、容器的属性 以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.flex-direction flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端 flex-flow column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 2.flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 4.justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5.align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6.align-content属性123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1.order属性123.item &#123; order: &lt;integer&gt;;&#125; 4.2.flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 &lt;完&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"},{"name":"前端基础知识","slug":"技术/前端基础知识","permalink":"http://yoursite.com/categories/技术/前端基础知识/"},{"name":"Flexbox","slug":"技术/前端基础知识/Flexbox","permalink":"http://yoursite.com/categories/技术/前端基础知识/Flexbox/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Flexbox","slug":"Flexbox","permalink":"http://yoursite.com/tags/Flexbox/"}]}]}